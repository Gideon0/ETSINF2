INTRODUCCIÃ“N a la
TEORIÌA DE NÃšMEROS.
Ejemplos y algoritmos.

Prof. Walter Mora F.,
Escuela de MatemÃ¡tica
Instituto TecnolÃ³gico de Costa Rica.
(https://tecdigital.tec.ac.cr/revistamatematica/)

Este libro se distribuye bajo la licencia Creative Commons Reconocimiento - No Comercial - Sin obra
derivada 3.0 Unported License. Esta licencia permite copiado y distribuciÃ³n gratuita, pero no permite venta ni modificaciones de
este material. Ver http://creativecommons.org/.
LÃ­mite de responsabilidad y exenciÃ³n de garantÃ­a: El autor o los autores han hecho su mejor esfuerzo en la preparaciÃ³n de este
material. Esta ediciÃ³n se proporcionaâ€œtal cualâ€. Se distribuye gratuitamente con la esperanza de que sea Ãºtil, pero sin ninguna
garantÃ­a expresa o implÃ­cita respecto a la exactitud o completitud del contenido.
La Revista digital MatemÃ¡ticas, EducaciÃ³n e Internet es una publicaciÃ³n electrÃ³nica. El material publicado en ella expresa la
opiniÃ³n de sus autores y no necesariamente la opiniÃ³n de la revista ni la del Instituto TecnolÃ³gico de Costa Rica.
https://tecdigital.tec.ac.cr/revistamatematica/Libros/TeoriaNumeros/WMora_TeoriaNumeros.pdf

2

CopyrightÂ© Revista digital MatemÃ¡tica EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/). Primera EdiciÃ³n.
Correo ElectrÃ³nico: wmora2@gmail.com
Escuela de MatemÃ¡tica
Instituto TecnolÃ³gico de Costa Rica
Apdo. 159-7050, Cartago
TelÃ©fono (506)25502225
Fax (506)25502493

Mora Flores, Walter.
IntroducciÃ³n a la TeorÃ­a de NÃºmeros. Ejemplos y algoritmos. 1ra ed.
â€“ Escuela de MatemÃ¡tica,Instituto TecnolÃ³gico de Costa Rica. 2010.
219 pp.
ISBN Obra Independiente: 978-9968-641-11-1
1. TeorÃ­a de nÃºmeros. 2. Algoritmos 3. ProgramaciÃ³n.

Contenido

Prefacio

6
PARTE I

1

Fundamentos
1.1
1.2
1.3
1.4

2

Principios
Valor absoluto y la funciÃ³n sgn( x )
Las funciones TxU VxW y JxK
NÃºmeros Poligonales y Piramidales
Ejercicios

2
2
5
5
7
11

Divisibilidad

14

2.1

15
17
18
21
22
27
29
31
32
34
36
39
43

2.2
2.3
2.4
2.5
2.6
2.7
2.8

3

INTRODUCCCION A LA TEORIA DE NUMEROS.

â€œAlgoritmo de la divisiÃ³nâ€
Ejercicios
NÃºmeros Primos.
Criba de EratÃ³stenes: CÃ³mo colar nÃºmeros primos.
2.3.1
Algoritmo e implementaciÃ³n.
MÃ¡ximo comÃºn divisor
Algoritmo de Euclides I.
2.5.1
Algoritmo e implementaciÃ³n.
Algoritmo Extendido de Euclides.
2.6.1
Algoritmo e implementaciÃ³n.
Ecuaciones DiofÃ¡nticas lineales.
Teorema fundamental de la aritmÃ©tica
Ejercicios

Congruencias

47
3

4

CONTENIDO

3.1
3.2
3.3
3.4
3.5
3.6
3.7
3.8

4

Potencias mod m
4.1
4.2
4.3
4.4
4.5

5

IntroducciÃ³n
RaÃ­ces Primitivas
Logaritmo discreto o Indicador
Ejercicios

Residuos CuadrÃ¡ticos
6.1
6.2
6.3

6.4

7

Orden de un elemento mÃ³dulo m.
El Teorema â€œpequeÃ±oâ€ de Fermat.
Teorema de Euler
4.3.1
Un recÃ­proco del Teorema pequeÃ±o de Fermat
Teorema de Wilson
Teorema de Carmichael
Ejercicios

RaiÌces primitivas y logaritmo discreto
5.1
5.2
5.3

6

Congruencias mÃ³dulo m
(*) Calendarios: Â¿QuÃ© dÃ­a naciÃ³ Ud?.
Trucos de divisibilidad.
(*) Cuadrados MÃ¡gicos
Clases residuales mÃ³dulo m
Congruencias lineales
Teorema Chino del resto
Congruencias de Orden Superior
Ejercicios

Congruencias cuadrÃ¡ticas mÃ³dulo m
Criterio de Euler
SÃ­mbolos de Legendre y Jacobi
6.3.1
Lema de Gauss
6.3.2
Ley de Reciprocidad CuadrÃ¡tica.
SÃ­mbolo de Jacobi.
Ejercicios

47
50
52
53
56
61
63
66
67
71
71
73
75
82
83
85
88
92
92
92
97
101
104
104
106
108
112
115
121
123

Estimaciones, EstadÃ­sticas y Promedios

126

7.1
7.2
7.3
7.4

126
130
132
134
134
136
138
140
143
146

7.5

7.6

Funciones AritmÃ©ticas
A los nÃºmeros primos les gusta los juegos de azar.
Orden de Magnitud
Teorema de los nÃºmeros primos
7.4.1
FÃ³rmula de Legendre para Ï€ ( x ).
7.4.2
FÃ³rmula de Meisel para Ï€ ( x ).
EstimaciÃ³n de Ï€ ( x ). Teorema de los nÃºmeros primos.
7.5.1
La funciÃ³n Zeta de Riemann
7.5.2
Teorema de Mertens.
NÃºmeros ArmÃ³nicos

5

7.7

Acerca de los factores de un nÃºmero grande
Ejercicios
PARTE II

8

INTRODUCCION A LA TEORIA ALGORITMICA DE NUMEROS.

Algoritmos para el mcd

153

8.1
8.2
8.3

154
155
159
160
162
163
164
165
168
169
170
170

8.4
8.5
8.6
8.7
8.8
9

148
150

Parte entera.
DivisiÃ³n con menor resto.
Algoritmo de Euclides II.
8.3.1
Algoritmo e implementaciÃ³n.
Algoritmo de Euclides con menor resto.
8.4.1
ImplementaciÃ³n.
Algoritmo binario.
8.5.1
Algoritmo e ImplementaciÃ³n.
Algoritmo LSBGCD (left-shift binary algorithm)
8.6.1
Algoritmo e ImplementaciÃ³n.
Algoritmo Extendido de Euclides.
Inversos multiplicativos en m

NÃºmeros Primos y factorizaciÃ³n.

173

9.1
9.2
9.3
9.4

173
175
177
183
183
184
190
192
195
195
196
198
200
201
202
207

IntroduccciÃ³n
Criba de EratÃ³stenes.
Primos entre m y n.
FactorizaciÃ³n por ensayo y error.
9.4.1
Probando con una progresiÃ³n aritmÃ©tica.
9.4.2
Algoritmo.
9.5
MÃ©todo de factorizaciÃ³n â€œrhoâ€ de Pollard.
9.5.1
Algoritmo e implementaciÃ³n.
Ejercicios
9.6
Pruebas de Primalidad.
9.7
Prueba de primalidad de Miller-Rabin.
9.7.1
Algoritmo e implementaciÃ³n.
Ejercicios
9.8
Algoritmo Chino del Resto.
9.8.1
Algoritmo e implementaciÃ³n.
BibliografÃ­a
BibliografÃ­a

207

SoluciÃ³n de los Ejercicios
Soluciones del CapÃ­tulo 2

208
208

Prefacio

La TeorÃ­a de NÃºmeros estudia los nÃºmeros enteros y, en cierta medida los nÃºmeros racionales
y los nÃºmeros algebraicos. La TeorÃ­a Computacional de NÃºmeros (Computational Number Theory) es sinÃ³nimo de TeorÃ­a AlgorÃ­tmica de NÃºmeros. AquÃ­ se estudia los algoritmos eficientes
para cÃ¡lculos en teorÃ­a de nÃºmeros. Este es un libro introductorio orientado hacia la teorÃ­a algorÃ­tmica de nÃºmeros. El interÃ©s es mostrar el valor puramente teÃ³rico de algunos teoremas y
cÃ³mo se debe hacer una variaciÃ³n si el propÃ³sito es cÃ¡lculos rÃ¡pidos y eficientes. Algunas algoritmos sencillos se implementan en VBA Excel o en LibreOffice Basic por ser lenguajes muy
amigables y por ser las hojas electrÃ³nicas muy familiares para los estudiantes. Sin emabargo estas implementaciones son muy lÃ­mitadas y solo tienen fines didÃ¡cticos. Otras implementaciones
se hacen en Java (para usar enteros y racionales grandes). En el capÃ­tulo final se desarrollan
algunos programas en Java que sirven de base para implementar otros algoritmos.
Agradezco a las personas que ayudaron con sus comentarios para corregir errores en el texto y
los programas y para mejorar algunos pÃ¡rrafos un tanto oscuros. Las actualizaciones del libro
(correcciones, nuevos programas, etc.,) estarÃ¡n en https://tecdigital.tec.ac.cr/revistamatematica//Libros/.
TambiÃ©n puede solicitar un â€™machoteâ€™ LaTeX del libro.

W. MORA.
Cartago, Costa Rica
Diciembre, 2014.

Parte I

INTRODUCCCION A LA TEORIA DE
NUMEROS.

235711
131719
232931
235711

1
1.1

FUNDAMENTOS

Principios

Los nÃºmeros enteros son el ingrediente principal en teorÃ­a de nÃºmeros. En esta secciÃ³n, establecemos brevemente la notaciÃ³n y el significado de algunos sÃ­mbolos que se relacionan con los
enteros y que serÃ¡n de amplio uso en el texto. AdemÃ¡s se establecen algunos principios que se
usan ampliamente en los argumentos.
En lo que sigue, usaremos la siguiente notaciÃ³n

a.) N = {0, 1, 2, ...} y N+ = {1, 2, ...}.
b.) Z+ = {1, 2, ...} = N+
c.) R+ = { x âˆˆ R : x > 0}.

Principio del Buen Orden: Todo conjunto no vacÃ­o de nÃºmeros naturales contiene un elemento
mÃ­nimo.
En particular, si S âŠ‚ Z y si S tiene al menos un elemento positivo, entonces S tiene un entero
positivo mÃ­nimo.
Ejemplo 1.1
Probar que si a, b âˆˆ Z con b â‰¥ 1, entonces existe q âˆˆ Z tal que qb â‰¤ a < (q + 1)b.
SoluciÃ³n: Idea: qb serÃ­a el mÃºltiplo de b mÃ¡s cercano a a en el sentido de que el
siguiente mÃºltiplo, (q + 1)b, lo sobrepasa; por tanto a âˆ’ qb â‰¥ 0 serÃ­a la resta no negativa
mÃ­nima. La existencia de este elemento mÃ­nimo se puede establecer usando el principio
del buen orden.
Sea S = { a âˆ’ nb tal que n âˆˆ Z âˆ§ a âˆ’ nb â‰¥ 0}. Primero probamos que S es no vacÃ­o. En
efecto, Si a â‰¥ 0, a = a âˆ’ 0 Â· b â‰¥ 0, entonces a âˆˆ S. Si a < 0, a âˆ’ ab = a(1 âˆ’ b) â‰¥ 0 pues
b â‰¥ 1, entonces a âˆ’ ab âˆˆ S. Por el principio del buen orden, S tiene un elemento mÃ­nimo
a âˆ’ qb â‰¥ 0 y, por tanto a âˆ’ (q + 1)b < 0. AsÃ­, qb â‰¤ a < (q + 1)b.

Principio del palomar: Si k es un entero positivo y k + 1 o mÃ¡s objetos son asignados a k cajas,
entonces hay al menos alguna caja a la que se le asignaron dos o mÃ¡s objetos.
Ejemplo 1.2
En un grupo de 367 personas, debe haber al menos dos que cumplen aÃ±os el mismo dÃ­a,
porque hay solo 366 posibles dÃ­as para cumplir aÃ±os.

Principio de InclusiÃ³n-ExclusiÃ³n: Sean A y B dos conjuntos finitos. Entonces

| A âˆª B | = | A | + | B | âˆ’ | A âˆ© B |.

Ejemplo 1.3
Sea A = { a, b, c, d} y B = { a, b, c, g, h}. | A| = 4, | B| = 5, | A âˆª B| = |{ a, b, c, d, g, h}| = 6 y
| A âˆ© B| = |{ a, b, c}| = 3. Luego, | A âˆª B| = 6 = | A| + | B| âˆ’ | A âˆ© B| = 4 + 5 âˆ’ 3.

Principio de InducciÃ³n: Para probar que una proposiciÃ³n P(n) es verdadera para todo entero
positivo n, se deben ejecutar los dos pasos siguientes:
a.) Verificar que P(n) se cumple para n = 1,
b.) Probar que si se cumple P(k) (hipÃ³tesis de inducciÃ³n), entonces se cumple P(k + 1)

Figura 1.1. Idea de inducciÃ³n matemÃ¡tica usando un juego de domino.
3

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

4

FUNDAMENTOS

Se puede probar que el principio de inducciÃ³n es un mÃ©todo vÃ¡lido de prueba si asumimos el
principio del buen orden como un axioma.

Ejemplo 1.4
HistÃ³ricamente, el primer ejemplo que se conoce en el que se usÃ³ inducciÃ³n matemÃ¡tica
aparece en el libro â€œArithmeticorum Libri Duoâ€ de Francesco Maurolico (1494-1575). En
este libro, entre otras cosas, Maurolico presenta gran variedad de propiedades de los
enteros y las pruebas de estas propiedades. Para las demostraciones, Ã©l ideo el mÃ©todo
de inducciÃ³n matemÃ¡tica. La primera vez que se usa el mÃ©todo, es para probar que la
suma de los primeros n enteros impares es n2 . El nombre â€œinducciÃ³n matemÃ¡ticaâ€, lo
usÃ³ por primera vez el matemÃ¡tico inglÃ©s John Wallis.

Figura 1.2. Francesco Maurolico. â€œArithmeticorum Libri Duoâ€, pÃ¡g 7. En www.books.google.com

Probar que 1 + 3 + 5 + ... + (2n âˆ’ 1) = n2
SoluciÃ³n: En este caso, n indica el nÃºmero de sumandos.
a.) La proposiciÃ³n es correcta para n = 1 pues 1 = 12
b.) HipÃ³tesis de inducciÃ³n: suponemos que la proposiciÃ³n es cierta para n = k, es decir,
1 + 3 + 5 + ... + 2k âˆ’ 1 = k2 . Ahora sumamos el siguiente impar, 2k âˆ’ 1 + 2 = 2k + 1,
a ambos lados,
k2

}|
{
z
1 + 3 + 5 + ... + 2k âˆ’ 1 + 2k + 1 = k2 + 2k + 1 = (k + 1)2 .
Por lo tanto, hemos demostrado que si la proposiciÃ³n es correcta para n = k, es
correcta para n = k + 1. Entonces, la fÃ³rmula es vÃ¡lida para todo n âˆˆ N, por el
principio de inducciÃ³n.

Principio de InducciÃ³n Completa: Para probar que una proposiciÃ³n P(n) es verdadera para
todo entero positivo n, se deben ejecutar los dos pasos siguientes:

a.) Verificar que P(n) se cumple para n = 1,
b.) Probar que si se cumple P(1) âˆ§ P(2) âˆ§ ... âˆ§ P(k) (hipÃ³tesis de inducciÃ³n), entonces se
cumple P(k + 1)

5

Se puede probar que el principio de inducciÃ³n completa es equivalente al principio de inducciÃ³n. Es decir, cada principio puede ser demostrado asumiendo el otro. La ganancia es que el
principio de inducciÃ³n completa es mÃ¡s flexible. A el principio de inducciÃ³n completa tambiÃ©n
se le llama "principio de inducciÃ³n fuerte" o "segundo principio de inducciÃ³n".

Ejemplo 1.5
Si n es un entero mayor que uno, n se puede escribir como un producto de primos. La
demostraciÃ³n de este hecho se hace con inducciÃ³n fuerte. Puede ver el teorema 2.14, que
estÃ¡ mÃ¡s adelante.

1.2

Valor absoluto y la funciÃ³n sgn( x )

Muchas veces es conveniente separar el nÃºmero y su signo. Para esto usamos la funciÃ³n â€œsignoâ€.
En las aplicaciones es necesario que esta funciÃ³n solo tome dos valores âˆ’1 y 1.

DefiniciÃ³n 1.1 (FunciÃ³n signo).
Definimos sgn( x ) = 1 si x â‰¥ 0 y sgn( x ) = âˆ’1 si x < 0.

Teorema 1.1
Sea a âˆˆ Z. Entonces, | a| = a Â· sgn( a) = a/sgn( a).

Ejemplo 1.6
a.) | âˆ’ 5| = âˆ’5 Â· sgn(âˆ’5) = âˆ’5 Â· âˆ’1 = 5

1.3

b.) |0| = 0/sgn(0) = 0/1 = 0

Las funciones TxU VxW y JxK

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

6

FUNDAMENTOS

DefiniciÃ³n 1.2 (Parte entera).

â€¢ FunciÃ³n TxU. Si x âˆˆ R y n âˆˆ Z tal que n â‰¤ x < n + 1 entonces TxU = n.
â€¢ FunciÃ³n VxW. Si x âˆˆ R y n âˆˆ Z tal que n âˆ’ 1 < x â‰¤ n entonces VxW = n.
â€¢ FunciÃ³n JxK.
JxK =

ï£±
ï£² TxU si

xâ‰¥0

ï£³

x<0

VxW si

Ejemplo 1.7
a.) T1.4U = 1

b.) V1.4W = 2

c.) Tâˆ’1.4U = âˆ’2

d.) Vâˆ’1.4W = âˆ’1

e.) Vâˆ’3W = Tâˆ’3U = âˆ’3.

RepresentaciÃ³n grÃ¡fica. Los grÃ¡ficos que siguen nos dan una idea clara del significado de cada
una de estas funciones.

y = TxU

y = VxW

3
2
1
4

3

2

1

1

1

2

3

y = JxK

4

4

3

3

2

2

1

1

4

2
3
4

4

3

2

1

1

1

2

3

4

4

3

2

1

1

2

2

3

3

1

2

Ejemplo 1.8
Probar que Tâˆ’ xU = âˆ’VxW.
SoluciÃ³n: Supongamos que Tâˆ’ xU = n, es decir, n â‰¤ âˆ’ x < n + 1.
âˆ’n âˆ’ 1 < x â‰¤ âˆ’n, es decir, VxW = âˆ’n. âˆ´ Tâˆ’ xU = âˆ’VxW.

Entonces

3

4

7

Ejemplo 1.9
Sea n âˆˆ Z. Entonces n = 2k o n = 2k + 1 para algÃºn entero k, ya sea que n es par o
impar.
s
{ s
{
nâˆ’3
2k âˆ’ 2
a.) Si n = 2k + 1 â‰¥ 3, entonces
=
=kâˆ’1
2
2
s
{ s
{ s
{
nâˆ’3
2k âˆ’ 3
1
b.) Si n = 2k â‰¥ 3, entonces
=
= kâˆ’1âˆ’
=kâˆ’2
2
2
2
p âˆ’ 1 r pz
âˆ’
= 4k âˆ’ 1 âˆ’ (2k âˆ’ 1) = 2k
c.) Si p = 8k âˆ’ 1 > 3, entonces
2
4

Ejemplo 1.10 (Conteo).
Si x > 0, el nÃºmero JxK cuenta la cantidad de enteros positivos menores o iguales a x
pues, por definiciÃ³n, si JxK = k entonces 1, 2, ..., k son menores que x.
Sea p un entero positivo y x â‰¥ p. Tx/pU cuenta la cantidad de enteros â‰¤ x divisibles
por p. En efecto, los enteros positivos divisibles por p e inferiores a x son los k nÃºmeros
p < 2p < ... < k Â· p â‰¤ x. Como kp â‰¤ x < (k + 1) p, entonces k = Tx/pU.

1.4

NÃºmeros Poligonales y Piramidales

Los nÃºmeros figurados son enteros positivos que pueden ser representados por patrones geomÃ©tricos. Los nÃºmeros poligonales son nÃºmeros figurados que se pueden representar por medio de polÃ­gonos regulares en el plano. Los nÃºmeros piramidales son nÃºmeros que pueden ser representados
por formas piramidales. Ellos son obtenidos tomando sumas de los correspondientes nÃºmeros
poligonales.
NÃºmeros cuadrados. Los PitagÃ³ricos usaban la palabra gnomon (= ) para referirse a los enteros impares 1, 3, 5, 7, ... . De manera figurada, cada gnomon es una â€œconfiguraciÃ³nâ€ de puntos
que se agrega a la configuraciÃ³n anterior, manteniendo su forma (figura 1.3). Ellos observaron
que n2 es la suma de los n primeros impares,
1

= 12 ,

1+3

= 22 ,

1+3+5

= 32 ,

1+3+5+7

= 42
..
.

8

FUNDAMENTOS

En el ejemplo (1.2) ya habÃ­amos indicado que Francesco Maurolico (1494-1575), probÃ³ este hecho
usando por primera vez, inducciÃ³n matemÃ¡tica. Una â€œprueba geomÃ©tricaâ€ se puede observar en
la figura (1.3).

Figura 1.3. Cada cuadrado es construido agregando un nÃºmero impar (los cÃ­rculos azules)

Los nÃºmeros cuadrados sn , corresponden a la cantidad de puntos en un
arreglo cuadrangular de n Ã— n. En este caso sn = n2 . A los nÃºmeros
sn tambiÃ©n se les llama cuadrados perfectos, y como acabamos de ver,
son una suma de nÃºmeros impares. TambiÃ©n notamos en el ejemplo
1.2 que sn+1 = sn + 2n + 1, es decir, el siguiente cuadrado perfecto se
obtiene agregando un gnomon (la escuadra de 2n + 1 puntos azules) al
nÃºmero figurado anterior.

9

8

7

6

5

7

6

5

4

4

5

4

3

3

3

3

2

2

2

2

1

1

1

1

1

Figura 1.4. Cuadrados perfectos.

Ley de la caÃ­da de los cuerpos de Galileo. En 1590 Galileo estableciÃ³, usando
relojes de agua, que un objeto inicialmente estacionario que se deja caer libremente
por gravedad (ignorando resistencia del aire y rotaciÃ³n de la tieraa), cae una distancia
que es proporcional al cuadrado del tiempo transcurrido. La imagen de la derecha,
que abarca medio segundo, fue capturada con un flash estroboscÃ³pico en 20 destellos
por segundo. Durante el primer 1/20 de segundo la bola cae una unidad de distancia
(aquÃ­, una unidad es aproximadamente 12 mm); a los 3/20 de segundo llevamos 4
unidades, a los 5/20 de segundo llevamos 9 unidades, a los 7/20 de segundo llevamos
16 unidades, etc. En general, un cuerpo cae en distancias proporcionales a los tiempos
1, 1 + 3, 1 + 3 + 5 , 1 + 3 + 5 + 7, ... asÃ­ que la distancia total de caÃ­da es proporcional
al cuadrado del tiempo. La constante de proporcionalidad (cerca de la superficie de la
tierra) es 0.5g y la la fÃ³rmula para la distancia recorrida en la caÃ­da es d(t) = 12 g t2 .
NÃºmeros TriÃ¡ngulares. Los nÃºmeros triangulares tn corresponden a la cantidad de cÃ­rculos (o
puntos u otra cosa) en un arreglo triangular con n columnas, como se ve en la figura (1.5).
2

3

4
5

3

1

2

1

1

9
4

9

3
6

4

5
7
6

10
8

2
5
1

12
8

3

14
11

7
2

15
13

10
6

1

Figura 1.5. NÃºmeros triangulares t1 = 1, t2 = 3, t3 = 6, t4 = 10, ...

Como cada columna tiene un elemento mÃ¡s que la columna anterior, tenemos que
tn = 1 + 2 + Â· Â· Â· + n âˆ’ 1 + n

9

Podemos tomar dos copias de tn y hacerlas encajar, de tal manera que obtengamos un rectÃ¡ngulo,como se ve en la figura (1.6).

Figura 1.6. 2t1 = 2 Â· 1, 2t2 = 3 Â· 2, 2t3 = 4 Â· 3, ...

Esto nos lleva de inmediato a la fÃ³rmula cerrada tn =

n ( n + 1)
.
2

La figura (1.7) tambiÃ©n constituye una â€œprueba geomÃ©tricaâ€ (base para una conjetura) de la
relaciÃ³n entre nÃºmeros triangulares y cuadrados, tn + tnâˆ’1 = sn

Figura 1.7. tn + tnâˆ’1 = sn

Es fÃ¡cil responder la pregunta Â¿CuÃ¡ndo un nÃºmero triangular es cuadrado?. Esto sucede si
tn = sm , ahora usamos nuestras fÃ³rmulas,
tn = sm â‡â‡’

n ( n + 1)
= m2 â‡â‡’ (2n + 1)2 âˆ’ 8m2 = 1
2

En general, un nÃºmero poligonal es un tipo de nÃºmero figurado, que cuenta la cantidad de
objetos en un arreglo en forma de cuadrado, triÃ¡ngulo, etc. La figura (1.8) muestra algunos de
estos arreglos,
2

3

4
7
5
3

1

3

2

9

6

6

10

2

8

4
5
1

1

1

3

6

10
6

3

13

8
3

1

1

4

1

5

9

9

1

12

2
2

15

5
8
4

2

7
9

5
3
5

1

5

4
8
5

8

3
1

1

6

1

2

4

4
4

14

9

13

6
7

6

12
10

5

2

13

3
7

15

18

4
3
2
1

6
17

2
1

5
3

12
4
6

10

13 17
20 29
19 25
31
15
27 33
23
34
22
26 32
14
30
5
18 24
7
21 28
12 16
8

15

8
1

16
14

18

14

7 12 16 23
14 19 25
11
22 27
1
8
18
28
2
10
21 26
4
13 17 24
6 9 15 20

9
1

20

5

11

11

10

12

3

7
2

22
16

7

10

21

8
2

1

19
17

12

5

15
13

3

2

3

11
9

6
1

6

4

11
7

1

3

11

4
4

2

16
14

7

11
10
9

10

FUNDAMENTOS

3

5

5

8

3
1

1

6

1

4

4
4

6

9

13

6
7

5
7

12

16

2
1

3

5

18

17

8
1

4
3
2
1

15

13
9

1

15

7 12 16 23
14 19 25
11
22 27
1
8
18
28
2
10
21 26
4
13 17 24
6 9 15 20
5

3

11

11

3

2

14

7
2

2

12
10

4
6

10

14

13 17
20 29
19 25
31
15
27 33
23
34
22
26 32
14
30
5
18 24
7
21 28
12 16
6

8

11
10
9

Figura 1.8. NÃºmeros poligonales

NÃºmeros tetraÃ©dricos. Denotados como Tn , son los anÃ¡logos de los triangulares en 3D. Estos
nÃºmeros son la cantidad de puntos en una pirÃ¡mide tetraÃ©dica, como se observa en la figura
(1.9),

Figura 1.9. T1 = 1, T2 = 4, T3 = 10, ...

Como la nâˆ’Ã©sima capa es un arreglo triangular de tn puntos, entonces
Tn = t1 + t2 + ... + tn
La â€œprueba geomÃ©tricaâ€ es un poco mÃ¡s complicada. Se requiere usar cubos, en vez de puntos,
de tal manera que varias copias encajen perfectamente para formar un cuboide. Por ejemplo,
consideremos T3 = 10, en la figura (1.10) se puede observar la nueva configuraciÃ³n de T3 usando cubos. Las dos copias de T3 ajustan bien, pero no constituyen un cuboide.

Figura 1.10. Encajar dos copias de T3 = 10

Para lograr un cuboide necesitamos seis copias de T3 , como se ve en la en la figura (1.11)

Figura 1.11. Encajando seis copias de T3 = 10

EJERCICIOS

11

Entonces, con seis copias de T3 obtenemos un cuboide de orden 3 Ã— (3 + 1) Ã— (3 + 2), por tanto
T3 = 3(3 + 1)(3 + 2)/6. Generalizando, si sumamos seis copias de Tn , obtenemos es un cuboide
de orden n Ã— (n + 1) Ã— (n + 2), es decir,
Tn =

n(n + 1)(n + 2)
6

NÃºmeros piramidales Pn de base cuadrada. Estos nÃºmeros corresponden a la cantidad de
objetos en una pirÃ¡mide de base cuadrada y altura n. En la figura (1.12) se muestra una configuraciÃ³n para P4 = 30.

+

+

+

=

Figura 1.12. P4 = 30

La kâˆ’Ã©sima capa en la pirÃ¡mide es un cuadrado con sk = k2 objetos, entonces
Pn = 12 + 22 + ... + n2
Para obtener una fÃ³rmula para Pn , usamos la relaciÃ³n entre nÃºmeros cuadrados y nÃºmeros
triangulares, esto nos lleva a una expresiÃ³n en tÃ©rminos de Tn .

Pn

=
=

n

n

k =1
n

k =1
n

âˆ‘ k 2 = âˆ‘ ( t k + t k âˆ’1 )

âˆ‘ tk

k =1

=

+

âˆ‘ tkâˆ’1 = Tn + Tnâˆ’1

k =1

n(n + 1)(2n + 1)
.
6

EJERCICIOS
1.1 Verifique, usando el principio del buen orden, que el conjunto S = {2x + 3y : x, y âˆˆ Z}
tiene un elemento positivo mÃ­nimo y calcular este elemento.
1.2 Use un el Ã¡rea de un rectÃ¡ngulo n Ã— (n + 1) para modlar la suma 1 + 2 + 3 + ... + n =
n ( n + 1)
2
1.3

Sea S = {1, 2, 3, ..., 1000000} . Â¿CuÃ¡ntos nÃºmeros hay en S que son divisbles por 1021 ?.

12

FUNDAMENTOS

1.4 Use el principio de InclusiÃ³n-ExclusiÃ³n para establecer una fÃ³rmula, usando la funciÃ³n
parte entera, que cuente todos los nÃºmeros positivos menores que x que no son divibles por 3
ni por 5 . Luego use la fÃ³rmula para verificar que en el primer millÃ³n de naturales, hay 533333
nÃºmeros que no son divibles por 3 ni por 5 . (Sugerencia: Contamos los nÃºmeros positivos
divisibles Ãºnicamente por 3 y los divisibles Ãºnicamente por 5 y luego los excluimos. Usamos
el principio de InclusiÃ³n-ExclusiÃ³n para contar porque tenemos que excluir los que simÃºltaneamente son divisibles por 3 y 5. )
1.5

Probar, usando el principio de inducciÃ³n, las fÃ³rmulas para sn , tn , y Tn

1.6

Muestre que 8tn + 1 = s2n+1

1.7 Probar, usando inducciÃ³n, que si a y n son enteros positivos, existe otro entero positivo m
tal que am > n
1.8

Use inducciÃ³n para probar que 1 + 23 + 33 + ... + n3 = n2 (n + 1)2 /4

1.9

Probar la fÃ³rmula para la suma de los primeros n tÃ©rminos en una progresiÃ³n aritmÃ©tica,
a + ( a + d) + ( a + 2d) + ... + [ a + (n âˆ’ l )d] = na +

1.10

Probar que si x 6= 1 es un nÃºmero real fijo, entonces
1 + x + x2 + x3 + Â· Â· Â· + x k =

1.11
1.12

n ( n âˆ’ 1)
d
2

1 âˆ’ x k +1
, kâˆˆ N
1âˆ’x

Mostrar que si x âˆˆ
/ Z, entonces VxW = TxU + 1.

[Truncamiento y redondeo.] Sea x âˆˆ R. La expansiÃ³n decimal de x es,

x = a.a1 a2 a3 .... = a + a1 Â· 10âˆ’1 + a2 Â· 10âˆ’2 + a3 Â· 10âˆ’3 + ..., con a âˆˆ Z y ai âˆˆ {0, 1, 2, ..., 9}.
Por ejemplo, 3.1415926535... = 3 + 1 Â· 10âˆ’1 + 4 Â· 10âˆ’2 + 1 Â· 10âˆ’3 + 5 Â· 10âˆ’4 + Â· Â· Â· .
Probar que si n âˆˆ N+ ,
a) T10n xU/10n es un truncamiento de x a n cifras decimales.
Por ejemplo, T1000 Â· 3.1415926535...U/1000 = 3.141.
b) T10n x + 0.5U/10n es un redondeo de x a n cifras decimales.
Por ejemplo, T1000 Â· 3.1415926535... + 0.5U/1000 = 3.142.

EJERCICIOS

13

VersiÃ³n actualizada de este libro: https://tecdigital.tec.ac.cr/revistamatematica/Libros/

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

235711
131719
232931
235711

2

DIVISIBILIDAD

DefiniciÃ³n 2.1
Sean a, b enteros con b 6= 0. Decimos que b divide a a si existe un entero c tal que a = bc. Si b
divide a a escribimos b| a

Teorema 2.1
Sean a, b, d, p, q âˆˆ Z.
a.) Si d| a y d|b entonces d|( ax + by) para cualquier x, y âˆˆ Z
b.) Si d|( p + q) y d| p =â‡’ d|q.
c.) Si a, b âˆˆ Z+ y b| a =â‡’ a â‰¥ b
d.) Si a|b, entonces a|mb, con m âˆˆ Z.
e.) Si a, b âˆˆ Z, a|b y b| a =â‡’ | a| = |b|

Prueba:
a.) Sea a = nd y b = md, entonces ax + by = (nx + my)d =â‡’ d|( ax + by)
b.) Sea p = kd y p + q = k0 d, entonces q = d(k0 âˆ’ k ) =â‡’ d|q
c.) Como a, b âˆˆ Z+ , si a = kb entonces k â‰¥ 1 y por tanto a = bk â‰¥ b.
d.) Sea b = ka =â‡’ mb = mka = (mk ) a =â‡’ a|mb
e.) El item c.) solo aplica si a y b son positivos. Si a|b y b| a entonces, | a|||b| y |b||| a|, por el
item c.), | a| â‰¤ |b| y |b| â‰¤ | a|. âˆ´ | a| = |b|

Ejemplo 2.1
5| âˆ’ 5

y

âˆ’5|5.

âˆ´ |5| = | âˆ’ 5|

Ejemplo 2.2
Sean a, b, d âˆˆ Z. Muestre que si a|d y d|b entonces a|b
SoluciÃ³n: Si a|d âˆ§ d|b =â‡’ d = k1 a âˆ§ b = k2 d,
k2 (k1 a) =â‡’ a|b

2.1

con k1 , k2 âˆˆ Z. Luego b = k2 d =

â€œAlgoritmo de la divisiÃ³nâ€

Si la divisiÃ³n no es exacta, no todo estÃ¡ perdido: Como hacÃ­amos en la escuela, la divisiÃ³n de a
por b la podemos expresar como un cociente y un resto. Por ejemplo, la divisiÃ³n de 23 por 3 es
7 y queda un resto r = 2. Es decir, 23 = 7 Â· 3 + 2. GrÃ¡ficamente,
r=2
7Â·3

23

(7 + 1) Â· 3

Teorema 2.2 (Teorema de la divisiÃ³n).
Sean a, b âˆˆ Z con b 6= 0. Existen q, r âˆˆ Z Ãºnicos tales que
a = bq + r con 0 â‰¤ r < |b|.
Prueba: Primero vamos a demostrar el teorema para a, b âˆˆ Z con b > 0. Consideremos la progresiÃ³n aritmÃ©tica
. . . , âˆ’3b, âˆ’2b, âˆ’b, 0, b, 2b, 3b, . . .
Por el principio del buen orden (ver el ejemplo 1.1) existe q âˆˆ Z tal que
qb â‰¤ a < (q + 1)b

Sea r = a âˆ’ qb, entonces a = bq + r. De qb â‰¤ a obtenemos 0 â‰¤ r y de a < (q + 1)b =â‡’ a âˆ’ qb < b.
âˆ´ a = bq + r con 0 â‰¤ r < b
Unicidad: La prueba es por contradicciÃ³n. Supongamos que existe q1 , r1 âˆˆ Z tal que
a = bq1 + r1 con 0 â‰¤ r1 < b y a = bq + r con 0 â‰¤ r < b
15

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

16

DIVISIBILIDAD

Ahora supongamos que r 6= r1 y que r > r1 .

ï£±
ï£² a

= bq1 + r1

ï£³

= bq + r

a

=â‡’ bq1 + r1 âˆ’ (bq + r ) = 0 =â‡’ b(q1 âˆ’ q) = r âˆ’ r1 =â‡’ b|(r âˆ’ r1 ).

Como b|(r âˆ’ r1 ), se tiene que r âˆ’ r1 â‰¥ b; pero 0 < r âˆ’ r1 < r < b; contradicciÃ³n!.
Por lo tanto, r = r1 . De aquÃ­: b(q1 âˆ’ q) = r âˆ’ r1 = 0 =â‡’ q1 = q
Caso b < 0. Existen q, r âˆˆ Z Ãºnicos tales que a = |b|q + r con 0 â‰¤ r < |b| con lo que
a = b Â· (âˆ’q) + r con 0 â‰¤ r < |b|.

Nota 1: Si a, b âˆˆ Z+ , el â€˜algoritmo de la divisiÃ³nâ€™ corresponde a la divisiÃ³n usual. Si a o b es
negativo, la divisiÃ³n usual difiere del teorema de la divisiÃ³n.
El enunciado del teorema de la divisiÃ³n es adecuado para fines teÃ³ricos. Para efectos de cÃ¡lculo
es mejor enunciar el teorema de la divisiÃ³n asÃ­:

Teorema 2.3
Sean a, b âˆˆ Z con b 6= 0. Existe un Ãºnico r âˆˆ Z tal que
Si b > 0, a = b Ta/bU + r con 0 â‰¤ r < b.
Si b < 0, a = b Va/bW + r con 0 â‰¤ r < |b|.
En este contexto, a/b denota la divisiÃ³n usual en R.

Prueba: Si b > 0 entonces, por el teorema de la divisÃ³n, existe q âˆˆ Z tal que qb â‰¤ a < (q + 1)b,
es decir q = Ta/bU y, por supuesto r = a âˆ’ b Ta/bU.
Si b < 0 entonces a = b Â· (âˆ’q) + r con 0 â‰¤ r < |b|. AsÃ­, âˆ’q = âˆ’Ta/bU = Va/bW, por tanto
âˆ’q = Va/bW y, por supuesto r = a âˆ’ b Va/bW.
NotaciÃ³n para restos. El resto de la divisiÃ³n de a por b se denota â€œ rem ( a, b)â€ o tambiÃ©n
â€œ rem( a, b)â€. Por supuesto, a|b si rem ( a, b) = 0. Para efectos teÃ³ricos puede ser conveniente
que r > 0 pero en cÃ¡lculos computacionales se puede permitir que r sea negativo. Esto es algo
que vamos a retomar mÃ¡s adelante.

EJERCICIOS

Ejemplo 2.3
Dividir âˆ’12 por âˆ’5 :
âˆ’12
10

âˆ’5,
2

âˆ’2

En la divisiÃ³n ordinaria âˆ’12 = 2 Â· âˆ’5 âˆ’ 2.
Desde el punto de vista del teorema de la divisiÃ³n,
como âˆ’3 Â· 5 â‰¤ âˆ’12 < âˆ’2 Â· 5, se tiene
âˆ’12 = âˆ’3 Â· 5 + 3

Ejemplo 2.4
Si a = 2q + r con 0 â‰¤ r < 2. Si r = 0 a se dice par y si r = 1, a se dice impar.

Ejemplo 2.5
Sean n, p âˆˆ N con n â‰¥ p > 0. Mostrar que hay Tn/pU nÃºmeros divisibles por p en el
conjunto A = {1, 2, ..., n}.
SoluciÃ³n: Si p < n entonces p divide a los nÃºmeros { p, 2p, ..., qp} âŠ† A donde qp â‰¤ n <
(q + 1) p, es decir p divide a Tn/pU nÃºmeros en este conjunto.
Ejemplo 2.6
Â¿CuÃ¡ntos enteros positivos â‰¤ 1000 000 no son divisibles por 3 ni por 5?
SoluciÃ³n: Contamos los nÃºmerospositivos divisibles Ãºnicamente por 3 y los divisibles
Ãºnicamente por 5 y luego los excluimos. Podemos usar el principio de InclusiÃ³nExclusiÃ³n para contar porque tenemos que excluir los que simÃºltaneamente son
divisibles por 3 y 5.
Sea A = { x âˆˆ Z+ : x â‰¤ 1000 000 y 3| x } y B = { x âˆˆ Z+ : x â‰¤ 1000 000 y 5| x }. Los
nÃºmeros divisibles por 3 y por 5 son divisibles por 15. Entonces,

| A âˆª B| = | A| + | B| âˆ’ | A âˆ© B|
= T1000 000/3U + T1000 000/5U âˆ’ T1000 000/15U
= 333333 + 200000 âˆ’ 66666 = 466667

Por tanto, en el primer millÃ³n de enteros positivos, hay 1000 000 âˆ’ 466667 = 533333 enteros no divisibles por 3 ni por 5.

EJERCICIOS
2.1

DÃ© un contraejemplo de la afirmaciÃ³n: a|bc y a - c entonces a|b

17

18

DIVISIBILIDAD

2.2

Mostrar que si d| a âˆ§ d|( a + 1) entonces |d| = 1

2.3

Sean d, n âˆˆ Z. Si d no divide a n entonces ningÃºn mÃºltiplo de d divide a n.

2.4

Si d| a y d|b y si a = bq + r entonces d|r.

2.5 Sea b 6= 0 y a = qb + r con 0 â‰¤ r < |b|. Muestre que en el conjunto { a, a âˆ’ 1, ..., a âˆ’ |b| + 1}
hay un Ãºnico mÃºltiplo de b.
2.6

Muestre que si a, b, d âˆˆ Z, a impar y si d| a y d|( ab + 2), entonces d = 1

2.7 Â¿CuÃ¡ntos enteros positivos â‰¤ 3000 son divisibles por 3, 5 o 7? Ayuda: | A âˆª B âˆª C | =
| A| + | B| + |C | âˆ’ | A âˆ© B| âˆ’ | B âˆ© C | âˆ’ |C âˆ© A| + | A âˆ© B âˆ© C |

2.2

NÃºmeros Primos.

DefiniciÃ³n 2.2 (Primos y compuestos).
Un entero p > 1 se dice primo si sus Ãºnicos divisores son 1 y p. Si p no es primo, se dice
compuesto.

El nÃºmero 1 no se toma como primo solo por conveniencia. No perjudica en nada y obtenemos
cierta economÃ­a en la formulaciÃ³n de teoremas.
Ejemplo 2.7
Los primeros primos son {2, 3, 5, 7, 11, 13, 17, ...}

Ejemplo 2.8
Sea pi el i âˆ’Ã©simo primo. El nÃºmero N = p1 Â· p2 Â· spn + 1 puede ser o no ser primo. Por
ejemplo,
N = 2 Â· 3 Â· 5 Â· 7 Â· 11 + 1 = 2311 es primo (ver ejemlo 2.9),
N = 2 Â· 3 Â· 5 Â· 7 Â· 11 Â· 13 + 1 = 30031 = 59 Â· 509 no es primo.

Teorema 2.4
Todo entero positivo n > 1 tiene un divisor primo

EJERCICIOS

19

Prueba: Si n es primo, tiene un divisor primo (Ã©l mismo). Supongamos que n es compuesto.
Por el principio del buen orden podemos suponer que existe un d > 1 que es el mÃ¡s pequeÃ±o
divisor positivo de n. Entonces d es primo. En efecto, si d fuera compuesto, d tendrÃ­a un divisor
1 < d1 < d. Pero si d1 |d y d|n entonces d1 |n, en contradicciÃ³n con la suposiciÃ³n de que d era el
mÃ¡s pequeÃ±o divisor > 1, de n.

Corolario 2.1 Sea n âˆˆ Z, n > 1. El mÃ¡s pequeÃ±o divisor positivo d > 1 de n es primo.

Â¿CÃ³mo decidir si n es primo? El problema de decidir si es un nÃºmero es primo no es en
general fÃ¡cil. Si n es un nÃºmero muy grande, probar que n no es divisible por ningÃºn nÃºmero
excepto 1 y n, nos llevarÃ­a a hacer un nÃºmero nada razonable de cÃ¡lculos. El siguiente teorema
nos dice que para determinar si un nÃºmero n es primo o no, basta con probar con los divisores
âˆš
âˆš
primos inferiores a n. Aunque n es en general pequeÃ±o respecto a n, este mÃ©todo tiene un
alcance muy limitado.

Teorema 2.5
Sean a, b, n âˆˆ N, a > 1, b > 1 y n > 1.
âˆš
âˆš
a.) Si n = ab, entonces a â‰¤ n âˆ¨ b â‰¤ n.
âˆš
b.) Si n no tiene divisores primos â‰¤ n, entonces n es primo.

Prueba: Probamos a.) por contradicciÃ³n: Si a >

âˆš

n âˆ§ b>

âˆš

n =â‡’ ab > n. (â‡’â‡).

Probamos b.): Si n fuera compuesto, n = ab con a > 1, b > 1. Entonces como los divisores primos de a y b son divisores de n, tendrÃ­amos que al menos uno de eso divisores es menor que
âˆš
n en contradicciÃ³n con la hipÃ³tesis.

Corolario 2.2 Si n es compuesto, n tiene un divisor primo p â‰¤

âˆš

n.

Ejemplo 2.9
Â¿ n = 103 es compuesto?

âˆš
SoluciÃ³n: 103 es primo pues no es divisible por ningÃºn primo inferior a 103 â‰ˆ 10.1
En efecto, los primos inferiores a 10 son 2, 3, 5 y 7. Para probar que n no es divisible
por alguno de estos nÃºmeros calculamos los residuos: rem (103, 2) = 1, rem (103, 3) = 1,
rem (103, 5) = 3 y rem (103, 7) = 5.
Â¿ n = 2311 es primo?
SoluciÃ³n: Siâˆšes primo. En efecto, si no fuera primo, n = 2311 tendrÃ­a un divisor primo
p con p â‰¤ 2311 = 48.07... . Los primos inferiores a 48 son {2, 3, 5, 7, 11, 13, 17, 19, 23, 29,

20

DIVISIBILIDAD

31, 37, 41, 43, 47} pero ninguno de ellos divide a 2311.
Â¿Puede un nÃºmero n compuesto tener factores primos mÃ¡s grandes que

âˆš

n?

âˆš
SoluciÃ³n: Si n = p1 p2 con p1 âˆš
y p2 primos distintos, no podrÃ­an ser ambos < n!.âˆšPor
ejemplo 206 = 2 Â· 103 y 103 > 206 â‰ˆ 14.35. Hay casos como 16 = 2 Â· 2 Â· 2 Â· 2 y 2 < 16.

Â¿CuÃ¡ntos primos hay?. Los primos son infinitos. Es algo que se conoce desde la Ã©poca de
Euclides.

Teorema 2.6 (Euclides).
Hay un nÃºmero infinito de primos

Prueba: La demostraciÃ³n es por contradicciÃ³n: Si p1 , . . . , pn fueran todos los primos, el nÃºmero
N = p1 p2 Â· spn + 1 es un nuevo primo o tiene un divisor primo diferente de cada pi , i = 1, 2, ..., n.
Si N es primo, N > pi , i = 1, 2, ..., n y entonces serÃ­a un nuevo primo, contradicciÃ³n.. Si N
no es un nuevo primo, tiene un divisor primo p j , pero entonces como p j |( p1 p2 Â· spn + 1) y
p j |( p1 p2 Â· spn ) =â‡’ p j |1 lo cual es imposible pues p j > 1.
Â¿CuÃ¡ntos primos hay â‰¤ x ?. Ahora esta es la pregunta correcta. Ï€ ( x ) denota la cantidad de
primos inferiores o iguales x. Por ejemplo, Ï€ (5) = Ï€ (6) = 3. Hasta el 2008, se conocen todos los
primos inferiores a x = 100 000 000 000 000 000 000 000 = 1023 . Se tiene
Ï€ (1023 ) = 1 925 320 391 606 803 968 923.
TambiÃ©n se conocen algunos primos fuera de Ã©stos, por ejemplo 19249 Â· 213018586 + 1 es un primo
con 3918990 dÃ­gitos; fue encontrado en el 2007 por Samuel Yates.
Una fÃ³rmula (no muy eficiente) para Ï€ (n) es la fÃ³rmula de Legendre (ver la secciÃ³n 7.4.1),

Teorema 2.7 (Legendre).
Sean p1 , p2 , ..., ps los primos â‰¤

âˆš
Ï€ (n) = n âˆ’ 1 + Ï€ ( n) âˆ’

âˆš

n, entonces

âˆ‘

1â‰¤ i â‰¤ s

Tn/pi U +

âˆ’

âˆ‘Tn/( pi p j )U

i< j

âˆ‘

i < j<k

Tn/( pi p j pk )U + Â· Â· Â· + (âˆ’1)s Tn/( p1 p2 Â· sps )U.

EJERCICIOS

21

Ejemplo 2.10
Calcular Ï€ (100) con la fÃ³rmula de Legendre.
SoluciÃ³n:
Los ingredientes son: n = 100,
âˆš
Ï€ ( 100) = 4. Por tanto,
Ï€ (100)

2.3

âˆš

100 = 10, los primos â‰¤ 10 son {2, 3, 5, 7} y

=

100 âˆ’ 1 + 4 âˆ’ (T100/2U + T100/3U + T100/5U + T100/7U)

+

(T100/(2 Â· 3)U + T100/(2 Â· 5)U + T100/(2 Â· 7)U + T100/(3 Â· 5)U + T100/(3 Â· 7)U

+

T100/(5 Â· 7)U)

âˆ’

(T100/(2 Â· 3 Â· 5)U + T100/(2 Â· 3 Â· 7)U + T100/(2 Â· 5 Â· 7)U + T100/(3 Â· 5 Â· 7)U)

+

T100/(2 Â· 3 Â· 5 Â· 7)U = 25.

Criba de EratÃ³stenes: CÃ³mo colar nÃºmeros primos.

Como vimos en el ejemplo 2.9, se requiere conocer una lista de primos para decidir si un nÃºmero
es primo o no. Este mÃ©todo para determinar la primalidad de un nÃºmero es conocido como
â€˜ensayo y errorâ€™ (â€˜trial divisionâ€™). Es efectivo para nÃºmeros pequeÃ±os pero no para nÃºmeros
âˆš
muy grandes. El problema es que la cantidad de nÃºmeros primos inferiores a n es aproxiâˆš
âˆš
un
madamente n/ ln( n) (Teorema de los NÃºmeros Primos), asÃ­ por ejemplo
âˆš si tenemos
âˆš
nÃºmero a â‰ˆ 1020 , para establecer si es primo o no, habrÃ­a que probar con 1020 / ln( 1020 ) â‰ˆ
4.34294 Ã— 108 nÃºmeros primos..., es decir unos 434 millones de nÃºmeros. Aunque tuvieramos los
nÃºmeros primos y un computador muy veloz, al sumar los tiempos que requiere cada divisiÃ³n
obtendrÃ­amos meses o aÃ±os de cÃ¡lculo. MÃ¡s adelante veremos otras pruebas de primalidad.
Actualmente, la manera mÃ¡s eficiente de colar â€œprimos pequeÃ±osâ€, es usar la criba1 de EratÃ³stenes.
Este es un algoritmo que permite â€œcolarâ€ todos los nÃºmeros primos menores que un nÃºmero
natural dado n, eliminando los nÃºmeros compuestos de la lista {2, ..., n}. Es simple y razonablemente eficiente mientras no haya problemas de almacenamiento (este es su punto dÃ©bil).
Primero tomamos una lista de nÃºmeros {2, 3, ..., n} y eliminamos de la lista los mÃºltiplos de 2.
Luego tomamos el primer entero despuÃ©s de 2 que no fue borrado (el 3 ) y eliminamos de la
lista sus mÃºltiplos, y asÃ­ sucesivamente. Los nÃºmeros que permanecen en la lista son los primos
{2, 3, 5, 7, ...}.

1 Criba,

tamiz y zaranda son sinÃ³nimos. Una criba es un herramienta que consiste de un cedazo usada para limpiar el
trigo u otras semillas, de impurezas. Esta acciÃ³n de limpiar se le dice cribar o tamizar.

22

DIVISIBILIDAD

Ejemplo 2.11
Primos menores que n = 10
Lista inicial
Eliminar mÃºltiplos de 2
Resultado
Eliminar mÃºltiplos de 3
Resultado

2
2
2
2
2

3
3
3
3
3

4
4

5
5
5

5
5
7
7
7

6 7 8 9 10
6
10
 7 8 9 
9
9

Primer refinamiento: Tachar solo los impares. Excepto el 2, los pares no son primos, asÃ­ que
podrÃ­amos â€œtacharâ€ solo sobre la lista de impares â‰¤ n :

s
{
nâˆ’3
{3, 5, 9, ..., } = 2i + 3 : i = 0, 1, ...
2
Para probar que esta lista efectivamente corresponde a los impares â‰¤ n, observemos que el Ãºlq 3y
timo impar es n o n âˆ’ 1. En cualquier caso, el Ãºltimo impar es 2 Â· nâˆ’
+ 3 pues:
2
q 3y
Si n es impar, n = 2k + 1 y nâˆ’
= k âˆ’ 1 =â‡’ 2(k âˆ’ 1) + 3 = n.
2
q n âˆ’3 y
= k âˆ’ 2 =â‡’ 2(k âˆ’ 2) + 3 = 2k âˆ’ 1 = n âˆ’ 1.
Si n es par, n = 2k y
2
Segundo refinamiento: Tachar de p2k en adelante. En el paso kâˆ’ Ã©simo hay que tachar los
mÃºltiplos del primo pk desde p2k en adelante. Esto es asÃ­ pues en los pasos anteriores se ya se
tacharon 3 Â· pk , 5 Â· pk , ..., pkâˆ’1 Â· pk . Por ejemplo, cuando nos toca tachar los mÃºltiplos del primo 7,
ya se han eliminado los mÃºltiplos de 2, 3 y 5, es decir, ya se han eliminado 2 Â· 7, 3 Â· 7, 4 Â· 7, 5 Â· 7
y 6 Â· 7. Por eso iniciamos en 72 .

Tercer refinamiento: Tachar mientras p2k â‰¤ n . En el paso kâˆ’ Ã©simo hay que tachar los mÃºltiplos
del primo pk solo si p2k â‰¤ n. En otro caso, nos detenemos ahÃ­. Â¿Porque?. En el paso kâˆ’ Ã©simo
tachamos los mÃºltiplos del primo pk desde p2k en adelante, asÃ­ que si p2k > n ya no hay nada
que tachar.
Ejemplo 2.12
Encontrar los primos menores que 20. El proceso termina cuando el cuadrado del mayor
nÃºmero confirmado como primo es < 20.
a.) La lista inicial es {2, 3, 5, 7, 9, 11, 13, 15, 17, 19}
b.) Como 32 â‰¤ 20, tachamos los mÃºltiplos de 3 desde 32 = 9 en adelante:
 17, 19}
{2, 3, 5, 7, 9, 11, 13,
15,
c.) Como 52 > 20 el proceso termina aquÃ­: Primos < 20 : {2, 3, 5, 7, 11, 13, 17, 19}

2.3.1

Algoritmo e implementaciÃ³n.

En este contexto, a/b denota divisiÃ³n entera, es decir, a/b es el cociente de dividir a y b.
IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

EJERCICIOS

23

a.) Como ya vimos, para colar los primos en el conjunto {2, 3, ..., n} solo consideramos los
impares:

{2i + 3 : i = 0, 1, ... J(n âˆ’ 3)/2K} = {3, 5, 7, 9, ...}
b.) Por cada primo p = 2i + 3 (tal que p2 < n ), debemos eliminar los mÃºltiplos impares de p
menores que n, a saber

(2k + 1) p = (2k + 1)(2i + 3), k = i + 1, i + 2, ...

Si k = i + 1 entonces el primer mÃºltiplo en ser eliminado es p2 = (2i + 3)(2i + 3), como
debe ser.
Esto nos dice que para implementar el algoritmo solo necesitamos un arreglo (booleano) de
tamaÃ±o T(n âˆ’ 3)/2U. En Java se pone â€œ(n-3)/2â€ y en VBA se pone â€œ(n-3)\2â€.
El arreglo lo llamamos EsPrimo[i], i=0,1,...,(n-3)/2.Cada entrada del arreglo â€œEsPrimo[i]â€
indica si el nÃºmero 2i + 3 es primo o no.
Por ejemplo

EsPrimo[0] = true

pues n = 2 Â· 0 + 3 = 3 es primo,

EsPrimo[1] = true

pues n = 2 Â· 1 + 3 = 5 es primo,

EsPrimo[2] = true

pues n = 2 Â· 2 + 3 = 7 es primo,

EsPrimo[3] = false

pues n = 2 Â· 3 + 3 = 9 no es primo.

Si el nÃºmero p = 2i + 3 es primo entonces i = ( p âˆ’ 3)/2 y
EsPrimo[(p-3)/2] = true.

Si sabemos que p = 2i + 3 es primo, debemos poner
EsPrimo[((2k+1)(2i+3) - 3)/2] = false

pues estas entradas representan a los mÃºltiplos (2k + 1)(2i + 3) de p. Observe que cuando
i = 0, 1, 2 tachamos los mÃºltiplos de 3, 5 y 7; cuando i = 3 entonces 2i + 3 = 9 pero en este
momento esPrimo[3]=false asÃ­ que proseguimos con i = 4, es decir, proseguimos tachando los
mÃºltiplos de 11.

24

DIVISIBILIDAD

En resumen: Antes de empezar a tachar los mÃºltiplos de p = 2i + 3 debemos preguntar si
esPrimo[i]=true.

Algoritmo 2.1: Criba de EratÃ³stenes
Datos: n âˆˆ N, n > 3
Salida: Primos entre 2 y n
1 mÃ¡x = ( n âˆ’ 3) /2 ;
2 boolean esPrimo[i ], i = 1, 2, ...,mÃ¡x;
3 for i = 1, 2, ..., mÃ¡x do
4
esPrimo[i ] =True;
5
6
7
8
9
10
11

i = 0;
while (2i + 3)(2i + 3) â‰¤ n do
k = i + 1;
if esPrimo(i) then
while (2k + 1)(2i + 3) â‰¤ n do
esPrimo[((2k + 1)(2i + 3) âˆ’ 3)/2] =False;
k = k + 1;
i = i + 1;

12
13
14
15
16
17

Imprimir;
Imprima 2, 3;
for j = 1, 2, ..., mÃ¡x do
if esPrimo[ j] =True then
Imprima 2j + 3

Nota: Es conveniente poner (2i + 3) â‰¤ n/(2i + 3) en vez de (2i + 3)(2i + 3) â‰¤ n, para no operar
con nÃºmeros innecesariamente grandes.

Hay variaciones de la criba de EratÃ³stenes muy eficientes ([15], [14],[20]). En la mayorÃ­a de las
referencias elementales sobre esta criba no se eliminan los pares posiblemente por mantener la
simplicidad y porque para estudios asintÃ³ticos no hay necesidad. La tabla que sigue muestra la
diferencia en tiempos de ejecuciÃ³n (en segundos) en una implementaciÃ³n en Mathematica2

Tiempo en segundos (en Mathematica.).
n
Criba sin pares Criba con pares
80000
1.10807
4.30427
90000
1.40809
5.49234
100000
1.67611
6.64842

ImplementaciÃ³n en VBA Excel. El cÃ³digo que sigue hace la lectura de datos en un cuaderno
como el que sigue. n se lee en la celda B7 y el nÃºmero de columnas, para imprimir en formato
de tabla, se lee en la columna C7. Se imprime desde la celda B9. La macro Eratostenes(n, 9,
2 Esta

implementaciÃ³n en Mathematica se espera que sea lenta porque es un lenguaje interpretado.

EJERCICIOS

25

criba los primos e imprime. En este cuaderno la macro se ejecuta desde
un botÃ³n (el cual se agrega desde la â€˜ficha del programadorâ€™).
2, CantidadColumnas)

[Descargar]

Option Explicit
Public CantidadColumnasAnt As Integer
â€™Principal: Lectura de datos y llamada a la macro
Private Sub CommandButton1_Click()
Dim n, CantidadColumnas
n = Cells(7, 2)

â€™Lee n en celda B7

CantidadColumnas = Cells(7, 3) â€™Lee la cantidad de columnas en C7
If n < 2 Then
MsgBox ("El n\â€™umero digitado debe ser un n\â€™umero natural mayor que 3")
Call LimpiaCeldas(9, 2, CantidadColumnas)
ElseIf CantidadColumnas < 0 Or CantidadColumnas > 60000 Then
MsgBox ("El n\â€™umero de columnas debe ser mayor a 0 y menor a 60 000")
Call LimpiaCeldas(9, 2, CantidadColumnasAnt)
Else
Call Eratostenes(n, 9, 2, CantidadColumnas)
End If
End Sub
Sub Eratostenes(n, fil, col, Optional CantidadColumnas As Variant)
Dim i, j, k, pos, l
Dim max As Integer
Dim esPrimo() As Boolean
If CantidadColumnas = "" Or CantidadColumnas = 0 Then
CantidadColumnas = 10
End If

Call LimpiaCeldas(fil, col, CantidadColumnasAnt) â€™Limpia celdas
CantidadColumnasAnt = CantidadColumnas
â€™**Criba---------------------------------------------------------*

26

DIVISIBILIDAD

max = (n - 3) \ 2 â€™divisi\â€™on entera
ReDim esPrimo(max + 1)

For i = 0 To max
esPrimo(i) = True
Next i
j = 0
While (2 * j + 3) <= n\(2 * j + 3)
k = j + 1
If esPrimo(j) Then
While (2 * k + 1) * (2 * j + 3) <= n
pos = ((2 * k + 1) * (2 * j + 3) - 3) \ 2
esPrimo(pos) = False
k = k + 1
Wend
End If
j = j + 1
Wend
â€™**---------------------------------------------------------------*
â€™**Imprimir en la hoja Excel--------------------------------------*
Cells(fil, col) = 2
â€™Hay dos casos especiales
If CantidadColumnas = 1 Then
Cells(fil + 1, col) = 3 : k=2 : j=0
ElseIf CantidadColumnas = 2 Then
Cells(fil, col + 1) = 3 : k=1 : j=0
Else
Cells(fil, col + 1) = 3 : k=0 : j=2
End If
For i = 1 To max
If esPrimo(i) Then
Cells(fil + k, col + j) = 2 * i + 3
If CantidadColumnas <> 1 Then
k = k + j \ (CantidadColumnas - 1)
j = j + 1
j = j Mod CantidadColumnas
Else
k = k + 1
End If
End If
Next i
End Sub
Private Sub LimpiaCeldas(fil, col, nc)
Dim k, j
k = 0
While LenB(Cells(fil + k, col)) <> 0

EJERCICIOS

27

For j = 0 To nc
Cells(fil + k, col + j) = ""
Next j
k = k + 1
Wend
End Sub

2.4

MÃ¡ximo comÃºn divisor

Si a, b son enteros no ambos nulos, entonces d es un divisor comÃºn de a y b si d| a y d|b.
Denotamos con Da al conjunto de divisores de a y con Db el conjunto de divisores de b. Estos
conjuntos no son vacÃ­os pues al menos 1 âˆˆ Da y 1 âˆˆ Db . El mÃ¡ximo comÃºn divisor comÃºn de a
y b es el mÃ¡s grande entero positivo del conjunto Da âˆ© Db .

Ejemplo 2.13
Como Dâˆ’3 = {âˆ’3, âˆ’1, 1, 3} y D6 = {Â±6, Â±3, Â±2, Â±1}, entonces Da âˆ© Db = {âˆ’3, 3, âˆ’1, 1}.
Por tanto, el mÃ¡ximo comÃºn divisor de 3 y 6 es 3.

Antes de continuar, una pregunta: Â¿porquÃ© a y b no pueden ser ambos nulos?
Una definiciÃ³n mÃ¡s tÃ©cnica y apropiada para el desarrollo teÃ³rica es,

DefiniciÃ³n 2.3 (MÃ¡ximo ComÃºn Divisor).
Sean a, b enteros con al menos uno de los dos diferente de cero. El mÃ¡ximo comÃºn divisor de a
y b, denotado mcd ( a, b), es el entero positivo d que satisface:
a.) d| a y d|b
b.) Si c| a y c|b, entonces c|d
Si mcd( a, b) = 1 se dice que a y b son relativamente primos o simplemente â€œcoprimosâ€.

Ejemplo 2.14
mcd (3, 6) = mcd (âˆ’3, 6) = mcd (3, âˆ’6) = 3.

Ahora establecemos algunas propiedades Ãºtiles. Otras propiedades serÃ¡n enunciadas mÃ¡s adelante, cuando tengamos mÃ¡s herramientas para hacer las pruebas.

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

28

DIVISIBILIDAD

Teorema 2.8
Sean a, b âˆˆ Z, no ambos nulos.
a.) mcd ( a, 0) = | a| si a 6= 0
b.) mcd ( a, b) = mcd (| a|, |b|)
c.) Si d = mcd ( a, b), entonces mcd ( a/d, b/d) = 1
d.) Si d = mcd ( a, b), entonces mcd ( a, b âˆ’ na) = d con n âˆˆ Z

Prueba: : Para probar a.) sea d = mcd ( a, 0). Como | a| | a y | a| |0, entonces | a| |d. Pero d| | a| =â‡’
d â‰¤ | a |. âˆ´ d = | a |.
Para probar b.) sea d = mcd( a, b) y d1 = mcd(| a|, |b|). Como d| a âˆ§ d|b =â‡’ d| | a| âˆ§ d| |b| =â‡’
d|d1 . Ahora como d1 | | a| âˆ§ d1 | |b| =â‡’ d1 | a âˆ§ d1 | b =â‡’ d1 |d. âˆ´ d = d1 por ser ambos positivos.
Para probar c.), sea d0 = mcd ( a/d, b/d), entonces hay enteros k, k0 tales que a/d = kd0 y
b/d = k0 d0 . Por tanto, a = dkd0 y b = dk0 d0 , es decir, dd0 | a âˆ§ dd0 |b =â‡’ dd0 â‰¤ d por definiciÃ³n; entonces d0 es un entero positivo â‰¤ 1, es decir, d0 = 1.
Para probar d.), sea d1 = mcd( a, b âˆ’ na). Como d| a âˆ§ d|b =â‡’ d|(b âˆ’ na) por el teorema 2.1 a.).
Entonces d â‰¤ d1 . Como d1 | a =â‡’ d1 |na. AsÃ­ d1 |na âˆ§ d1 |(b âˆ’ na) =â‡’ d1 |b por el teorema 2.1 b.).
Entonces d1 â‰¤ d. âˆ´ d = d1

Nota. El orden importa. En el ejercicio 2.9 se pide dar un par de ejemplos que muestren que en
general, si d = mcd ( a, b), entonces d 6= mcd ( a, a âˆ’ nb) con n âˆˆ Z
Ejemplo 2.15
Muestre que si p es primo, mcd ( a, p) = p o mcd ( a, p) = 1.
SoluciÃ³n: Si d = mcd ( a, p), en particular d| p, por tanto, como p es primo, d = 1 âˆ¨ d = p.

Ejemplo 2.16
Muestre que si n > 1, p es primo y p|(n2 + 1), entonces mcd ( p, n) = 1.
SoluciÃ³n: mcd ( p, n) = 1 âˆ¨ mcd ( p, n) = p. Si mcd ( p, n) = p entonces p|n =â‡’ p|n2 y
como p|(n2 + 1) entonces p|1; contradicciÃ³n. âˆ´ mcd ( p, n) = 1.

EJERCICIOS

29

Ejemplo 2.17
Sea d = mcd ( a, b). Si a = kd y b = k0 d, entonces mcd (k, k0 ) = 1.
SoluciÃ³n: El teorema 2.8 c.) dice que mcd ( a/d, b/d) = 1, es decir, mcd (k, k0 ) = 1.
En la prÃ¡ctica necesitamos calcular el mÃ¡ximo comÃºn divisor de varios nÃºmeros. Esto no es
problema, el siguiente teorema nos dice que el mÃ¡ximo comÃºn divisor de varios nÃºmeros se
puede calcular de la misma manera en la que sumamos: De dos en dos.

Teorema 2.9
Sean a1 , a2 , .., an âˆˆ Z+ , n â‰¥ 3. Entonces mcd ( a1 , a2 , ..., an ) = mcd ( a1 , mcd ( a2 , ..., an )).
Prueba: Sea d = mcd ( a1 , a2 , ..., an ) y d1 = mcd ( a1 , d2 ) con d2 = mcd ( a2 , ..., an ). Como d| a1 , d| a2 , ..., d| an ,
entonces d|d2 y por tanto d|d1 . Como d1 | a1 y d1 |d2 entonces d1 | a1 , âˆ§ d1 | a2 , ..., d1 | an (por transitividad). Por tanto d1 |d âˆ´ d = d1 .

Corolario 2.3 Sean a1 , ..., an âˆˆ Z no todos nulos, si
ï£¼
= d2 , ï£´
ï£´
= d3 , ï£½
=â‡’ dn = mcd ( a1 , ..., an ).
ï£´
...
ï£´
ï£¾
mcd (dnâˆ’1 , an ) = dn ,
mcd ( a1 , a2 )
mcd (d2 , a3 )

Ejemplo 2.18
mcd (3, 6, 12) = mcd ( mcd (3, 6), 12) = mcd (3, 12) = 3.

2.5

Algoritmo de Euclides I.

El algoritmo de Euclides se basa en la aplicaciÃ³n sucesiva del siguiente lema
Lema 2.1
Sean a, b, q, r âˆˆ Z tales que a = bq + r con b > 0 y 0 â‰¤ r < b. Entonces mcd ( a, b) = mcd (b, r ).
Prueba: SegÃºn el teorema 2.8 d.), mcd (b, a) = mcd (b, a âˆ’ bq) = mcd (b, r )

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

30

DIVISIBILIDAD

Este resultado lo podemos usar para obtener un algoritmo para calcular el mÃ¡ximo comÃºn
divisor de dos nÃºmeros.

Algoritmo de Euclides. Sean a y b nÃºmeros naturales, b 6= 0. Aplicando el teorema de
la divisiÃ³n se obtiene una sucesiÃ³n finita a, r0 = b, r1 , r2 , ..., rn , 0 definida por
a

= r0 q1 + r1 ,

0 â‰¤ r1 < r0

r0

= r1 q2 + r2 ,

0 â‰¤ r2 < r1

r1

= r2 q3 + r3 ,

0 â‰¤ r3 < r2

r n âˆ’2

..
.
=

0 â‰¤ r n < r n âˆ’1

r n âˆ’1

= r n q n +1 + 0

r n âˆ’1 q n + r n ,

rn+1 = 0.

El Ãºltimo tÃ©rmino es rn = mcd ( a, b).

Correctitud del algoritmo. Aplicando el teorema de la divisiÃ³n obtenemos una sucesiÃ³n decreciente de residuos 0 â‰¤ ... < rk < rkâˆ’1 < ... < r1 < r0 = b. La sucesiÃ³n es finita pues entre 0 y r0 6= 0
solo puede haber un nÃºmero finito de enteros. Por tanto algÃºn residuo debe ser cero (sino, se
podrÃ­a aplicar el teorema de la divisiÃ³n indefinidamente y tendrÃ­amos una sucesiÃ³n infinita de
enteros entre 0 y b , lo cual es imposible.) Si b| a, entonces r1 = 0 y r0 serÃ­a el mÃ­nimo residuo
positivo. En general, debe haber un residuo mÃ­nimo rn > 0 y rn+1 = 0
De acuerdo al lema (2.1) tenemos que
mcd ( a, b)

=

mcd ( a âˆ’ r0 q, r0 )

=

mcd (r1 , r0 )

=

mcd (r1 , r0 âˆ’ r1 q2 )

=

mcd (r1 , r2 )

=

mcd (r1 âˆ’ r2 q2 , r2 )

=
..
.

mcd (r3 , r2 )

=

mcd (rnâˆ’1 , rn )

=

mcd (rn , 0) = rn

Ejemplo 2.19
Vamos a aplicar el algoritmo de Euclides para calcular mcd (8, 2) y mcd (78, 32).

EJERCICIOS

a.) mcd (8, 2) = 2. En efecto;
8

=

AsÃ­,

2.5.1

2Â·4+0
r0 = 2 y r1 = 0.

31

b.) mcd (78, 32) = 2. En efecto;
78

=

32 Â· 2 + 14

32

=

14 Â· 2 + 4

14

=

4Â·3+ 2

4

=

2Â·2+0

Algoritmo e implementaciÃ³n.

Recordemos que mod( a, b) denota el resto de la divisiÃ³n de a por b. En este algoritmo, en cada
paso r = mod (rn+1 , rn ) donde rn+1 = c es el dividendo actual y rn = d es el divisor actual.
Luego se actualiza rn+1 = d y d = r. El proceso continÃºa mientras d no se anule.
Algoritmo 2.2: MÃ¡ximo comÃºn divisor
Datos: a, b âˆˆ Z. b 6= 0
Salida: mcd ( a, b)
1 c = | a |, d = | b | ;
2 while d 6 = 0 do
3
r = mod(c, d);
4
c = d;
5
d = r;
6

return mcd ( a, b) = |c|;

ImplementaciÃ³n en VBA Excel.

Function mcd(a, b)
Dim c As Long, d As Long, r As Long â€™max = 2 147 483 647
c = Abs(a)
d = Abs(b)
While d <> 0
r = c Mod d â€™residuo entre (c,d)
c = d
d = r
Wend
mcd = Abs(c)
End Function

Para calcular el mcd de una lista de enteros que estÃ¡n en una columna de una hoja de Excel, se
puede seleccionar la lista con el ratÃ³n y convertir la lista a un vector de enteros. Luego aplicamos
el algoritmo.
Private Sub mcdLista()
Dim n, i

32

DIVISIBILIDAD

Dim Rango As Range
Dim Lista() As Long
â€™Seleccionar rango y convertir a Array
Set Rango = Selection
n = Rango.Rows.Count â€™Solo filas
If n <= 1 Then
MsgBox ("Debe seleccionar 2 o m\â€™as enteros")
Exit Sub
End If
ReDim Lista(n)
For i = 1 To n â€™Arreglos inician en cero, rangos en 1
Lista(i) = Rango(i, 1)
Next i
Cells(7, 6) = mcd_Lista(Lista)
End Sub
â€™Los arreglos se pasan solo por referencia
Function mcd_Lista(ByRef L() As Long) â€™ByRef = por referencia
Dim c As Long
Dim i, n
c = 0
n = UBound(L) â€™tamano del arreglo

For i = 1 To n
If c = 0 Then
c = mcd(c, L(i))
Else
c = Abs(c) * Abs(L(i)) / mcd(c, L(i))
End If
Next i
mcd_Lista = Abs(c)
End Function

2.6

Algoritmo Extendido de Euclides.

El siguiente teorema establece la llamada â€œIdentidad de Etienne Bezoutâ€ aunque el resultado lo
descubriÃ³ primero el francÃ©s Claude Gaspard Bachet de MÃ©ziriac (1581-1638).

Teorema 2.10 (Identidad de BÃ©zout).
Si a, b son dos enteros no ambos cero, existen s, t âˆˆ Z (posiblemente no Ãºnicos) tales que
sa + tb = mcd ( a, b)
Prueba: Sea A el conjunto de combinaciones lineales enteras de a y b, A = {u a + v b : u, v âˆˆ Z}.
Este conjunto tiene nÃºmeros positivos, negativos y el cero. Sea m = a x + b y el mÃ¡s pequeÃ±o
IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

EJERCICIOS

33

entero positivo en A.
Â¿m divide a a y a b?. Mmmmm, supongamos que a = mq + r con 0 â‰¤ r < m. Entonces,
0 â‰¤ r = a âˆ’ mq = a âˆ’ ( a x + b y)q = (1 âˆ’ qx ) a + (âˆ’qy)b
AsÃ­, r es una combinaciÃ³n lineal de a y b, es decir, r âˆˆ A. Pero 0 â‰¤ r < m, asÃ­ que la Ãºnica
posibilidad es que r = 0 por ser m el mÃ­nimo entero positivo en A.
Luego, a = mq y m| a. De manera anÃ¡loga podemos establecer que m|b. Sea d = mcd ( a, b).
Como m es comÃºn divisor de a y b, entonces d â‰¥ m. Pero, como a = k1 d y b = k2 d entonces
m = ax + by = ( xk1 + yk2 )d > 0, por lo tanto m â‰¥ d. AsÃ­ que m = d.

Los siguientes corolarios son sumamente Ãºtiles,
Corolario 2.4 El mcd ( a, b) es el mÃ¡s pequeÃ±o entero positivo de la forma sa + tb; s, t âˆˆ Z. En particular, mcd ( a, b) = 1 si y sÃ³lo si existen x, y âˆˆ Z tal que ax + by = 1
Prueba: Ejercicio.

Corolario 2.5 Si a|bc y mcd ( a, b) = 1 entonces a|c.
Prueba: Como mcd ( a, b) = 1, existen x, y âˆˆ Z tal que xa + by = 1. Multiplicando por c a ambos
lados,
acx + bcy = c
Como a| ac y a|bc entonces a|( acx + bcy).

âˆ´ a|c.

Ejemplo 2.20

Si n es entero positivo, verifique que

n+2
es irreducible.
n+1

SoluciÃ³n: Si n > 0, n + 2 âˆ’ (n + 1) = 1; entonces, segÃºn el corolario (2.4), mcd (n + 2, n +
1) = 1.
Calcular t y s. La ecuaciÃ³n sa + tb = mcd ( a, b) no tiene soluciÃ³n Ãºnica para s, t enteros. Se
puede obtener una soluciÃ³n despejando los residuos, en el algoritmo de Euclides, y haciendo
una sustituciÃ³n hacia atrÃ¡s.
Consideremos la sucesiÃ³n r1 , r2 , ..., rn del algoritmo de Euclides. Todos estos residuos son una
combinaciÃ³n lineal entera de a y b : En efecto, como r1 = a âˆ’ bq0 y b = r1 q1 + r2 entonces r2
es combinaciÃ³n lineal de a y b. Como r1 y r2 son combinaciones lineales de a y b y como
r1 = r2 q2 + r3 entonces r3 es combinaciÃ³n lineal de a y b. Continuando de esta manera, como
riâˆ’1 y riâˆ’2 son combinaciones lineales de a y b y como riâˆ’2 = riâˆ’1 q2 + ri (i = 2, ..., n), entonces
rn es combinaciÃ³n lineal (mÃ­nima) de a y b.

34

DIVISIBILIDAD

Ejemplo 2.21
mcd (78, 32) = 2. De acuerdo a la identidad d BÃ©zout, existen s, t âˆˆ Z tal que
s Â· 78 + t Â· 32 = 2. En este caso, una posibilidad es 7 Â· 78 âˆ’ 17 Â· 32 = 2, es decir s = 7 y
t = âˆ’17.
s y t se pueden obtener asÃ­: Primero despejamos los residuos en el algoritmo de
Euclides de abajo hacia arriba, iniciando con el mÃ¡ximo comÃºn divisor. Luego hacemos
sustituciÃ³n hacia atrÃ¡s, sustituyendo las expresiones de los residuos. En cada paso se ha
subrayado el residuo que se sustituye

2
78
32
14
4

=
=
=
=

32 Â· 2 + 14
14 Â· 2 + 4
4Â·3+2
2Â·2+0

âˆ’â†’ 14 = 78 âˆ’ 32 Â· 2
âˆ’â†’ 4 = 32 âˆ’ 14 Â· 2
âˆ’â†’ 2 = 14 âˆ’ 4 Â· 3

_â†‘
_â†‘

=â‡’

=
=
=
=
=

14 âˆ’ 4 Â· 3
14 âˆ’ (32 âˆ’ 14 Â· 2)3
14 Â· 7 âˆ’ 32 Â· 3
(78 âˆ’ 32 Â· 2)7 âˆ’ 32 Â· 3
7 Â·78 + âˆ’ 17 Â·32
|{z}
|{z}
s

t

Ejemplo 2.22
Calcular s, t âˆˆ Z tal que s Â· âˆ’8 + t Â· 22 = mcd (âˆ’8, 22).
SoluciÃ³n:
Calcular mcd (âˆ’8, 22)

âˆ’8
22
14
8
6

2.6.1

=
=
=
=
=

âˆ’1 Â· 22 + 14
1 Â· 14 + 8
1Â·8+6
1Â·6+2
3Â·2+0

CÃ¡lculo de s y t
2

=
=
=
=
=
=
âˆ´

8âˆ’6
8 âˆ’ (14 âˆ’ 8)
8 Â· 2 âˆ’ 14
8 Â· 2 âˆ’ (âˆ’8 + 22)
8 Â· 3 âˆ’ 22
âˆ’8 Â· âˆ’3 + âˆ’1 Â· 22
s = âˆ’3 y t = âˆ’1

Algoritmo e implementaciÃ³n.

En este contexto, a/b denota el cociente de dividir a por b. El agoritmo implementa la sustituciÃ³n hacia atrÃ¡s que vimos antes.

EJERCICIOS

35

Algoritmo 2.3: Algoritmo Extendido de Euclides
Datos: a, b enteros no ambos nulos
Salida: mcd ( a, b), t y s
1 c = | a |, d = | b | ;
2 c1 = 1, d1 = 0 ;
3 c2 = 0, d2 = 1 ;
4 while d 6 = 0 do
q = c/d,
r = c âˆ’ qd,
r1 = c1 âˆ’ qd1 , r2 = c2 âˆ’ qd2 ,
c = d,
c1 = d1 ,
c2 = d2 ,
5
d = r,
d1 = r1 ,
d2 = r2 ,
6

return mcd (a,b) = |c|, s = c1 /sgn( a) Â· sgn(c), t = c2 /sgn(b) Â· sgn(c) ;


Recordemos que sgn( x ) =

1 si x â‰¥ 0
.
âˆ’1 si x < 0

Validez del algoritmo. La validez de este algoritmo se establece probando que en todo el ciclo
While, se tiene

c

= c1 | a | + c2 | b |

d

= d1 | a | + d2 | b |

(2.1)

Al final, cuando d = 0, obtenemos s y t usando los datos en (2.1).

Como | x | = x/sgn( x ) = x Â· sgn( x ), entonces

|c| =
=

c1
c2
| a| +
|b|
sgn(c)
sgn(c)
c1
c2
a+
b
sgn(c) Â· sgn( a)
sgn(c) Â· sgn(b)
|
|
{z
}
{z
}
s

t

ImplementaciÃ³n en VBA Excel. Primero debemos implementar una funciÃ³n signo acorde con
nuestra definiciÃ³n. Luego implementamos el algoritmo tal cuÃ¡l.

[Descargar]

36

DIVISIBILIDAD

Option Explicit
Private Sub Calcular_Click()
Dim a, b
Dim vector() As Long
a = Cells(8, 2) : b = Cells(8, 3)
vector = EuclidesExtendido(a, b)
Cells(8, 4) = vector(1) : Cells(8, 5) = vector(2) : Cells(8, 6) = vector(3)
End Sub
Function signo(x)
If x < 0 Then
signo = -1
Else signo = 1
End If
End Function
Dim mcdst() As Long
Dim c, c1, c2, d, d1, d2, q, r, r1, r2
ReDim mcdst(3)
Function EuclidesExtendido(a, b) As Long()
c = Abs(a) : d = Abs(b)
c1 = 1 : c2 = 0
d1 = 0 : d2 = 1
While d <> 0
q = c \ d
r = c - q*d
r1 = c1 - q*d1
r2 = c2 - q*d2
c = d : c1 = d1 : c2 = d2
d = r : d1 = r1 : d2 = r2
Wend
mcdst(1) = Abs(c)

â€™mcd(a,b)

mcdst(2) = c1 * signo(a) * signo(c) â€™s
mcdst(3) = c2
â€™t
EuclidesExtendido= mcdst()
End Function

2.7

Ecuaciones DiofÃ¡nticas lineales.

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

EJERCICIOS

37

Consideremos el problema de resolver ax + by = c en enteros. AquÃ­ a, b, c son dados y se debe
determinar x, y âˆˆ Z. Las condiciones de existencia de soluciones y el mÃ©todo para obtenerlas se
basa en el algoritmo extendido de Euclides.

Ejemplo 2.23
Consideremos la ecuaciones en enteros 2x + 3y = 2 y 6x âˆ’ 3y = 1 GrÃ¡ficamente, las soluciones enteras corresponden a los pares ( x, y) âˆˆ Z Ã— Z contenidos en la representaciÃ³n
grÃ¡fica de cada recta.
En el caso de 2x + 3y = 2, en la figura (2.1), se puede observar que
(âˆ’5, 4), (âˆ’2, 2), (1, 0), (4, âˆ’2), (7, âˆ’4) son algunas soluciones. En el caso de la recta
6x âˆ’ 3y = 1, no se observan soluciones; Â¿tendrÃ¡ alguna?

6
4
2
-5

5

Figura 2.1. Algunas soluciones enteras de la ecuaciÃ³n 2x + 3y = 2.

Teorema 2.11
La ecuaciÃ³n diofÃ¡ntica lineal ax + by = c tiene soluciones x, y âˆˆ Z si y sÃ³lo si mcd ( a, b)|c

Prueba: Sea d = mcd ( a, b)
â€œ=â‡’ â€: Si existen x, y âˆˆ Z tal que c = ax + ay, entonces d|c pues d| a y d|b.
â€œâ‡= â€: Si d|c entones c = kd. Como podemos determinar, usando el algoritmo extendido de Euclides, s, t âˆˆ Z tal que d = sa + tb, entonces c = kd = (ks) a + (kt)b y una soluciÃ³n de la ecuaciÃ³n
diofÃ¡ntica lineal serÃ­a x = ks y y = kt.

Ejemplo 2.24
La ecuaciÃ³n en enteros 2x + 3y = 2 tiene soluciÃ³n pues mcd (2, 3) = 1 y 1|2. La ecuaciÃ³n
en enteros 6x âˆ’ 3y = 1 no tiene soluciones enteras pues mcd (6, 3) = 3 y 3 - 1.

38

DIVISIBILIDAD

Ejemplo 2.25
Calcule una soluciÃ³n para la ecuaciÃ³n en enteros âˆ’8x + 22y = 20
SoluciÃ³n: En el ejemplo (2.21) encontramos que 2 = mcd (âˆ’8, 22) y que 2 = âˆ’3 Â· âˆ’8 +
âˆ’1 Â· 22. Ahora, como 20 = 2 Â· 10,
2 = âˆ’3 Â· âˆ’8 + âˆ’1 Â· 22 =â‡’ 20 = âˆ’30 Â· âˆ’8 + âˆ’10 Â· 22.
AsÃ­, una soluciÃ³n de la ecuaciÃ³n diofÃ¡ntica es x = âˆ’30 âˆ§ y = âˆ’10 .

SoluciÃ³n general. La soluciÃ³n general se establece al estilo de las ecuaciones diferenciales y el
Ã¡lgebra lineal: Primero se busca la soluciÃ³n de la ecuaciÃ³n homogÃ©nea ax + by = 0 y la soluciÃ³n
general de la ecuaciÃ³n ax + by = c se expresa usando esta soluciÃ³n.

Teorema 2.12
Sea d = mcd ( a, b). Las soluiones de la ecuaciÃ³n diofÃ¡ntica lineal homogÃ©nea ax + by = 0 son de
la forma,
b
a
x = t,
y = âˆ’ t con t âˆˆ Z.
d
d

a
b
y
son enteros. Sustituyendo directamente x e y se observa que efectid
d
vamente son soluciones de la ecuaciÃ³n homÃ³genea para cualquier t âˆˆ Z.

Prueba: Claramente

Ahora hay que mostrar que cualquier otra soluciÃ³n x, y âˆˆ Z tiene esa forma. Sea a = kd y
b = k0 d. ax + by = 0 =â‡’ ax = âˆ’by =â‡’ k x = âˆ’k0 y. Esto Ãºltimo dice que k|(âˆ’k0 y). Ahora
b
a
como mcd (k , k0 ) = 1, entonces por el corolario 2.5, k|(âˆ’y). Por tanto y = âˆ’ t y x = t, t âˆˆ Z.
d
d

Teorema 2.13
Sea d = mcd ( a, b). Si la ecuaciÃ³n diofÃ¡ntica lineal ax + by = c tiene una soluciÃ³n x = x0 , y = y0 ,
b
a
entonces la soluciÃ³n general es x = x0 + t, y = y0 âˆ’ t con t âˆˆ Z.
d
d

Prueba: Sean x = x0 , y = y0 , soluciÃ³n de ax + by = c. Tenemos,
ï£±
ï£²

ax + by = c

ï£³

ax0 + by0 = c

ï£±
EcuaciÃ³n homogÃ©nea
ï£² x âˆ’ x0 = (b/d) t =â‡’ x = x0 + (b/d)t
}|
{
z
=â‡’ a( x âˆ’ x0 ) + b(y âˆ’ y0 ) = 0 =â‡’
ï£³
y âˆ’ y0 = (âˆ’ a/d) t =â‡’ y = y0 âˆ’ ( a/d)t

EJERCICIOS

39

Ejemplo 2.26
Consideremos la ecuaciÃ³n en enteros 2x + 3y = 2. Como una soluciÃ³n particular es
( x0 , y0 ) = (1, 0), entonces la soluciÃ³n general es x = 1 + 3t, y = 0 âˆ’ 2t, t âˆˆ Z.
k
Â·s
âˆ’4
âˆ’3
âˆ’2
âˆ’1
0
1
2
3
4
Â·s

6
4
2
5
-5
5

Figura 2.2. Soluciones enteras de la ecuaciÃ³n
2x + 3y = 2.

2.8

x

y

âˆ’11
âˆ’8
âˆ’5
âˆ’2
1
4
7
10
13

8
6
4
2
0
âˆ’2
âˆ’4
âˆ’6
âˆ’8

Teorema fundamental de la aritmÃ©tica

Antes de enunciar el teorema fundamental de la aritmÃ©tica, veamos un ejemplo muy familiar
Ejemplo 2.27
Podemos factorizar 36 como un producto de primos: En cada paso buscamos el divisor
primo mÃ¡s pequeÃ±o:

36

= 2 Â· 18
= 2Â·2Â·9
= 2Â·2Â·3Â·3

El mÃ©todo que usamos es el procedimiento usual de la escuela. Obtener la factorizaciÃ³n
prima de un nÃºmero n dividiendo por los primos â‰¤ n

36

84

18

2

9

2

42

2

21

2

3

3

7

3

1

3

1

7

36 = 22 Â· 32

84 = 22 Â· 3 Â· 7

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

40

DIVISIBILIDAD

Lema 2.2 (Lema de Euclides).
Si p es primo y p| ab entonces p| a o p|b.
Prueba: Supongamos que p| ab pero p - a. En este caso mcd ( p, a) = 1 por ser p primo (el Ãºnico
factor en comÃºn serÃ­a p o 1), entonces por el corolario 2.5, concluimos que p|b.
Teorema 2.14 (Fundamental de la aritmÃ©tica).
Todo nÃºmero natural compuesto n > 1 se puede factorizar de manera Ãºnica como
Î²

Î²

Î²

n = p1 1 p2 2 Â· spk k
donde p1 , . . . , pn son primos distintos y Î² 1 , . . . , Î² n son enteros positivos. Esta factorizaciÃ³n se
llama la factorizaciÃ³n prima de n.
Prueba: La prueba se hace por inducciÃ³n completa. El resultado es cierto para n = 2. Supongamos ahora que el resultado es cierto para n = 3, 4, ..., k. Hay que probar que es cierto para
k + 1. Si k + 1 es primo, listo. Si k + 1 es compuesto, entonces existen a, b âˆˆ Z, 1 < a â‰¤ b < k + 1,
tal que k + 1 = ab. Pero, por hipÃ³tesis de inducciÃ³n a y b factorizan como producto de primos,
asÃ­ que k + 1 tambiÃ©n factoriza como producto de primos, a saber, los factores de a y b.
Unicidad: La prueba es por contradicciÃ³n. Supongamos que n = r1 r2 Â· sru = q1 q2 Â· sqv donde
todos los ri0 s y los q0j s son primos, r1 â‰¤ r2 â‰¤ ... â‰¤ ru y q1 â‰¤ q2 â‰¤ ... â‰¤ qv . Si cancelamos los primos
iguales que hay en ambos lados nos queda
ri1 ri2 Â· srin = q j1 q j2 Â· sq jm (todos distintos)
entonces
ri1 (ri2 Â· srin ) = q j1 q j2 Â· sq jm ,
es decir, ri1 divide a q j1 q j2 Â· sqim , entonces por el lema de Euclides, ri1 divide a algÃºn q jt , por
tanto ri1 = q jt : ContradicciÃ³n pues los asumimos distintos.
Nota: Observe que el nÃºmero 1 no es ni primo ni compuesto. Esto garantiza la unicidad de la
factorizaciÃ³n.

MÃ¡ximo comÃºn divisor y MÃ­nimo comÃºn MÃºltiplo.

DefiniciÃ³n 2.4
Si a, b âˆˆ Z+ entonces el mÃ­nimo comÃºn mÃºltiplo de a y b es el mÃ¡s pequeÃ±o entero m > 0 tal
que a|m y b|m. Se escribe mcm ( a, b) = m

Para el teorema que sigue necesitamos aclarar la notaciÃ³n. Necesitamos que dos nÃºmeros tengan los mismos factores primos en una factorizaciÃ³n por conveniencia; lo que hacemos es que
completamos con potencias p0k . Por ejemplo, si

EJERCICIOS

41

a = 22 Â· 33 Â· 74 Â· 192

b = 2 Â· 32 Â· 112 ,
entonces la factorizaciÃ³n por conveniencia serÃ­a
a = 22 Â· 33 Â· 74 Â· Â·110 Â· 192

b = 2 Â· 32 Â· 70 Â· 112 Â· 190 .

Teorema 2.15
Si a, b son enteros positivos, supongamos que
k

a = âˆ pi i , Î±i â‰¥ 0
Î±

i =1
k

b = âˆ pi i , Î² i â‰¥ 0
Î²

i =1

Donde Î±i y Î² i podrÃ­an ser cero con el propÃ³sito de completar la factorizaciÃ³n prima de a con
los primos de la factorizaciÃ³n prima de b y viceversa (se completan con potencias p0k ). Entonces,
k

mcd ( a, b) = âˆ pi i , Î³i = mÃ­n {Î±i , Î² i }, i = 1, ..., k
Î³

i =1
k

mcm ( a, b) = âˆ pi i , Î´i = mÃ¡x{Î±i , Î² i }, i = 1, ..., k
Î´

i =1

En particular mcd ( a, b) mcm ( a, b) = ab, es decir
mcm ( a, b) =

ab
.
mcd ( a, b)

Prueba: Ejercicio.
Aunque para nÃºmeros pequeÃ±os, el mÃ©todo de la factorizaciÃ³n prima sirve para calcular mcd (n, m)
y el mcm (n, m), en general, es computacionalmente ineficiente, por el costo de obtener esta factorizaciÃ³n. Un algoritmo mÃ¡s adecuado estÃ¡ basado en el teorema (2.5).

Ejemplo 2.28
A partir de la factorizaciÃ³n prima de dos nÃºmeros a, b podemos calcular el mcd ( a, b) y
el mcm ( a, b).

42

DIVISIBILIDAD

36
18

84
2

9

2

3

3

1

3

36 = 22 Â· 32 Â· 70

Luego, mcd (36, 84) =

22

Â· 3 Â· 70

42

2

21

2

7

3

1

7

84 = 22 Â· 3 Â· 7

= 12 y el mcm (36, 84) = 22 Â· 32 Â· 7 = 252.

Ejemplo 2.29 (Suma de fracciones).

Realizar la suma

5
7
3
+
+ .
36 84 4

SoluciÃ³n: Como mcm (36, 84, 4) = 252, entonces

5
7
3
+
+
36 84 4

=
=
=

7Â·5
3Â·7
63 Â· 3
+
+
252
252
252
245
35
=
252
36

Para el mÃ­nimo comÃºn mÃºltiplo de una lista de nÃºmeros tenemos un teorema similar al teorema
del mÃ¡ximo comÃºn divisor.

Teorema 2.16
mcm ( a1 , a2 , ..., an ) = mcm ( a1 , mcm ( a2 , ..., an )).

Prueba: Ejercicio.
En la secciÃ³n que trata sobre el â€œteorema chino del restoâ€ vamos a necesitar los dos corolarios
que siguen y, en su momento, haremos referencia a ellos.

Corolario 2.6 Si m1 , m2 , ..., mk son primos relativos dos a dos, entonces
mcm (m1 , m2 , ..., mk ) = m1 Â· m2 Â· smk .
Prueba: Ejercicio.
Corolario 2.7 Si m1 , m2 , ..., mk , a âˆˆ Z+ y si mi | a, i = 1, 2, ..., k; entonces
mcm (m1 , m2 , ..., mk )| a.
Prueba: Por inducciÃ³n completa.

EJERCICIOS

43

La afirmaciÃ³n es claramente correcta para k = 1 y k = 2. Asumamos que es correcta para 1, 2, ..., t.
Ahora, supongamos que mi | a, i = 1, 2, . . . , t, t + 1 entonces mcd (m1 , m2 , . . . , mt )| a por la hipÃ³tesis de inducciÃ³n y mt+1 | a, pero entonces los dos nÃºmeros mcd (m1 , m2 , . . . , mt ) y mt+1 dividen a, asÃ­ que la hipÃ³tesis de inducciÃ³n nos dice que mcd ( mcd (m1 , m2 , . . . , mt ), mt+1 )| a, i.e.
mcm (m1 , m2 , ..., mk )| a por el teorema (2.16).
Ejemplo 2.30
El entero 290290 es divisible por 10, 77 , y 13. Como mcd (10, 77) = 1, mcd (10, 13) = 1
y mcd (77, 13) = 1; entonces mcm (10, 77, 13) = 10 Â· 77 Â· 13 = 10010 y 10010 | 290290.

Ejemplo 2.31
Muestre que si p = 4k + 1 y p = 3k0 + 1 entonces hay un k00 âˆˆ Z tal que p = 12k00 + 1
SoluciÃ³n: Como mcd (4, 3) = 1, 4|( p âˆ’ 1) y 3|( p âˆ’ 1), entonces mcm (3, 4) = 12 y
12|( p âˆ’ 1), es decir, hay un k00 âˆˆ Z tal que p âˆ’ 1 = 12k00 .

EJERCICIOS
2.8

Muestre que los divisores de n ocurren en pares, es decir, si d|n con n = kd, entonces k|n.

2.9 De un par de ejemplos que muestren que en general, si d = mcd ( a, b), entonces d 6=
mcd ( a, a âˆ’ nb) con n âˆˆ Z
2.10

Muestre que mcd ( ab, m)| mcd ( a, m) mcd (b, m) (Use Id. Bezout).

2.11

Muestre que mcd ( a, b) = 1 entonces mcd ( a, m) mcd (b, m) = mcd ( ab, m)

2.12

Probar el corolario 2.4.

2.13

Muestre que si mcd ( a, b) = 1 y si mcd ( a, c) = 1,

2.14 Muestre que si mcd ( a1 , m) = 1, mcd ( a2 , m) = 1, . . . , mcd ( ak , m) = 1 entonces mcd ( a1 Â·
a2 Â· sak , m) = 1.
2.15 Muestre, usando la identidad de Bezout, que si mcd ( a, b) = d y si a = k1 d y b = k2 d,
entonces mcd (k1 , k2 ) = 1
2.16

Muestre que si d = mcd ( a, b) y si ra + sb = d, entonces mcd (r, s) = 1.

2.17

Muestre que si am + bn = h entonces mcd ( a, b)|h

44

DIVISIBILIDAD

2.18

Muestre que la ecuaciÃ³n diofÃ¡ntica ax + by = h tiene soluciÃ³n solo si mcd ( a, b)|h

2.19

Resuelva la ecuaciÃ³n diofÃ¡ntica 24 = 365x + 1876y

2.20 Sea p un nÃºmero primo. Determinar todos los enteros k âˆˆ Z tales que
ral. Ayuda: Si p2 = ab =â‡’ ( a = p âˆ§ b = p) âˆ¨ ( a = p2 âˆ§ b = 1)

p

k2 âˆ’ kp es natu-

2.21 Sean q1 , . . . , qn y pi todos nÃºmeros primos distintos. Use inducciÃ³n matemÃ¡tica para probar que si pi |q1 q2 Â· sqn entonces pi = q j para algÃºn j âˆˆ 1, 2, ..., n.
2.22

Sea p primo, si p| an =â‡’ p| a

2.23 Muestre que si p es primo, entonces
âˆš
suponga n p = a/b con mcd ( a, b) = 1.

âˆš
n

p no es racional. Ayuda: Por contradicciÃ³n,

2.24

Sean mcd ( a, b) = 1 y p primo, entonces p - mcd ( an , bn ).

2.25

Muestre que si mcd ( a, p) = 1 con p primo, entonces mcd ( a, ps ) = 1, con s > 0.

2.26 Sean m y n son primos relativos. Muestre que si mn = ak , k â‰¥ 0; entonces existe x, y âˆˆ Z
tal que m = x k y n = yk . Ayuda: Use la descomposiciÃ³n en factores primos de cada uno de los
nÃºmeros.
2.27

Consideremos la descomposiciÃ³n prima n = âˆik pi i . Â¿ mcm ( p1 1 , . . . , pk k ) = n?
Î±

Î±

Î±

2.28 Supongamos que los enteros m y n son primos relativos. Muestre que si d|mn, entonces
âˆƒ b, c Ãºnicos tal que d = bc con b|m y c|n.
2.29

Si 4| p âˆ’ 3 y 3| p âˆ’ 1, muestre que 12| p + 1.

2.30

Sea n > 1 y p el mÃ¡s pequeÃ±o divisor primo de n. Muestre que mcd (n, p âˆ’ 1) = 1

2.31 Encuentre tres nÃºmeros a, b, c tal que mcd ( a, b, c) = 1 pero que mcd ( a, b) 6= 1, mcd ( a, c) 6=
1, mcd (b, c) 6= 1.
2.32

Probar que dos enteros consecutivos son primos relativos

2.33

Probar que si mcd ( a, b) = mcm ( a, b) =â‡’ a = b.

2.34

Muestre que mcd (mg, g) = g si g âˆˆ N.

2.35

Si a, b âˆˆ N, y si a|b calcule mcd ( a, b) y mcm ( a, b).

2.36 Muestre que (âˆƒ x, y âˆˆ Z tal que x + y = s âˆ§ mcd ( x, y) = g) â‡â‡’ g|s, g âˆˆ Z+ Ayuda:
Una implicaciÃ³n es directa por Bezout, la otra requiere descomponer kg = (k âˆ’ 1) g + g

EJERCICIOS

2.37

Mostrar que si mcd ( a, b) = mcd (c, d) = 1 y si

p|qc y mcd ( p, q) = 1, entonces p|c.

45

a
c
+ âˆˆ Z entonces |b| = |d|. Ayuda: Si
b
d

2.38

Mostrar que mcd ( a, b) = mcd ( a, b, ax + by) con x, y âˆˆ Z

2.39

Muestre que mcd ( a, a + 2) = 1 Ã³ 2

2.40

Sea pi el i âˆ’Ã©simo primo y sea N = p1 p2 Â· spnâˆ’1 + 1. Muestre que N â‰¥ pn .

2.41

Sean m, a, b âˆˆ Z. Muestre que mcd (ma, mb) = |m| mcd ( a, b)

2.42 Sea mcd ( a, b) = 1. Muestre que si d = mcd ( a + b, a âˆ’ b) entonces d = 1 o d = 2.
Sea mcd ( a, b) = 1 y d = mcd ( a + 2b, 2a + b). Muestre que d|3a y d|3b y por tanto, d = 1 o d = 3.
1
1 1
+ + ... + no es entero
2 3
n

2.43

Muestre que para todo n âˆˆ N, n > 1; A = 1 +

2.44

Mostrar que si d|(n2 + 1) y d|((n + 1)2 + 1) para algÃºn entero n, entonces d = 1 d = 5.

2.45

Probar que la fracciÃ³n (21n + 4)/(14n + 3) es irreducible para cualquier n âˆˆ Z

2.46

Sea N = 2 p âˆ’ 1,
a) Probar que 2ab âˆ’ 1 = (2a âˆ’ 1)(1 + 2a + 22a + 23a + Â·s + 2(bâˆ’1)a ). Ayuda: Usar la identidad
1 âˆ’ x k +1
1 + x + x2 + x3 + Â·s + x k =
, x 6= 1, k âˆˆ N.
1âˆ’x
b) Muestre que si N es primo, entonces p es primo.

2.47

Considere los nÃºmeros de Euler: Tn = 22 + 1 con n âˆˆ N.
n
a) Muestre que 22 âˆ’ 1 = Tn2âˆ’1 âˆ’ 2Tnâˆ’1
b) Muestre, usando a), que Tn âˆ’ 2 = Tnâˆ’1 Tnâˆ’2 Â· sT0
c) Muestre que si m > n, mcd ( Tn , Tm ) = 1

n

2.48 Sea n entero positivo y S un conjunto con n + 1 elementos distintos tomados del conjunto
{1, 2, ..., 2n}. Muestre que hay al menos dos elementos en S primos relativos
2.49 n â‰¥ 2. Supongamos que tomamos n + 1 enteros al azar. Muestre que hay dos elementos
tal que su diferencia es divisible por n. Ayuda: usar le principio del palomar y el algoritmo de
la divisiÃ³n: n + 1 enteros producen n + 1 restos, pero dividir por n solo produce n restos...
2.50 Mostrar que hay un nÃºmero infinito de primos de la forma 4n + 3.
Ayuda: Asuma que solo hay k primos de esa forma y considere el nÃºmero N = 4p1 p2 Â· spk + 3.

46

DIVISIBILIDAD

VersiÃ³n actualizada de este libro: https://tecdigital.tec.ac.cr/revistamatematica/Libros/

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

235711
131719
232931
235711

3
3.1

CONGRUENCIAS

Congruencias mÃ³dulo m

Recordemos que estabamos usando â€˜ r = rem( a, m) â€™ para indicar el resto (en el teorema de
la divisiÃ³n) de dividir a por m. Dos nÃºmeros â€˜â€˜son congruentes mÃ³dulo mâ€ si dejan el mismo
residuo al dividir por m, es decir si rem( a, m) = rem(b, m). Como a = qm + rem( a, m) y
b = q0 m + rem(b, m) entonces m|(b âˆ’ a).
Todos los nÃºmeros son congruentes mÃ³dulo m = 1. Si usamos m = 2, los pares son congruentes
con los pares (resto 0 mÃ³dulo 2) y los impares con los impares (resto 1 mÃ³dulo 2). En general, la
idea es â€˜agruparâ€™ los nÃºmeros segÃºn el residuo que dejan al dividir por m. Estos subconjuntos
constituyen una particiÃ³n de Z de tal manera que podemos trabajar no con todo Z sino con un
grupo de representantes.

DefiniciÃ³n 3.1
Sea m âˆˆ Z, m â‰¥ 1. Decimos que a es congruente con b mÃ³dulo m si m|(b âˆ’ a). Escribimos
a â‰¡ b (mod m) o tambiÃ©n a â‰¡m b

Ejemplo 3.1
a.) 10 â‰¡ 0 (mod 5)
b.) 10 â‰¡ 1 (mod 3)

pues
pues

5|(10 âˆ’ 0)
3|(10 âˆ’ 1)

c.) 10 â‰¡ âˆ’1 (mod 11)
d.) 5 â‰¡ 3 (mod 2)

pues
pues

11|(10 + 1)
2|(3 âˆ’ 5)

Teorema 3.1
b âˆ’ a â‰¡ 0 (mod m)

(ii)

a = mk + b,

(iii)

rem( a, m) = rem(b, m) (residuos mÃ³dulo m)

â‡
â‡’

(i)
a â‰¡ b (mod m) â‡â‡’

para algÃºn k âˆˆ Z

â‡’
â‡

Prueba: Probemos (iii) usando el teorema de la divisiÃ³n.
47

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

48

CONGRUENCIAS

â€ =â‡’ â€ Sea rem( a, m) = r1 y rem(b, m) = r2 , es decir, a = q1 m + r1 con 0 â‰¤ r1 < m y b =
q2 m + r2 con 0 â‰¤ r2 < m. Supongamos que r1 > r2 , entonces b âˆ’ a = (q1 âˆ’ q2 )m + (r1 âˆ’ r2 ) con
0 â‰¤ r1 âˆ’ r2 < m pues 0 < r1 âˆ’ r2 < r1 < m. Pero m|(b âˆ’ a), por tanto b âˆ’ a = mq3 , como el resto
es Ãºnico (en el esquema del teorema de la divisÃ³n) entonces r2 = r1 . El caso r1 < r2 es idÃ©ntico.
â€ â‡= â€ Si a = q1 m + r1 con 0 â‰¤ r1 < m y b = q2 m + r2 con 0 â‰¤ r2 < m, entonces b âˆ’ a = q3 m, es
decir, m|(b âˆ’ a).

(NotaciÃ³n de congruencia y residuo).
Si r es el residuo r = rem( a, m), entonces a â‰¡ r (mod m)
El sÃ­mbolo â€œ â‰¡ â€ se puede manipular como â€œ=â€ excepto para la cancelaciÃ³n:

Teorema 3.2
Sean a â‰¡ b (mod m) a0 â‰¡ b0 (mod m) y c, k âˆˆ Z. Entonces,
a.) ka â‰¡ kb (mod m), en particular si k â‰¥ 0, ak â‰¡ bk (mod m).
b.) aa0 â‰¡ bb0 (mod m)
c.) a Â± a0 â‰¡ b Â± b0 (mod m)
d.) a â‰¡ a (mod m) para toda a âˆˆ Z
e.) a â‰¡ b (mod m) â‡â‡’ b â‰¡ a (mod m)
f.) a â‰¡ b (mod m) âˆ§ b â‰¡ c (mod m) =â‡’ a â‰¡ c (mod m)
g.) Sea a 6= 0, ab â‰¡ ac (mod m) âˆ§ mcd ( a, m) = d =â‡’ b â‰¡ c (mod

m
d)

h.) Sea a 6= 0, ab â‰¡ ac (mod m) âˆ§ mcd ( a, m) = 1 =â‡’ b â‰¡ c (mod m)
i.) Si a â‰¡ b (mod m) y d|m , entonces a â‰¡ b (mod d)
Prueba: SÃ³lo vamos a probar algunos items, el resto queda como ejercicio.
b.) aa0 â‰¡ bb0 (mod m) : Por hipÃ³tesis existen k, k0 âˆˆ Z tal que b = mk + a y b0 = mk0 + a0 ,
multiplicando obtenemos bb0 = m(mkk0 + ka0 + k0 a) + aa0 =â‡’ m|(bb0 âˆ’ aa0 ).
g.) ab â‰¡ ac (mod m) âˆ§ mcd ( a, m) = d =â‡’ b â‰¡ c (mod md ) : En efecto, como d = mcd ( a, m)
a m
a
m
entonces
y
son enteros y mcd
,
= 1.
d
d
d d
a
m
Por hipÃ³tesis, existen k âˆˆ Z tal que ac âˆ’ ab = mk =â‡’ a(c âˆ’ b) = mk =â‡’ (c âˆ’ b) = k.
d
d
a m
m  a
m
AsÃ­,
(
c
âˆ’
b
)
âˆ§
mcd
,
=
1
=â‡’
c
âˆ’
b
)
por
el
corolario
??.
|(

d d
d d
d

49

Ejemplo 3.2 (ManipulaciÃ³n algebraica mÃ³dulo m ).
a.) Muestre que si a â‰¡ b (mod m) y si c â‰¡ a + d (mod m) entonces c â‰¡ b + d (mod m).
SoluciÃ³n: Como 0 â‰¡ b âˆ’ a (mod m) y c â‰¡ a + d (mod m), sumando miembro a
miembro (teorema 3.2 c.)) se obtiene c â‰¡ b + d (mod m)
b.) Muestre que si a â‰¡ b (mod m) y si c â‰¡ ad (mod m) entonces c â‰¡ bd (mod m)
SoluciÃ³n: Existe k, k0 âˆˆ Z tal que a = mk + b y c âˆ’ ad = mk0 , entonces c âˆ’ ad =
c âˆ’ (mk + b)d = mk0 =â‡’ c âˆ’ bd = m(k0 + kd) =â‡’ c â‰¡ bd (mod m).
â‰¡ 0
10

â‰¡ 0
10

â‰¡ 7
10

z }| { z }| { z }| {
c.) d â‰¡ [8 + 2 + 3 + 2 + 5 + 5 + 2] (mod 10) =â‡’ d â‰¡ 7 (mod 10)
d.) Calcular rem(95 , 5) (el resto de dividir 95 por 5).
SoluciÃ³n: Recordemos que rem(95 , 5) = r si 95 â‰¡ r (mod 5). Como 9 â‰¡ âˆ’1 (mod 5)
entonces 95 â‰¡ (âˆ’1)5 (mod 5), es decir rem(95 , 5) = âˆ’1 o tambiÃ©n 95 = 11810 Â· 5 âˆ’ 1.
Si queremos el resto positivo (como en el esquema del teorema de la divisiÃ³n),
observamos que âˆ’1 â‰¡ 4 (mod 5), por tanto rem(95 , 5) = 4 o tambiÃ©n 95 = 11809 Â·
5 + 4.

Ejemplo 3.3
Calcular el resto de dividir 15196 por 13.
SoluciÃ³n: La idea es descomponer 15196 en potencias mÃ¡s pequeÃ±as. Si r es el resto
buscado, 15196 â‰¡ r (mod 13).
15196

â‰¡
â‰¡
â‰¡
â‰¡
â‰¡

rem(2196 , 13),
pues 15 â‰¡ 2 (mod 13),
 7Â·7
rem( 22Â·2
, 13), pues 196 = 2 Â· 2 Â· 7 Â· 7,
7
rem( 37 , 13),
pues 24 = 16 â‰¡ 3 (mod 13),
2
rem((3)7 , 13),
pues 37 = 33 Â· 3 â‰¡13 12 Â· 3 â‰¡ 3 (mod 13)
rem(3, 13)
pues 37 â‰¡ 3 (mod 13).

AsÃ­, el resto de dividir 15196 por 13 es 3.

Ejemplo 3.4
Resolver 4x â‰¡ 8 (mod 12) con x âˆˆ {0, 1, 2, ..., 11}.

50

CONGRUENCIAS

SoluciÃ³n: PodrÃ­amos resolver esta congruencia por ensayo y error, pero la vamos a
resolver usando el teorema 3.2 g.).
4x â‰¡ 8 (mod 12) =â‡’ x â‰¡ 2 (mod 3) por el teorema 3.2 g.)
Luego, los x âˆˆ {0, 1, 2, ..., 11} que dejan resto 2 al dividir por 3 son x = 2, 5, 8 y 11.

No siempre usamos el residuo del teorema de la divisÃ³n porque a veces los residuos negativos
son, en valor absoluto, mÃ¡s pequeÃ±os.
Ejemplo 3.5
Calcular el resto de la divisiÃ³n de 12201 por 13, es decir, calcular 12201 mod 13
Como 12 â‰¡ âˆ’1 (mod 13) =â‡’ 12201 â‰¡ (âˆ’1)201 (mod 13). Entonces, por transitividad
12201 â‰¡ 12 (mod 13). Esto dice que 12201 mod 13 = 12 mod 13 = 12

Ejemplo 3.6
Calcular 13300 mod 7.
Aunque 13 â‰¡ 5 (mod 7) es mejor iniciar con 13 â‰¡ âˆ’2 (mod 7) pues de esta congruencia obtene-mos 133 â‰¡ âˆ’8 (mod 7) y âˆ’8 â‰¡ 1 (mod 7). AsÃ­, 13300 â‰¡ 1 (mod 7) =â‡’
13300 mod 7 = 1 mod 7 = 1.

3.2

(*) Calendarios: Â¿QuÃ© dÃ­a naciÃ³ Ud?.

Supongamos que queremos saber el dÃ­a de la semana correspondiente a una fecha dada: Por
ejemplo, Â¿quÃ© dÃ­a fue el 9 de mayo de 1973?
En varios libros se hace un anÃ¡lisis de como resolver este problema, por ejemplo en [3]; aquÃ­ solo
vamos a dar la soluciÃ³n, segÃºn el calendario Gregoriano.
Primero debemos numerar los dÃ­as y los meses, como se muestra en en la tabla que sigue (a
febrero se le asigna el 12; febrero es especial por ser el mes al que se agrega un dÃ­a en aÃ±o
bisiesto).
Ahora, sea f = fecha, m = mes, a = aÃ±o, s = siglo y n = aÃ±os en el siglo. Por ejemplo, si tenemos la fecha: abril 1, 1673 entonces: f = 1, m = 2, a = 1673 = 100s + n donde s = 16 y n = 73.
Finalmente, si d denota el dÃ­a de la semana correspondiente a la fecha ( f , m, a), entonces

51
Domingo
Lunes
Martes
MiÃ©rcoles
Jueves
Viernes
SÃ¡bado

=0
=1
=2
=3
=4
=5
=6

Marzo
Abril
Mayo
Junio
Julio
Agosto
Setiembre

=1
=2
=3
=4
=5
=6
=7

Octubre
Noviembre
Diciembre
Enero
Febrero

=8
=9
= 10
= 11
= 12

Tabla 3.1

s

{
r s z rnz
13m âˆ’ 1
dâ‰¡ f +
âˆ’ 2s + n +
+
(mod 7)
5
4
4
Un detalle. En esta redistribuciÃ³n, el aÃ±o inicia en Marzo y finaliza en Febrero. Este es un detalle
a tener en cuenta: Las fechas que involucran a enero y febrero se les debe restar un aÃ±o, pues en esta
fÃ³rmula estos meses estÃ¡n en el aÃ±o anterior. Por ejemplo, si tenemos la fecha 3 de enero del
2010 entonces f = 3, m = 11 y a = 2009 = 100s + n donde s = 20 y n = 9.

100s + n âˆ’ 1
enero febrero

100s + n
marzo
marzo

abril
abril

Â·Â·Â·
Â·Â·Â·

diciembre
diciembre

Ahora ya puede calcular quÃ© dÃ­a naciÃ³ Ud.
Ejemplo 3.7
a.) El 9 de mayo de 1973 fue miÃ©rcoles = 3; pues f = 9, m = 3, A = 1973 = 100s + n con
s = 19 y n = 73. Usando la fÃ³rmula obtenemos,
d â‰¡ 9 + 7 âˆ’ 38 + 73 + 4 + 18 â‰¡ 3 (mod 7)

a.) El 3 de enero del 2010 fue domingo = 0; pues f = 3, m = 11, A = 2009 = 100s + n
con s = 20 y n = 9. Usando la fÃ³rmula obtenemos,
d â‰¡ 3 + 28 âˆ’ 40 + 19 + 5 + 4 â‰¡ 0 (mod 7)

a.) El 29 de febrero del 2008 fue viernes, verifÃ­quelo!

52

CONGRUENCIAS

ImplementaciÃ³n en Excel.

[Descargar]

Private Sub CommandButton1_Click()
Dim f, m, s, n, d, dia
f = Cells(8, 1)
m = Cells(8, 2)
s = Cells(8, 3)
n = Cells(8, 4)
If m=11 or m=12 then
n=n-1
End If
d = (f+Int((13*m-1)/5)-2*s+n+Int(s/4)+Int(n/4))Mod 7
If d<0 then
d=d+7
End If
dia = Switch(d = 0,"D",d =1,"L",d=2,"K",d=3,"M",d=4,"J",d=5,"V",d=6,"S")
Cells(8, 5) = dia
End Sub

3.3

Trucos de divisibilidad.

Si a = an 10n + anâˆ’1 10nâˆ’1 + ... + a1 10 + a0 , la suma de sus dÃ­gitos es congruente con a mÃ³dulo
9, en efecto, como 10 â‰¡ 1 (mod 9) entonces 10i â‰¡ 1 (mod 9), i = 0, 1, 2, ... Luego, multiplicando
por ai y sumando
n

n

âˆ‘ ai 10i â‰¡ âˆ‘ ai

i =0
n

i =0

n

âˆ‘ ai 10i â‰¡ âˆ‘ ai

i =0

n

(mod 9) =â‡’ a â‰¡

i =0

âˆ‘ ai

(mod 9)

i =0
n

(mod 3) =â‡’ a â‰¡

âˆ‘ ai

(mod 3) pues 3|9

i =0

a.) Divisibilidad por 9 : 9 divide a a si y sÃ³lo si 9 divide la suma de sus dÃ­gitos, es decir,
9| a â‡â‡’ 9 |âˆ‘in=0 ai

53
n

En efecto, como a â‰¡

âˆ‘ ai

(mod 9) entonces 9 |(âˆ‘in=0 ai âˆ’ a) . Si 9| a entonces divide la

i =0

suma de sus dÃ­gitos y si 9 divide la suma de los dÃ­gitos de a entonces divide a a.
b.) Divisibilidad por 3 : 3 divide a a si y sÃ³lo si 3 divide la suma de sus dÃ­gitos. La demostraciÃ³n es igual a la anterior, cambiando 9 poe 3.
c.) Divisibilidad por 2 y por 5 : tanto 2 como 5 dividen a a si y sÃ³lo si dividen a0 .
n

En efecto: Observemos que a =
n

dividen a la suma

âˆ‘ ai 10

âˆ‘ ai 10i

+ a0 . Tanto 2 como 5 dividen a ai 10i , por tanto,

i =1
i

+ a0 si y solo si tanto 2 y 5 dividen a a0

i =1

d.) Divisibilidad
 por 11 : 11 divide a a si y sÃ³lo si 11 divide la suma alternada de sus dÃ­gitos,
es decir, 11 âˆ‘in=0 (âˆ’1)i ai
En efecto, esto es consecuencia de que 10 â‰¡ âˆ’1 (mod 11).

3.4

(*) Cuadrados MÃ¡gicos

Un cuadrado mÃ¡gico es un arreglo de n Ã— n nÃºmeros en el que la suma de las entradas de cada
fila o columna siempre es la misma. Por ejemplo, consideremos el cuadrado mÃ¡gico 3 Ã— 3
ï£®
ï£¹
4 2 6
ï£° 0 7 5 ï£» , tanto las filas como las columnas suman 12
8 3 1
En la actualidad hay varios mÃ©todos para construir cuadrados
mÃ¡gicos. En 1693 De la LoubÃ¨re dio un mÃ©todo para construir
cuadrados mÃ¡gicos para cualquier n impar, el mÃ©todo es llamado el â€œMÃ©todo SiamÃ©sâ€. En 1929 D.N. Lehmer investigÃ³,
por medio de congruencias, una generalizaciÃ³n de este mÃ©todo.
El resultado es una manera sencilla de colocar los nÃºmeros
0, 1, ..., n2 âˆ’ 1 en un arreglo n Ã— n de tal manera que sea un
cuadrado mÃ¡gico. Este mÃ©todo, llamado mÃ©todo del â€œpaso uniformeâ€, calcula la entrada (i, j), usando congruencias, en la que
se debe colocar cada uno de los nÃºmeros k = 0, 1, ..., n2 âˆ’ 1 para
que el arreglo resulte â€œmÃ¡gicoâ€.
DefiniciÃ³n 3.2
Supongamos que n2 enteros diferentes son colocados en un arreglo n Ã— n. Si la suma de las
entradas de cada fila suma siempre lo mismo, decimos que el cuadrado es â€œmÃ¡gico por filasâ€. Si
la suma de las entradas de cada columna suma siempre lo mismo, decimos que el cuadrado es
â€œmÃ¡gico por columnasâ€. Si el cuadrado es ambos â€œmÃ¡gico por filasâ€ y â€œmÃ¡gico por columnasâ€,
se dice â€œcuadrado mÃ¡gicoâ€ y la suma se dice â€œsuma mÃ¡gicaâ€.
IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

54

CONGRUENCIAS

Teorema 3.3
Sea n entero positivo impar y a, b, c, d, e, f enteros, tal que mcd (c f âˆ’ de, n) = 1 Sea A = ( aij ) la
matriz n Ã— n definida asÃ­: Para cada k = 0, 1, ..., n2 âˆ’ 1,
ai+1,j+1 = k si i â‰¡ a + c Â· k + e Â· Jk/nK (mod n) y j â‰¡ b + d Â· k + f Â· Jk/nK (mod n)
Entonces,
Si mcd (c, n) = mcd (e, n) = 1, el cuadrado es â€mÃ¡gico por columnasâ€.
Si mcd (d, n) = mcd ( f , n) = 1, el cuadrado es â€mÃ¡gico por filasâ€.
Si mcd (c, n) = mcd (d, n) = mcd (e, n) = mcd ( f , n) = 1, el cuadrado es mÃ¡gico. En cada caso la
suma mÃ¡gica es n(n2 âˆ’ l )/2.

Ejemplo 3.8
Sea n = 7 y a = 4, b = 3, c = 1, d = âˆ’2, e = 1, f = âˆ’4. Como mcd (c, n) = mcd (d, n) =
mcd (e, n) = mcd ( f , n) = 1, el mÃ©todo construye un cuadrado mÃ¡gico 7 Ã— 7 con suma
mÃ¡gica 168.
k = 0 : i â‰¡ 4 + 1 Â· 0 + 1 Â· J0/7K (mod 7) y
k = 1 : i â‰¡ 4 + 1 Â· 1 + 1 Â· J1/7K (mod 7) y
k = 2 : i â‰¡ 4 + 1 Â· 2 + 1 Â· J2/7K (mod 7) y
Â·Â·Â·
ï£®
15 40 9
ï£¯ 10 28 4
ï£¯
ï£¯ 5
23 48
ï£¯
ï£¯
ï£¯ 42 18 36
ï£¯
ï£¯ 37 13 31
ï£¯
ï£° 32 1 26
27 45 14

j â‰¡ 3 âˆ’ 2 Â· 0 âˆ’ 4 Â· J0/7K (mod 7) â‡’ a5,4 = 0
j â‰¡ 3 âˆ’ 2 Â· 1 âˆ’ 4 Â· J1/7K (mod 7) â‡’ a6,2 = 1
j â‰¡ 3 âˆ’ 2 Â· 2 âˆ’ 4 Â· J2/7K (mod 7) â‡’ a7,7 = 2
34
22
17
12
0
44
39

3
47
35
30
25
20
8

21
16
11
6
43
38
33

46
41
29
24
19
7
2

ï£¹
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£º
ï£»

ImplementaciÃ³n usandoMathematica. La implementaciÃ³n, usando Mathematica, es muy
sencilla,
a = 4; b = 3; c = 1; d = -2; e = 1; f = -4; n = 7;
(*Verificar si son primos relativos?*)
{GCD[c*f - d*e, n], GCD[c, n], GCD[d, n], GCD[e, n], GCD[f, n]}
B = Array[A, {n, n}]; (*A[i,j]=k*)
Do[A[Mod[a + c*k + e*Floor[k/n], n] + 1,
Mod[b + d*k + f*IntegerPart[k/n], n] + 1] = k, {k, 0, n^2 - 1}
]
MatrixForm[B]

55

ImplemetnaciÃ³n en VBA Excel.
[Descargar]

Private Sub CommandButton1_Click()
Dim n, a, b, c, d, e, f, k, i, j
Dim CM() â€™Matriz=Cuadrado m\â€™agico
n = Cells(4, 1) : a = Cells(4, 2) : b = Cells(4, 3)
c = Cells(4, 4) : d = Cells(4, 5) : e = Cells(4, 6)
f = Cells(4, 7)
If mcd(c * f - d * e, n) = 1 And mcd(c, n) = 1 And mcd(d, n) = 1
And mcd(e, n) = 1 And mcd(f, n) = 1 Then
â€™ nada
Else: MsgBox "No se cumplen las condiciones del teorema!!! "
End If
ReDim MC(1 To n, 1 To n)
For k = 0 To n ^ 2 - 1
i = (a + c * k + e * Int(k / n)) Mod n
j = (b + d * k + f * Int(k / n)) Mod n
â€™Queremos residuos positivos
If i < 0 Then
i = i + n
End If
If j < 0 Then
j = j + n
End If
MC(i + 1, j + 1) = k
Next k
â€™Imprimir la matriz
For i = 1 To n
For j = 1 To n
Cells(5 + i, 1 + j) = MC(i, j)
Next j

56

CONGRUENCIAS

Next i
End Sub
Function mcd(a, b)
Dim c As Long, d As Long, r As Long â€™max = 2 147 483 647
c = Abs(a) : d = Abs(b)
While d <> 0
r = c Mod d â€™residuo entre (c,d)
c = d : d = r
Wend
mcd = Abs(c)
End Function

3.5

Clases residuales mÃ³dulo m

Sea m âˆˆ Z con m > 1. La relaciÃ³n â€œcongruente mÃ³dulo mâ€, denotada por brevedad con â€œâ‰¡m â€,
se define asÃ­:
a â‰¡ b (mod m) â‡â‡’ m|(b âˆ’ a)
La relaciÃ³n â€œ â‰¡m â€ es una relaciÃ³n de equivalencia, es decir, particiona Z en clases (de equivalencia.) El conjunto cociente â€œ Z/ â‰¡m â€, es el conjunto de clases de equivalencia. TambiÃ©n se usa la
notaciÃ³n Z/Zm o Zm . Denotamos con a la clase cuyo representante es a, es decir,
En Zm , a = {b âˆˆ Z : a â‰¡ b (mod m)}. En particular, 0 = m.
Es fÃ¡cil saber a quÃ© clase pertence un a âˆˆ Z arbitrario: Si a âˆˆ Z y a = mk + r con 0 â‰¤ r < m,
entonces a â‰¡ r (mod m). Entonces es natural tomar como representante de clase los residuos
positivos mÃ¡s pequeÃ±os, es decir a = rem( a, m) (recordemos que â€œ rem( a, m) â€ denota el mÃ¡s
pequeÃ±o residuo â‰¥ 0 de dividir a por m ).

Ejemplo 3.9
Si m = 2. Al dividir por dos solo hay dos posibilidades: Que el nÃºmero se a par y el resto
es 0 o que el nÃºmero sea impar y el resto es 1. Por tanto Z2 = {0, 1}, es decir Z se
particiona en dos conjuntos, los pares y los impares.

Ejemplo 3.10
La relaciÃ³n â€œ â‰¡5 â€ particiona Z en 5 clases pues, por el teorema de la divisiÃ³n, si a âˆˆ Z,
existe k âˆˆ Z tal que a = k Â· 5 + r con 0 â‰¤ r < 5; entonces al dividir por 5 solo hay
posibilidad de cinco residuos: 0, 1, 2, 3 o 4.

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

57

El conjunto cociente es Z5 = {0, 1, 2, 3, 4}.
0
...
11... 10
-5 -10
6
-9
-4
5
1 0
-3
4 -6
2
7...
3 9 -11
-8
-12 -2 -1...
2
8... -7
4
1

0 = {5k : k âˆˆ Z} = {0, Â±5, Â±10, ...}
1 = {5k + 1 : k âˆˆ Z} = {..., âˆ’9, âˆ’4, 1, 6, 11, ...}
2 = {5k + 2 : k âˆˆ Z} = {..., âˆ’8, âˆ’3, 2, 7, 12, ...}
3 = {5k + 3 : k âˆˆ Z} = {..., âˆ’7, âˆ’2, 3, 8, 13, ...}
4 = {5k + 4 : k âˆˆ Z} = {..., âˆ’6, âˆ’1, 4, 9, 14, ...}

3

En este contexto, a las clases de equivalencia se les denomina clases residuales mÃ³dulo m y, como
deciamos mÃ¡s arriba, el conjunto cociente se denota con Zm (o tambiÃ©n Z/mZ ) en vez de
Z/ â‰¡m .
Zm = {0, 1, 2, 3, Â· Â· Â· m âˆ’ 1} y Z = 0 âˆª 1 âˆª Â· Â· Â· âˆª m âˆ’ 1

Por abuso del lenguaje, es usual poner
Zm = {0, 1, 2, 3, Â· Â· Â· m âˆ’ 1}
Observe que: Si n âˆˆ Z entonces n debe estar en alguna clase y solo una, de Zm

Ejemplo 3.11
Muestre que si p > 3 es primo, p es de la forma 6k Â± 1.
SoluciÃ³n: Mmmmmm...Idea: Si p = 6k Â± 1 entonces p â‰¡ Â±1 (mod 6).
Como p âˆˆ Z, p debe estar en alguna de las clases de Z6 . No estÃ¡ en 0, 2 ni 4 pues estas
clases solo contienen pares (sus elementos son nÃºmeros de la forma 6k, 6k + 2, 6k + 4,
respectivamente). No estÃ¡ en 3 pues esta clase solo nÃºmeros de la forma 6k + 3 que son
mÃºltiplos de 3. AsÃ­ que p âˆˆ 1 o p âˆˆ 5 = âˆ’1. Es decir, p es de la forma 6k Â± 1.

Permutaciones mÃ³dulo m. En las aplicaciones a veces se usan otros conjuntos de representantes
para las clases.A estas representaciones las llamamos permutaciones del conjunto {0, 1, 2, ..., m âˆ’ 1}
mÃ³dulo m.
Por ejemplo, Z5 = {5, 7, 6, âˆ’6, 13} es una permutaciÃ³n mÃ³dulo 5 de Z5 = {0, 1, 2, 3, 4} pues

58

CONGRUENCIAS

5 â‰¡ 0 (mod 5),
7 â‰¡ 2 (mod 5),
6 â‰¡ 1 (mod 5),
âˆ’6 â‰¡ 4 (mod 5)
13 â‰¡ 3 (mod 5),

y

AdemÃ¡s, por supuesto, Z5 = {5, 7, 6, âˆ’6, 13} = {0, 1, 2, 3, 4}

Si m es impar, la representaciÃ³n simÃ©trica de Zm es


âˆ’

mâˆ’1
mâˆ’1
, . . . , âˆ’1, 0, 1, . . .
2
2



En efecto,

0 â‰¡ 0 (mod m),
1 â‰¡ 1 (mod m),
..
.
mâˆ’1
mâˆ’1
â‰¡
(mod m),
2
2

mientras que âˆ’

mâˆ’1
mâˆ’1
mâˆ’1
+iâˆ’1â‰¡
+ i (mod m), i = 1, 2, ...,
.
2
2
2

Si p es primo, existe b âˆˆ Z tal que Zm = {0, b, b2 , ..., b pâˆ’1 } (ver capÃ­tulo 5).

Ejemplo 3.12

Z5

= {0, 1, 2, 3, 4}
= {âˆ’2, âˆ’1, 0, 1, 2} pues âˆ’ 2 â‰¡ 3 (mod 5) y âˆ’ 1 â‰¡ 4 (mod 5),
= {0, 3, 32 , 33 , 34 } pues 32 â‰¡ 4 (mod 5), 33 â‰¡ 2 (mod 5), 34 â‰¡ 1 (mod 5)

Suma y producto en Zm . Ahora nos interesa ver Zm desde el punto de vista de su estructura
algebraica. Esto no solo nos permite usar un lenguaje comÃºn, sino que tambiÃ©n nos permite usar
resultados generales de la teorÃ­a de grupos, por ejemplo.
Podemos definir operaciones de suma y producto en Zm de la siguiente manera:
a + b = rem( a + b, m) i.e. a + b es el resto de dividir a + b por m
a Â· b = rem( a Â· b, m) i.e. a Â· b es el resto de dividir a Â· b por m

59

Ejemplo 3.13
En Z7 ,
5 + 6 = rem 117 = 4
5 Â· 30 = rem(150, 7) = 3
Propiedades de la suma y producto en Zm . Con estas operaciones, si m â‰¥ 2, Zm es anillo
conmutativo con identidad. Si a, b, c âˆˆ Zm ,
(1) a + b âˆˆ Z,

(1â€™) a Â· b âˆˆ Z,

(2) a + b = b + a,

(2â€™) a Â· (b + c) = a Â· b + a Â· c y (b + c) Â· a = b Â· a + c Â· a,

(3) a + (b + c) = ( a + b) + c,

(3â€™) a Â· 1 = a.

(4) a + 0 = 0 + a = a,
(5) el inverso aditivo de a es âˆ’ a
Inversos mÃ³dulo m (unidades) y divisores de cero. Sea a âˆˆ Zm , a es una unidad si tiene inverso, es decir, si existe b âˆˆ Zm tal que ba â‰¡ ab â‰¡ 1 (mod m). En este caso ponemos aâˆ’1 = b. Por
ejemplo, 2 Â· 3 â‰¡ 1 (mod 5), entonces el inverso de 2, mÃ³dulo 5, es 3 y viceversa.
Por otra parte, a 6= 0, es divisor de cero en Zm si existe b âˆˆ Zm , b 6= 0, tal que ab = 0. Por
ejemplo, 2 Â· 3 â‰¡ 0 (mod 6), entonces 2 y 3 son divisores de cero en Z6 .

Teorema 3.4
En Zm ,
a.) a es una unidad si y solo si mcd ( a, m) = 1;
b.) a es divisor de cero si y solo si 1 < mcd ( a, m) < m;
Prueba: a.) ab â‰¡ 1 (mod m) si y solo si existe k âˆˆ Z tal que ab + mk = 1, es decir, si y solo si
mcd ( a, m) = 1.
b.) Sea a > 1 y d = mcd ( a, m).
â€ =â‡’ â€ Como a es divisor de cero, sea b 6= 0, tal que ab = 0. Supongamos, por contradicciÃ³n,
que d = 1 o d = m. Si d = 1 âˆ§ m| ab =â‡’ m|b, pero esto no puede ser pues b 6â‰¡ 0(mod m). Si
d = m =â‡’ m| a pero esto no puede ser pues a 6â‰¡ 0(mod m).
â€ â‡= â€ Como 1 < d < m y d|m, existe k tal que dk = m y 1 < k < m. Entonces k 6= 0 y dk = 0.
Por tanto, si a = dk0 , ak = dkk0 = 0, es decir, a es divisor de cero.

Inversos y mÃ³dulo primo. Si p es primo, entonces mcd (i, p) = 1 para todo i = 1, 2, ..., p âˆ’ 1.
AsÃ­, en Z p todo elemento tiene inverso y no hay divisores de cero. Zm es un campo si y solo si

60

CONGRUENCIAS

Ejemplo 3.14 (Unidades y divisores de cero).
Sea m = 9. Si construimos una tabla de multiplicar para Z9 podemos detectar las
unidades y los divisores de cero (si hubiera). La otra manera es usar el teorema (3.4)
(Z9 , Â·) 1 2 3 4 5 6 7 8
1
1 2 3 4 5 6 7 8
2
4 de
6 multiplicar
8 1 3para
5 Z79
Tabla 3.2.2Tabla
3
3 6 0 3 6 0 3 6
4 a 41 82 33 74 25 66 17 58
mcd5( a, 9) 5 1 1 1 6 3 2 1 7 1 3 3 8 1 4 1
6
6 Aplicando
3 0 6el teorema
3 0 (3.4)
6 3
Tabla
3.3.
7
7 5 3 1 8 6 4 2
4 3 de
2 cero
1 son 3, 6 .
AsÃ­, las unidades de Z8 son 81, 2, 4, 85, 7,78 y 6los 5divisores

m es primo.
En el mundillo del Ã¡lgebra, si p es primo, se usa a Z p como el â€œrepresentanteâ€ de los campos
finitos con p elementos y se le denota F p .
Sistemas de residuos. Como ya dijimos, hay distintos conjuntos de representantes de Zm . Vamos a establecer un par de lemas que serÃ¡n de mucha utilidad la hora de establecer los teoremas
clÃ¡sicos en teorÃ­a de nÃºmeros.

Â¿CÃ³mo determinar si dado { a1 , a2 , ..., am }, se tiene Zm = { a1 , a2 , ..., am } ?.
Zm = { a1 , a2 , ..., am } si todos los m ai0 s estÃ¡n en clases distintas, es decir,

{ a1 , a2 , . . . , am } = { rem( a1 , m), rem( a2 , m), . . . , rem( am , m)} = {0, 1, . . . , m âˆ’ 1},
Para comprobaciones en la teorÃ­a usarÃ­amos la siguiente caracterizaciÃ³n: Zm = { a1 , a2 , ..., am } si
y sÃ³lo si ai 6â‰¡ a j (mod m) âˆ€i, j con i 6= j, 1 â‰¤ i, j â‰¤ m.

Lema 3.1
Sea mcd ( a, m) = 1, entonces Zm = {0, a, a Â· 2, . . . , a Â· (m âˆ’ 1)}
Prueba: Solo hay que probar que los m elementos de {0, a, a Â· 2, . . . , a Â· (m âˆ’ 1)} no se repiten
mÃ³dulo m.
Primero observemos que si i, j âˆˆ {0, 1, 2, ..., m âˆ’ 1} y si i 6= j , entonces j 6â‰¡ i (mod m) pues i y j
estarÃ­an en clases distintas.
Ahora, si a Â· i â‰¡ a Â· j (mod m) con i 6= j, 1 â‰¤ i, j â‰¤ m, entonces m| a( j âˆ’ i ) ; pero mcd ( a, m) = 1
entonces m|( j âˆ’ i ) pero esto es imposible pues j 6â‰¡ i (mod m) .

61

La aplicaciÃ³n prÃ¡ctica que vamos a encontrar frecuentemente es la que se establece en el siguiente
corolario,
Corolario 3.1 Si mcd ( a, m) = 1, entonces
a Â· 1 Â· a Â· 2 Â· Â· Â· a Â· (m âˆ’ 1) â‰¡ 1 Â· 2 Â· Â· Â· (m âˆ’ 1) (mod m)
Prueba: Ejercicio.

Ejemplo 3.15
mcd (4, 5) = 1, entonces 4 Â· 1 Â· 4 Â· 2 Â· 4 Â· 3 Â· 4 Â· 4 â‰¡ 1 Â· 2 Â· 3 Â· 4 (mod 5) o 6144 â‰¡ 24 (mod 5).

3.6

Congruencias lineales

Es fÃ¡cil resolver la ecuaciÃ³n x + a â‰¡ b (mod m), la solulciÃ³n es x â‰¡ b âˆ’ a (mod m.)
Consideremos la ecuaciÃ³n ax â‰¡ b (mod m) : Hay un k âˆˆ Z tal que b âˆ’ ax = mk o b = mk + ax.
Como ya vimos en la secciÃ³n sobre ecuaciones diofÃ¡nticas lineales, b = mk + ax tiene soluciÃ³n si
y sÃ³lo si mcd ( a, m)|b. Si esta es la situaciÃ³n, hay un k0 âˆˆ Z tal que b = k0 Â· mcd ( a, m) y entonces,
utilizando el algoritmo extendido de Euclides, determinamos s, t âˆˆ Z tal que mcd ( a, b) = sa +
tm =â‡’ b = k0 sa + k0 tm y una soluciÃ³n serÃ­a x = k0 s.
Ejemplo 3.16
Determinar una soluciÃ³n de 2x â‰¡ 5 (mod 7).
SoluciÃ³n: Como mcd (2, 7) = 1 y 1|5, la ecuaciÃ³n tiene soluciÃ³n. Como el mÃ³dulo es
pequeÃ±o, podemos encontrar una soluciÃ³n por ensayo y error: Sustituimos los valores
x = 0, 1, 2, ..., 6 y buscamos los valores de x que satisfacen la congruencia. En este caso
obtenemos la soluciÃ³n x = 6. Esta soluciÃ³n es Ãºnica mÃ³dulo 7.
Si el mÃ³dulo es muy grande, podemos encontrar una soluciÃ³n usando algoritmo extendido de Euclides: 1 = âˆ’3 Â· 2 + 1 Â· 7 =â‡’ 5 = âˆ’15 Â· 2 + 5 Â· 7. AsÃ­, x = âˆ’15 es una soluciÃ³n.
La reducciÃ³n mÃ³dulo 7 nos da x = 6.

Inversos mÃ³dulo m
Teorema 3.5
Si mcd ( a, m) = 1 entonces ax â‰¡ 1 (mod m) tiene soluciÃ³n Ãºnica x = aâˆ’1 mÃ³dulo m.
Prueba: Resolver la congruencia ax â‰¡ 1 (mod m) es equivalente a resolver la ecuaciÃ³n ax + my =
1. Como mcd ( a, m) = 1, existen s, t âˆˆ Z tal que sa + tm = 1, con lo que tenemos la soluciÃ³n

62

CONGRUENCIAS

x = s para la ecuaciÃ³n ax â‰¡ 1 (mod m).
La unicidad mÃ³dulo m significa que si as â‰¡ 1 (mod m) y as0 â‰¡ 1 (mod m), entonces s â‰¡
s0 (mod m). Para verificar que la soluciÃ³n es Ãºnica mÃ³dulo m, supongamos que as0 â‰¡ 1 (mod m),
luego, restando tenemos a(s âˆ’ s0 ) â‰¡ 0 (mod m) =â‡’ m| a(s âˆ’ s0 ) pero como mcd ( a, m) = 1 entonces m|(s âˆ’ s0 ) =â‡’ s â‰¡ s0 (mod m).

Si sa + tm = 1, en la prÃ¡ctica tomamos aâˆ’1 = rem(s, m) (el residuo de dividir s por m en el
teorema de la divisiÃ³n).

Ejemplo 3.17
Como mcd (27, 31) = 1 entonces 27 tiene inverso mÃ³dulo 31. Aplicando el algoritmo
extendido de Euclides obtenemos âˆ’8 Â· 27 + 7 Â· 31 = 1. AsÃ­ aâˆ’1 = âˆ’8. En la prÃ¡ctica nos
interesa la soluciÃ³n aâˆ’1 = rem(âˆ’8, 31) = 23 (pues âˆ’8 = âˆ’1 Â· 31 + 23 ).

SoluciÃ³n general. Podemos aplicar la teorÃ­a de ecuaciones diofÃ¡nticas lineales para obtener el
siguiente resultado,

Teorema 3.6
ax â‰¡ b (mod m) tiene soluciÃ³n si y sÃ³lo si d = mcd ( a, m)|b. Si x0 es una soluciÃ³n particular,
la soluciÃ³n general es x â‰¡ x0 (mod m/d), es decir, obtenemos las â€˜ d â€™ soluciones mÃ³dulo m,
m
x = x0 + t con 0 â‰¤ t < d
d

Prueba: Para la prueba vamos a usar los teoremas (2.11) y (2.13) de la secciÃ³n de ecuaciones
diofÃ¡nticas. Si ax â‰¡ b (mod m), entonces hay un k âˆˆ Z tal que ax âˆ’ mk = b. Esta ecuaciÃ³n
diofÃ¡ntica tiene soluciÃ³n si y solo si d = mcd ( a, m)|b. Si una soluciÃ³n particular es x = x0 , enm
tonces la soluciÃ³n general es x = x0 + t, con t âˆˆ Z (aquÃ­ solo interesa x ). Solo falta probar
d
que solo hay d soluciones distintas mÃ³dulo m.
m
m
Si x0 + t1 â‰¡ x0 + t2 (mod m), usando el hecho de que (m/d)|m, obtenemos que t1 â‰¡
d
d
m
m
t2 (mod d), es decir, x0 + t1 y x0 + t2 son soluciones distintas mÃ³dulo m si y solo si t1 y
d
d
t2 estÃ¡n en clases distintas de Zd . Esto nos deja solo las d posibilidades t = 0, 1, ..., d âˆ’ 1.

Corolario 3.2 Si p es primo y mcd ( a, p) = 1, la ecuaciÃ³n lineal ax â‰¡ b (mod m) tiene soluciÃ³n Ãºnica
x â‰¡ aâˆ’1 b (mod p).
Prueba: Ejercicio.

63

Ejemplo 3.18
a.) Resolver 2x â‰¡ 5 (mod 7).
SoluciÃ³n: como mcd (2, 7) = 1, la ecuaciÃ³n tiene soluciÃ³n Ãºnica mÃ³dulo 7. La soluciÃ³n es x â‰¡ 2âˆ’1 Â· 5 (mod 7); como 4 Â· 2 â‰¡ 1 (mod 7), x â‰¡ 4 Â· 5 â‰¡ 6 (mod 7). AsÃ­, la
soluciÃ³n es x = 6.
b.) Resolver 42x â‰¡ 50 (mod 76).
SoluciÃ³n: Usando el algoritmo extendido de Euclides obtenemos la soluciÃ³n particular
x = âˆ’225 â‰¡ 3 (mod 76).
Ahora, como mcd (42, 76) = 2, la soluciÃ³n general es
x â‰¡ 3 (mod 38),
es decir, x = 3 + 38 t. La ecuaciÃ³n tiene dos soluciones mÃ³dulo 76, a saber x = 3 y
x = 41.
c.) Resolver 12x â‰¡ 48 (mod 18).
SoluciÃ³n: Una soluciÃ³n particular es x = 1, ahora, como mcd (12, 18) = 6, la soluciÃ³n general es x â‰¡ 1 (mod 3), es decir, x = 1 + 3 t. La ecuaciÃ³n tiene seis soluciones
mÃ³dulo 18, a saber x = 1, 4, 7, 10, 13 y 16.
d.) La ecuaciÃ³n 2x â‰¡ 3 (mod 4) no tiene soluciÃ³n pues mcd (2, 4) = 2 - 3

3.7

Teorema Chino del resto

Un ejemplo concreto de un sistema de congruencias lineales se describe en el ejemplo que sigue,

Ejemplo 3.19

Calcule x tal que

ï£±
x â‰¡ 1 (mod 3),
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£²
x â‰¡ 2 (mod 5),

ï£´
ï£´
ï£´
ï£´
x â‰¡ 3 (mod 7).
ï£´
ï£´
ï£³

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

64

CONGRUENCIAS

SoluciÃ³n: Hay un nÃºmero infinito de soluciones para este sistema, por ejemplo x =
52, âˆ’53, 157, ... como se puede verificar rÃ¡pidamente. Una manera de resolver este sistema es despejar y sustituir x hasta que la Ãºltima congruencia sea usada,

x â‰¡ 1 (mod 3)

=â‡’ x = 1 + 3t1
=â‡’ 1 + 3t1 â‰¡ 2 (mod 5)
=â‡’ 3t1 â‰¡ 1 (mod 5)
=â‡’ t1 â‰¡ 2 (mod 5) pues 3 Â· 2 â‰¡ 1 (mod 5)
=â‡’ t1 = 2 + 5t2
=â‡’ x = 7 + 15t2
=â‡’ 7 + 15t2 â‰¡ 3 (mod 7)
=â‡’ 15t2 â‰¡ 3 (mod 7)
=â‡’ t2 â‰¡ 3 (mod 7) pues 15 Â· 1 â‰¡ 1 (mod 7)

Por tanto,
y

t2 = 3 + 7t
x = 7 + 15 Â· (3 + 7t) = 52 + 105t, t âˆˆ Z.

AsÃ­, x = 52 + 105t, t âˆˆ Z; es la soluciÃ³n general del sistema. AquÃ­ debemos notar que
105 = 3 Â· 5 Â· 7, es decir, la soluciÃ³n es Ãºnica mÃ³dulo 3 Â· 5 Â· 7.

Teorema 3.7 (Teorema Chino del resto).
Consideremos el sistema lineal de congruencias
x â‰¡ a1 (mod m1 )
x â‰¡ a2 (mod m2 )
...
x â‰¡ ak (mod mk )
con mcd (mi , m j ) = 1, i 6= j; entonces, si M = m1 Â· m2 Â· Â· Â· mk , Mi = M/mi y yi â‰¡ Miâˆ’1 (mod mi ),
el sistema tiene soluciÃ³n Ãºnica x = a1 M1 y1 + a2 M2 y2 + Â· Â· Â· + ak Mk yk , mÃ³dulo M.

65

Prueba: La prueba3 es en dos partes, primero se muestra una soluciÃ³n de manera explÃ­cita y
luego se prueba que es Ãºnica.
Sean M = m1 Â· m2 Â· Â· Â· mk y Mi = M/mi , 1 â‰¤ i â‰¤ k. Como los mÃ³dulos son primos relativos dos a
dos, mcd ( Mi , mi ) = 1 para cada i. TambiÃ©n, Mi â‰¡ 0 (mod m j ) j 6= i.
Como mcd ( Mi , mi ) = 1, entonces Mi yi â‰¡ 1 (mod mi ) tiene soluciÃ³n Ãºnica yi â‰¡ Miâˆ’1 (mod mi ).
Sea x = a1 M1 y1 + a2 M2 y2 + Â· Â· Â· + ak Mk yk . Vamos a mostrar que x es soluciÃ³n del sistema de
congruencias.

k

x

=

âˆ‘ a i Mi y i

+ a j Mj y j

i =1
i6= j
k

â‰¡

âˆ‘ ai Â· 0 Â· yi

+ a j Â· 1 (mod m j )

i =1
i6= j

â‰¡ 0 + a j (mod m j )
â‰¡ a j (mod m j ), 1 â‰¤ j â‰¤ k

Por tanto, x satisface todas las congruencias del sistema, es decir, es una soluciÃ³n del sistema.
Para probar la unicidad mÃ³dulo M supongamos que x1 y x2 son soluciones del sistema, vamos
a demostrar que x1 â‰¡ x2 (mod M).
Puesto que x1 â‰¡ a j (mod m j ) y x2 â‰¡ a j (mod m j ) para 1 â‰¤ j â‰¤ k, restando x1 âˆ’ x2 â‰¡ 0 (mod m j ),
luego m j |( x1 âˆ’ x2 ) para cada j.
Entonces mcm (m1 Â· m2 Â· Â· Â· mk )|( x1 âˆ’ x2 ), es decir, M|( x1 âˆ’ x2 ) pues tambiÃ©n M = mcm (m1 Â·
m2 Â· Â· Â· mk ). Por tanto, x1 âˆ’ x2 â‰¡ 0 (mod M ), es decir x1 â‰¡ x2 (mod M ).

Ejemplo 3.20

Resolver el sistema

ï£±
ï£² x â‰¡ 1 (mod 3),
ï£³

x â‰¡ 2 (mod 5),
x â‰¡ 3 (mod 7).

usando el mÃ©todo del teorema anterior.

SoluciÃ³n: M = 3 Â· 5 Â· 7 = 105, M1 = 35, M2 = 21, M3 = 15. Luego,

3

Para seguir la prueba debemos recordar que si m1 , m2 , ..., mk son primos relativos dos a dos, entonces
mcm (m1 , m2 , ..., mk ) = m1 Â· m2 Â· Â· Â· mk y si m1 , m2 , ..., mk , a âˆˆ Z+ y mi | a, i = 1, 2, ..., k; entonces mcm (m1 , m2 , ..., mk )| a .

66

CONGRUENCIAS

y1 â‰¡ M1âˆ’1 (mod 3) =â‡’ y1 â‰¡ 2 (mod 3)
y2 â‰¡ M2âˆ’1 (mod 5) =â‡’ y2 â‰¡ 1 (mod 5)
y3 â‰¡ M3âˆ’1 (mod 7) =â‡’ y3 â‰¡ 1 (mod 7)
AsÃ­,
x

= a1 M1 y1 + a2 M2 y2 + a3 M3 y3
= 1 Â· 35 Â· 2 + 2 Â· 21 Â· 1 + 3 Â· 15 Â· 1
= 157 â‰¡ 52 (mod M)

Podemos decir, la soluciÃ³n Ãºnica es x â‰¡ 52 (mod 105).

Sistemas con mÃ³dulos no coprimos dos a dos. Si los mÃ³dulo no son coprimos dos a dos, el
sistema podrÃ­a tener soluciÃ³n en las condiciones del siguiente teorema,

Teorema 3.8
El sistema
x â‰¡ a1 (mod m1 )
x â‰¡ a2 (mod m2 )
...
x â‰¡ ak (mod mk )
tiene soluciÃ³n si y solo si mcd (mi , m j )|( ai âˆ’ a j ), 1 â‰¤ i, j â‰¤ k. Cuando hay soluciÃ³n, es Ãºnica
mÃ³dulo mcm (m1 Â· m2 Â· Â· Â· mk ).

Si hay soluciÃ³n, se puede obtener despejando y sustituyendo como en el ejemplo (3.19).

3.8

Congruencias de Orden Superior

Consideremos de manera general el problema de resolver la congruencia P( x ) â‰¡ 0 (mod m) con
P( x ) un polinomio con coeficientes enteros. La manera directa (y no muy eficiente) de resolver
este problema es probar con x = 0, 1, ..., m âˆ’ 1.
Ejemplo 3.21
Resolver x2 + x âˆ’ 2 â‰¡ 0 (mod 10).
SoluciÃ³n: Probamos sustituyendo x = 0, 1, ..., 9 y encontramos las soluciones x = 1, 3, 6, 8.
Si m no es la potencia de un primo, el problema se puede reducir a resolver un sistema con
mÃ³dulos menores que m, usando el teorema chino del resto.

EJERCICIOS

67

Teorema 3.9
Sea m = m1 Â· m2 Â· Â· Â· mk con m1 , m2 , Â· Â· Â· , mk primos relativos dos a dos. x = a es una soluciÃ³n de
P( x ) â‰¡ 0 (mod m) si y solo si a es soluciÃ³n del sistema
P( x ) â‰¡ 0 (mod m1 )
P( x ) â‰¡ 0 (mod m2 )
...
P( x ) â‰¡ 0 (mod mk )
Prueba: Si P( a) â‰¡ 0 (mod M ), entonces P( a) â‰¡ 0 (mod mi ), i = 1, 2, ..., k.
Ahora supongamos que x = a es soluciÃ³n del sistema, es decir,
P( a) â‰¡ 0 (mod m1 )
P( a) â‰¡ 0 (mod m2 )
...
P( a) â‰¡ 0 (mod mk )
El teorema chino del resto nos dice que P( a) â‰¡ 0 (mod m1 Â· m2 Â· Â· Â· mk ), es decir, x = a es soluciÃ³n
de P( x ) â‰¡ 0 (mod m).

Ejemplo 3.22
Resolver x2 + x âˆ’ 2 â‰¡ 0 (mod 10).
SoluciÃ³n: Como 10 = 2 Â· 5, podemos resolver el sistema
P( x ) â‰¡ 0 (mod 2)
P( x ) â‰¡ 0 (mod 5)
La ganancia serÃ­a resolver congruencias con un mÃ³dulo mÃ¡s pequeÃ±o. Por ensayo y error,
P( x ) â‰¡ 0 (mod 2) tiene soluciones x = 0, 1
P( x ) â‰¡ 0 (mod 5) tiene soluciones x = 1, 3
La soluciÃ³n del problema requiere resolver los cuatro sistemas


x â‰¡ 0 (mod 2)
,
x â‰¡ 1 (mod 5)



x â‰¡ 0 (mod 2)
,
x â‰¡ 3 (mod 5)



x â‰¡ 1 (mod 2)
,
x â‰¡ 1 (mod 5)



x â‰¡ 1 (mod 2)
.
x â‰¡ 3 (mod 5)

Las soluciÃ³n de cada uno de los cuatro sistemas son x = 6, 8, 1, 3, respectivamente. Por
tanto, la soluciÃ³n de la congruencia x2 + x âˆ’ 2 â‰¡ 0 (mod 10) es x = 1, 3, 6, 8.

EJERCICIOS
3.1 Sea r el residuo de dividir b por m en el Teorema de la DivisiÃ³n. DÃ© un contra-ejemplo
que evidencie que â€œb â‰¡ r (mod m) =â‡’
6
b = r mod mâ€.Â¿CuÃ¡l es el requisito para la equivalencia?
3.2

Calcule el inverso de a = 7 mÃ³dulo m = 211.

68

CONGRUENCIAS

3.3 Si llamamos a los dÃ­as de la semana por un nÃºmero 0 â‰¤ d < 7 (0 = domingo, 6 = sÃ¡bado),
describa un algoritmo (usando congruencias) que, sabiendo que hoy es el dÃ­a d, nos diga quÃ©
dÃ­a serÃ¡ en n dÃ­as contando el dÃ­a de hoy? Por ejemplo, si hoy es domingo (0), en 7 dÃ­as es
domingo. Por ejemplo, si hoy es lunes(d = 1), Â¿quÃ© dÃ­a es en 374 dÃ­as?.
3.4 Probar que todo entero es congruente con exactamente uno de los residuos {0, 1, 2, ..., m âˆ’
1} mÃ³dulo m.
3.5 Muestre que todo primo p > 3 es congruente con 1 o con 5 mÃ³dulo 6. Ayuda: Use el
ejercicio anterior.
3.6 Sea S = {2, 3, 5, 7, 11, 13, 17, ...} = {2, 3} âˆª {6k Â± 1 : k = 1, 2, ...}. Muestre que S contiene a
todos los primos.
Ayuda: 2, 3 âˆˆ S. Solo falta verificar que si p es primo > 3, entonces p âˆˆ S.
3.7 Muestre que si p es primo y p - a , la ecuaciÃ³n ax â‰¡ b (mod p) tiene soluciÃ³n Ãºnica, mÃ³dulo
p, x â‰¡ a pâˆ’2 b (mod p).
3.8

Â¿ Z7 = {0, 1, âˆ’2, 4, âˆ’8, 16, âˆ’32} ?

3.9

Mostrar que si a âˆˆ Z, Zm = { a, a + 1, ... , a + m âˆ’ 1}.

3.11

mâˆ’1
mâˆ’1
, . . . , âˆ’1, 0, 1, . . .
}
2
2
Muestre que si mcd (b, m) > 1, entonces Zm 6= {0, b Â· 1, b Â· 2, . . . , b Â· (m âˆ’ 1)}

3.12

Sea p primo, muestre que si mcd ( a, p) = 1, entonces mcd ( aâˆ’1 , p) = 1.

3.13

Muestre que si k â‰¥ 5 entonces k! â‰¡ 0 (mod 15)

3.14

Muestre que 3! + 4! + 5! + Â· Â· Â· + 100! es divisible por 15 .

3.10

Mostrar que si m es impar, Zm = {âˆ’

3.15 Muestre que N = 11 Â· 14n + 1 es compuesto.
Ayuda: Si n es par, iniciar con 14 â‰¡ âˆ’1 (mod 3) y recalcular N mÃ³dulo 3. Si n es impar, iniciar
con 14 â‰¡ âˆ’1 (mod 5) y recalcular N mÃ³dulo 5.
3.16 Muestre que si P( x ) es un polinomio con coeficientes enteros y si a â‰¡ b (mod m) entonces
P( a) â‰¡ P(b) (mod m).
3.17

DÃ© un ejemplo que muestre que ( a â‰¡ b (mod p) y si p|m) 6=â‡’ a â‰¡ b mod (m)

3.18 Sea p un divisor no trivial de m. Muestre que si xi â‰¡ x j (mod p) âˆ§ xi 6â‰¡ x j mod (m),
entonces mcd ( xi âˆ’ x j , m) es un divisor no trivial de m.
3.19 Muestre que si p â‰¡ 1 (mod 4) y p â‰¡ 1 (mod 3), entonces p â‰¡ 1 (mod 12). Ayuda: Corolario
(2.7).
3.20 Muestre que si p â‰¡ 3 (mod 4) y p â‰¡ 2 (mod 3), entonces p â‰¡ 7 (mod 12). Ayuda: Corolario
(2.7).
3.21

Muestre que 43q â‰¡ 1 (mod 9), q âˆˆ N.

3.22 Muestre que para cada n âˆˆ N, 4n â‰¡ 1 (mod 9) o 4n â‰¡ 4 (mod 9) o 4n â‰¡ 7 (mod 9)
Ayuda: Calcule primero 4t mod 9 para t = 0, 1, 2, 3. Luego use el algoritmo de la divisiÃ³n: 4n =
43q+r .
3.23

Muestre que 6 Â· 4n â‰¡ 6 (mod 9) para todo n â‰¥ 0.

3.24

Muestre que ( a1 + a2 )2 â‰¡ ( a21 + a22 ) (mod 2)

3.25

Muestre que ( a1 + a2 + ... + an )2 â‰¡ ( a21 + a22 + ... + a2n ) (mod 2)

EJERCICIOS

3.26

69

Muestre que si 0 â‰¤ r < m y a â‰¡ r (mod m), entonces a mod m = r

3.27 Sean m1 , m2 , ..., mk âˆˆ Z+ con c = mcm (m1 m2 Â· Â· Â· mk ). Muestre que si a â‰¡ b (mod mi ), i =
1, 2, ..., k; entonces a â‰¡ b (mod c).
3.28

Verifique que 112 â‰¡ 1 (mod 5) y 11 â‰¡ 1 (mod 5) pero 11 6â‰¡ âˆ’1 mod 5

3.29 Muestre que si p es primo y si mcd ( a, p) = 1, entonces si a2 â‰¡ 1 (mod p) =â‡’ a â‰¡
1 (mod p) o a â‰¡ âˆ’1 (mod p). Indique ademÃ¡s, Â¿porquÃ© se requiere la hipÃ³tesis mcd ( a, p) = 1, ?
3.30

Sea p primo impar y i, j âˆˆ {âˆ’

mod p)

pâˆ’1
pâˆ’1
, . . . , âˆ’1, 0 1, . . .
} con i 6= j. Muestre que i2 6â‰¡ j2 (
2
2

3.31

Sea p primo y i, j âˆˆ {0, 1, 2, ..., p âˆ’ 1} con i 6= j. Muestre que i2 6â‰¡ j2 ( mod p)

3.32

Muestre que a2 â‰¡ a (mod 2) para todo a âˆˆ Z

3.33

Muestre que si ra â‰¡ rb (mod rm) entonces a â‰¡ b (mod m).

3.34

Sean a, b enteros positivos < m. Muestre que a 6â‰¡ b( mod m)

3.35

DÃ© un ejemplo en el que mcd ( a, m) = 1 y mcd (b, m) = 1 y que a â‰¡ b (mod m).

3.36 Calcule el mÃ¡s pequeÃ±o entero positivo n que deja residuo 3 al dividir por 7, residuo 4 al
dividir por 9 y residuo 8 cuando se divide por 11.
3.37

Resuelva el sistema
x â‰¡ 21 (mod 3),
x â‰¡ 32 (mod 5),
x â‰¡ 3 (mod 7),
x â‰¡ 9 (mod 11),
x â‰¡ 2 (mod 2),
x â‰¡ 1 (mod 97).

3.38 Un niÃ±o tiene una bolsa con bolinchas. Si las agrupa en puÃ±os de 7, le sobran 5, Si las
agrupa en puÃ±os de 11, le sobran 6, Si las agrupa en puÃ±os de 13, le sobran 8. Determine el
mÃ­nimo nÃºmero de bolinchas que podrÃ­a tener el niÃ±o.

x â‰¡ 2 (mod 4)
3.39 Muestre que el sistema
no tiene soluciÃ³n. Ayuda: Use el mÃ©todo de
x â‰¡ 3 (mod 6)
sustituciÃ³n y Bezout.
3.40

Calcule el mÃ¡s pequeÃ±o entero positivo n tal que 2|n, 3|n + 1, 5|n + 2, 7|n + 3, y 11|n + 4.

3.41

Resuelva el sistema
x â‰¡ 4 (mod 6),
x â‰¡ 2 (mod 8),
x â‰¡ 1 (mod 9).

3.42

Resolver x5 âˆ’ 3x4 + x âˆ’ 2 â‰¡ 0 (mod 165).

70

CONGRUENCIAS

VersiÃ³n actualizada de este libro: https://tecdigital.tec.ac.cr/revistamatematica/Libros/

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

235711
131719
232931
235711

4
4.1

POTENCIAS mod m

Orden de un elemento mÃ³dulo m.

Sea mcd ( a, p) = 1, entonces p - as si s â‰¥ 1. Como a, a2 , a3 , ..., a p son p elementos no nulos del
conjunto de p âˆ’ 1 residuos {1, 2, ..., p âˆ’ 1}, entonces al menos dos se tienen que repetir mÃ³dulo
p: Existen s 6= t tal que as â‰¡ at (mod p).
La parte importante aquÃ­ es ver que si s = t + r, entonces, como mcd ( at , p) = 1, at tiene inverso
mÃ³dulo p, asÃ­ multiplicando este inverso a ambos lados se tienen
as â‰¡ at (mod p) =â‡’ at+r â‰¡ at (mod p) =â‡’ ar â‰¡ 1 (mod p).
Ejemplo 4.1
En Z7 , {2, 22 , 23 , 24 , 25 , 26 , 27 } = {2, 4, 1, 2, 4, 1, 2}. En particular, 22 â‰¡ 25 (mod 7), entonces
23 â‰¡ 1 (mod 7)

Teorema 4.1
Si mcd ( a, m) = 1 entonces at â‰¡ 1 (mod m) para algÃºn 1 â‰¤ t < m.

Prueba: Se trata de refinar un poco el argumento que se dio mÃ¡s arriba, asÃ­ que se deja como
ejercicio.

DefiniciÃ³n 4.1 (Orden de un nÃºmero mÃ³dulo m ).
Sea m â‰¥ 2. Si mcd ( a, m) = 1, el orden de â€œaâ€ mÃ³dulo m , denotado Ordm ( a), es el mÃ¡s pequeÃ±o
entero positivo t tal que at â‰¡ 1 (mod m)

Observe que si Ordm ( a) = t, entonces at â‰¡ 1 (mod m) pero as 6â‰¡ 1(mod m) si 0 < s < t
71

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

72

POTENCIAS mod m

Ejemplo 4.2
El orden de 2 mÃ³dulo 7 es t = 3 pues 23 â‰¡ 1 (mod 7) pero 22 6â‰¡ 1(mod 7) y 21 6â‰¡
1(mod 7). Observemos que 26 â‰¡ 1 (mod 7) y 3|6.

Teorema 4.2
Si Ordm ( a) = t y as â‰¡ 1 (mod m), entonces t|s.

Prueba: Si s = kt + r con 0 â‰¤ r < t, se tiene que as â‰¡ akt+r (mod m) =â‡’ ar â‰¡ 1 (mod m). Pero
como 0 â‰¤ r < t y t es el orden de a, la Ãºnica posiblidad que queda es ar â‰¡ 1 (mod m) solo si
r = 0.

Si conocemos el orden de un nÃºmero mÃ³dulo m, podrÃ­amos ganar algo en el cÃ¡lculo del orden
de otros elementos de Zm : Si a tiene orden t mÃ³dulo m y queremos calcular el orden de ad ,
ya se sabe que adt â‰¡ 1 (mod m) pero el orden de ad es â‰¤ dt, en realidad tenemos,

Teorema 4.3
Si Ordm ( a) = t, entonces el orden de ad es q =

t
si d > 0
mcd (d, t)

Prueba: amcm(d,t) â‰¡ 1 (mod m) pues t| mcm (d, t). Tenemos,

( ad )

Como mcm (d, t) =

mcm(d,t)
d

â‰¡ 1 (mod m)

dt
mcm (d, t)
t
=â‡’
=
, entonces
mcd (d, t)
d
mcd (d, t)

t

( ad ) mcd(d,t) â‰¡ 1 (mod m)
t
: Si ( ad )s = ads â‰¡ 1 (mod m) entonces t|ds. AsÃ­, ds
mcd (d, t)
es mÃºltiplo de t y es mÃºltiplo de d, por tanto,
Falta probar que el orden de ad es

ds â‰¥ mcm (d, t) =â‡’ s â‰¥

mcm(d, t )

d

=

t
.
mcd (d, t)

73

Ejemplo 4.3
El orden de 2 mÃ³dulo 7 es t = 3, entonces el orden de 4 = 22 es

3
= 3, i.e.
mcd (2, 3)

43 â‰¡ 1 (mod 7.)
El orden de 3 mÃ³dulo 163 es 162, entonces el orden de 326 es

4.2

162
= 81.
mcd (26, 162)

El Teorema â€œpequeÃ±oâ€ de Fermat.

Para establecer el teorema â€œpequeÃ±oâ€ de Fermat4 , observemos que

( a Â· 1) ( a Â· 2) Â· Â· Â· ( a Â· ( p âˆ’ 1)) = a pâˆ’1 (1 Â· 2 Â· Â· Â· ( p âˆ’ 1))
Pero podemos probar que si mcd( a, p) = 1, entonces el conjunto { a Â· 1, a Â· 2, Â· Â· Â· , a Â· ( p âˆ’ 1)} es
una permutaciÃ³n mÃ³dulo p, del conjunto {1, 2, ..., p âˆ’ 1}. Luego, si mcd ( a, p) = 1, cancelando
tendrÃ­amos a pâˆ’1 â‰¡ 1 (mod p.)

Ejemplo 4.4
Sea a = 270 y p = 7.
270 Â· 1 â‰¡ 4 (mod 7)
270 Â· 3 â‰¡ 5 (mod 7)
270 Â· 5 â‰¡ 6 (mod 7)

270 Â· 2 â‰¡ 1 (mod 7)
270 Â· 4 â‰¡ 2 (mod 7)
270 Â· 6 â‰¡ 3 (mod 7)

AsÃ­,
2706 (1 Â· 2 Â· 3 Â· 4 Â· 5 Â· 6)

â‰¡ (270 Â· 1)(270 Â· 2)(270 Â· 3)(270 Â· 4)(270 Â· 5)(270 Â· 6) (mod 7)
â‰¡

(4 Â· 5 Â· 6 Â· 1 Â· 2 Â· 3)(mod 7)

entonces, 2706 (1 Â· 2 Â· Â· Â· 6) â‰¡ (1 Â· 2 Â· Â· Â· 6) (mod 7) =â‡’ 2706 â‰¡ 1 (mod 7)

Antes de enunciar el teorema, establecemos el lema
4

P.

El 18 de octubre de 1640, Fermat escribiÃ³ una carta a Bernhard Frenicle de Bessy (1605-1675), un funcionario de
la Casa de la Moneda francesa, excelente alumno en teorÃ­a de los nÃºmeros.
En su carta, Fermat comunica el resultado siguiente: Si p es primo y p - a entonces p| a pâˆ’1 âˆ’ 1 . Fermat no presentÃ³
una prueba de este resultado, pero una nota adjunta prometÃ­a enviar una demostraciÃ³n, siempre que no resultara
demasiado extensa. Sin embargo, la primera prueba conocida la dio Euler un siglo despuÃ©s. Este resultado es
conocido como el â€œpequeÃ±oâ€ teorema de Fermat para diferenciarlo del â€œÃºltimo teorema de Fermatâ€ (1637): La
Fermat (1601-1665)
ecuaciÃ³n x n + yn = zn no tiene soluciones enteras positivas si n > 2 (demostrado por A.Wiles en 1995.)

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

74

POTENCIAS mod m

Lema 4.1
Sea p primo y mcd ( a, p) = 1, entonces
a Â· 1 Â· a Â· 2 Â· Â· Â· a Â· ( p âˆ’ 1) â‰¡ 1 Â· 2 Â· Â· Â· ( p âˆ’ 1) (mod p)

Prueba: AplicaciÃ³n directa del lema (3.1) y el corolario (3.1)

Teorema 4.4 (Teorema â€œpequeÃ±oâ€ de Fermat)
Sea p primo y a âˆˆ Z.

â€¢ Si mcd ( a, p) = 1 entonces, a pâˆ’1 â‰¡ 1 (mod p)
â€¢ Para cualquier a âˆˆ Z+ se tiene a p â‰¡ a (mod p.)

Prueba: Usando lema anterior,

a pâˆ’1 (1 Â· 2 Â· Â· Â· ( p âˆ’ 1))

â‰¡ ( a Â· 1)( a Â· 2) Â· Â· Â· ( a Â· ( p âˆ’ 1)) (mod p)
â‰¡ 1 Â· 2 Â· Â· Â· ( p âˆ’ 1) (mod p)

Entonces a pâˆ’1 (1 Â· 2 Â· Â· Â· ( p âˆ’ 1)) â‰¡ 1 Â· 2 Â· Â· Â· ( p âˆ’ 1) (mod p) =â‡’ a pâˆ’1 â‰¡ 1 (mod p) pues se sabe que
mcd (1 Â· 2 Â· Â· Â· ( p âˆ’ 1), p) = 1.
Para probar la segunda afirmaciÃ³n solo hay que observar que si p| a entonces a â‰¡ 0 (mod p) por
tanto a p â‰¡ a (mod p). Si a y p son primos realtivos se obtiene el resultado de manera inmediata.

Ejemplo 4.5
Calcule manualmente el resto de dividir 241937 por 17.
SoluciÃ³n: Por el teorema de Fermat, como mcd (24, 17) = 1, 2416 â‰¡ 1 (mod 17). Luego,
como 1937 = 16 Â· 121 + 1, entonces
241937 = 2416Â·121+1 = 2416Â·121 241 â‰¡ 24 (mod 17), es decir, 241937 â‰¡ 7 (mod 17).

75

Ejemplo 4.6
La congruencia x6 + x4 + x âˆ’ 3 â‰¡ 0 (mod 5) tiene las mismas soluciones que la congruencia x2 + x âˆ’ 3 â‰¡ 0 (mod 5) pues, por el teorema de Fermat, x4 â‰¡ 1 (mod 5) y
x6 = x4 Â· x2 â‰¡ x2 (mod 5)

Teorema 4.5
Sea p primo y a cualquier entero tal que p - a. Entonces, a pâˆ’2 es el inverso de a mÃ³dulo p.
Prueba: Por el teorema de Fermat, a pâˆ’1 â‰¡ 1 (mod p), entonces a Â· a pâˆ’2 â‰¡ 1 (mod p), es decir,
a Â· a pâˆ’2 = 1.

Corolario 4.1 Sea p > 1. Si existe a âˆˆ Z y mcd ( a, p) = 1, tal que a p 6â‰¡ a (mod p), entonces p es
compuesto.
Prueba: Ejercicio.

El teorema de Fermat no se puede usar, en principio como una prueba de primalidad pues
solo nos da una condiciÃ³n necesaria pero no suficiente. En efecto, hay nÃºmeros compuestos que
pasan la â€œpruebaâ€ del teorema de Fermat para alguna base a.
Ejemplo 4.7
a.) 341 = 11 Â· 31 es compuesto, mcd (341, 2) = 1 y 2340 â‰¡ 1 (mod 341), es decir, 341
pasa la â€œprueba de Fermatâ€ en base 2 pero no es primo.
b.) 4 no es primo pues 24 6â‰¡ 2 (mod 4).

4.3

Teorema de Euler

El teorema de Euler es uno de los grandes hitos en la desarrollo de la teorÃ­a de nÃºmeros. Fue
probado por Euler en 1760. Este teorema extiende el teorema â€œpequeÃ±oâ€ de Fermat a un mÃ³dulo
arbitrario. Antes de enunciarlo y probarlo, necesitamos algunos detalles tÃ©cnicos.

DefiniciÃ³n 4.2
Para cada n â‰¥ 1, denotamos con Ï•(n) la cantidad de enteros positivos menores que n y coprimos con n. A Ï• se le llama funciÃ³n â€œphiâ€ de Euler.
IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

76

POTENCIAS mod m

Euler parece que no usaba una notaciÃ³n funcional para esta funciÃ³n; Ã©l usÃ³ en algÃºn momento
la notaciÃ³n â€œ Ï€n â€. Gauss introdujo la notaciÃ³n â€œ Ï•(n) â€ aunque tambiÃ©n se usa â€œ Ï†(n) â€. Sylverter
introdujo la notaciÃ³n â€œTotient(n)â€ que a veces aparece en la literatura actual.
Ejemplo 4.8
Ï•(24) = 8 pues 1, 5, 7, 11, 13, 17, 19 y 23 son los coprimos con 24 inferiores a 24.

Recordemos que a âˆˆ Zm tiene inverso si mcd ( a, m) = 1. Luego, Ï•(m) calcula la cantidad de
unidades en Zm . AsÃ­, si p es primo, entonces Ï•( p) = p âˆ’ 1.

Ejemplo 4.9
Sea m = 9, de acuerdo con la tabla, Ï•(9) = 6.
a
mcd ( a, 9)

1
1

2
1

3
3

4
1

5
1

6
3

7
1

8
1

Tabla 4.1. Unidades de Z9 : Ï•(9) = 6.

Teorema 4.6
p es primo si y solo si Ï•( p) = p âˆ’ 1
Prueba: Si p es primo, los enteros 1, 2, ..., p âˆ’ 1 son primos relativos con p y menores que p,
entonces Ï•( p) = p âˆ’ 1.
Hay exactamente p âˆ’ 1 enteros positivos inferiores a p. Como Ï•( p) = p âˆ’ 1, ninguno de estos
p âˆ’ 1 enteros divide a p, es decir, p es primo.

Corolario 4.2 Sea m es compuesto, Ï•(m) < m âˆ’ 1.
Prueba: Ejercicio.

Teorema 4.7
Sea p primo y Î± > 1. Ï•( pÎ± ) = pÎ± âˆ’ pÎ±âˆ’1 = pÎ±âˆ’1 ( p âˆ’ 1)
Prueba: Observemos que el conjunto {1, 2, ..., pÎ± } tiene pÎ± elementos. Por ejemplo, el conjunto
{1, 2, 3, ..., 52 } tiene 52 = 25 elementos.

77

Como p es primo, los nÃºmeros que dividen a pÎ± e inferiores a Ã©l (excepto 1) son los pÎ±âˆ’1
nÃºmeros
p, 2p, . . . , pÎ±âˆ’1 p.
Entonces, en el conjunto {1, 2, . . . , pÎ± } hay pÎ± âˆ’ pÎ±âˆ’1 elementos coprimos con pÎ± .

Ejemplo 4.10
Ï•(9) = Ï•(32 ) = 3 Â· 2 = 6 y Ï•(4) = Ï•(22 ) = 2 Â· 1 = 1

Si Ï• fuera multiplicativa, es decir, si Ï•(nm) = Ï•(n) Ï•(m) cuando mcd (m, n) = 1, entonces
Ï•(36) = Ï•(22 Â· 32 ) = Ï•(22 ) Ï•(32 ) = 2 Â· 6 = 12. Y efectivamente, Ï• es multiplicativa. Para tener una
guÃ­a para la demostraciÃ³n de este hecho, necesitamos un lema previo y un ejemplo numÃ©rico.

Lema 4.2
Sean mcd (n, m) = 1 y r un entero, entonces Zm = {r, n + r, 2n + r, ..., (m âˆ’ 1)n + r }

Prueba: Solo necesitamos probar que los m elementos de A = {r, n + r, 2n + r, ..., (m âˆ’ 1)n + r }
no se repiten mÃ³dulo m. En efecto, si
jn + r â‰¡ in + r (mod m), i 6= j, 0 â‰¤ i, j â‰¤ m âˆ’ 1;
entonces, como mcd (n, m) = 1, se obtiene j â‰¡ i (mod m), pero esto no puede pasar i y j estÃ¡n
en clases distintas mÃ³dulo m.

Ejemplo 4.11
Sea n = 4 y m = 9. mcd (4, 9) = 1. Para establecer una guÃ­a para la demostraciÃ³n de que
Ï• es multiplicativa, hacemos un arreglo con los nÃºmeros 1, 2, ..., 36,
1
ï£¯ 2
ï£¯
ï£° 3
4
ï£®

5
6
7
8

9
10
11
12

13
14
15
16

17
18
19
20

21
22
23
24

25
26
27
28

29
30
31
32

ï£¹
33
34 ï£º
ï£º
35 ï£»
36

La idea es eliminar nÃºmeros hasta que nos quede un arreglo rectangular Ï•(n) Ã— Ï•(m).
La fila i es i n + i 2n + i ... (m âˆ’ 1)n + i. Como 2 no es primo relativo con n = 4,
entonces 2 ni la fila 2 n + 2 2n + 2 ... (m âˆ’ 1)n + 2 es prima relativa con n = 4,
asÃ­ que podemos quitar esta fila y, con el mismo argumento, podemos quitar la fila 4.

78

POTENCIAS mod m

1 5
ï£¯  
ï£¯
ï£° 3 7
 
ï£®

9

11


13

15


17 21
 
19 23
 

25 29
 
27 31
 

ï£¹
33
 ï£º
ï£º
35 ï£»


Las filas que quedan son las filas que inician con primos relativos de n = 4, es decir
quedan Ï•(n) = 2 filas.
Ahora quitamos, en cada fila, los nÃºmeros que no son primos relativos con m = 9, resulta
que los elementos que se deben quitar son Ï•(m) = 3 elementos:
1 5
ï£¯  
ï£¯
ï£° 3 7
 
ï£®



11


13 17
 
 19
 



23


25




ï£¹
29 
  ï£º
ï£º
31  ï£»
 



âˆ’â†’

1
3

5
7

13
11

17
19

25
23

29
31



En cada fila quedan Ï•(m) elementos, pues si hacemos reducciÃ³n mÃ³dulo m, por el lema
anterior, la fila {i, n + i 2n + i ... (m âˆ’ 1)n + i } se convierte en {0, 2, ..., m âˆ’ 1}, y en este
conjunto solo hay Ï•(m) elementos primos relativos con m. Finalmente el arreglo queda
Ï•(n) Ï•(m). Recordemos que si mcd (i, n) = 1 y mcd (i, m) = 1, entonces mcd (i, mn) = 1.
AsÃ­, el arreglo tiene todos los primos relativos con mn e inferiores a mn, es decir Ï•(nm).

Teorema 4.8
Ï• es multiplicativa, i.e., si mcd (m, n) = 1 =â‡’ Ï•(nm) = Ï•(n) Ï•(m)
Prueba: Consideremos el arreglo
ï£®
1
ï£¯ 2
ï£¯
ï£¯ Â·Â·Â·
ï£¯
ï£¯
ï£¯ i
ï£¯
ï£¯ Â·Â·Â·
ï£¯
ï£° mâˆ’1
m

m+1
m+2

2m + 1
2m + 2

m+i

2m + i

2m

3m

ï£¹
( n âˆ’ 1) m + 1
( n âˆ’ 1) m + 2 ï£º
ï£º
ï£º
ï£º
ï£º
. . . ( n âˆ’ 1) m + i ï£º
ï£º
ï£º
ï£º
ï£»
. . . mn

...
...

Si mcd (i, n) 6= 1, entonces los elementos de la fila i no son primos relativos con n. Si quitamos
estas filas, quedan Ï•(n) filas
rj

n + rj

2n + r + j

...

(m âˆ’ 1)n + r j , j = 1, ..., Ï•(n)

con mcd (r j , n) = 1. Ahora, como Zm = {r j , n + r j , 2n + r + j, ..., (m âˆ’ 1)n + r j }, entonces en
cada fila de estas solo hay Ï•(m) nÃºmeros primos relativos con m. Finalmente nos queda un
arreglo de Ï•(n) Ã— Ï•(m) con nÃºmeros ambos primos relativos con n y m y por tanto, primos
relativos con nm. Como todos son inferiores a nm, Ï•(nm) = Ï•(n) Ï•(m).

El teorema (4.8) nos permite calcular Ï•(n) de manera directa, si conocemos la factorizaciÃ³n
prima de n ,

79



Î±
Î± âˆ’1
Ï• (n) = Ï• âˆik=1 pi i = âˆik=1 pi i ( pi âˆ’ 1).

Teorema 4.9
Sea n = âˆik=1 pi i , pi primo. Entonces
Î±



1
Ï•(n) = n 1 âˆ’
p1



1
1âˆ’
p2





1
Â·Â·Â· 1 âˆ’
pk







1
1
Prueba: Si n = pÎ± , Ï•(n) = Ï•( pÎ± ) = pÎ± âˆ’ pÎ±âˆ’1 = pÎ± p âˆ’
=n pâˆ’
.
p
p
Si n = âˆik=1 pi i ,
Î±

!

k

Ï•(n) = Ï•

âˆ

i =1

Î±
pi i

k

=âˆ

i =1

Î±
pi i



1
1âˆ’
pi



k

= nâˆ

i =1



1
1âˆ’
pi



Este teorema parece algo extraÃ±o, Â¿para quÃ© usar fracciones si podemos calcular Ï•(n) con enteros?. Es cierto. Pero esta forma de expresar Ï• serÃ¡ de mucha utilidad mÃ¡s adelante cuando
aparezcan los factores 1 âˆ’ 1/pi en productos infinitos.
Ejemplo 4.12
Muestre que Ï•(n) = n/2 â‡â‡’ n = 2Î± .
SoluciÃ³n: Si n = 2Î± el resultado es directo. En la otra direcciÃ³n, si n = âˆik=1 pi i y Ï•(n) =
n/2, entonces Ï•(n) = n âˆik=1 (1 âˆ’ 1/pi ) = n/2, es decir, âˆik=1 (1 âˆ’ 1/pi ) = 1/2, por tanto
k = 1 y p1 = 2, sino tendrÃ­amos una contradicciÃ³n pues si k > 1, entonces âˆik=1 (1 âˆ’
1/pi ) < 1/2. Finalmente, n = 2Î±
Î±

Por ahora, vamos a establecer un lema anÃ¡logo al lema (4.1): a Ï•(m) â‰¡ 1 (mod m) si mcd ( a, m) = 1.
Para familiarizarnos, veamos primero un ejemplo.
Ejemplo 4.13
Ï•(12) = 4 cuenta los primos relativos con 12 que son inferiores a 12, es decir 1, 5, 7, 11.
Ahora, mcd (12, 35) = 1 y 35 Â· 1 â‰¡ 11 (mod 12), 35 Â· 5 â‰¡ 7 (mod 12), 35 Â· 7 â‰¡ 5 (mod 12)
y 35 Â· 11 â‰¡ 1 (mod 12).
AsÃ­, {35 Â· 1, 35 Â· 5, 35 Â· 7, 35 Â· 11} es una permutaciÃ³n mÃ³dulo 12 de {1, 5, 7, 11}

80

POTENCIAS mod m

El conjunto de unidades de Zm se denota (Z/mZ)âˆ— . Este conjunto es un ejemplo de un â€œsistema reducido de residuos.â€
Es claro entonces que |(Z/mZ)âˆ— | = Ï•(m) y, en particular, |(Z/mZ)âˆ— | = m âˆ’ 1 si y solo si m es
primo.

Lema 4.3
Sea m entero positivo y mcd ( a, m) = 1. Sean r1 , r2 , . . . , r Ï•(m) los Ï•(m) enteros positivos < m y
primos relativos con m. Entonces el conjunto de residuos R = { rem( a Â· r j , m) : j = 1, ..., Ï•(m)}
es una permutaciÃ³n mÃ³dulo m de los enteros r1 , r2 , . . . , r Ï•(m) .

Prueba: Como el conjunto de residuos R = {rem( a Â· r j , m) : j = 1, ..., Ï•(m)} âŠ† {r1 , r2 , . . . , r Ï•(m) },
solo hay que demostrar que R tiene Ï•(m) elementos distintos y todos primos relativos con m .
AsÃ­, estos Ï•(m) nÃºmeros son inferiores a m y coprimos con m, entonces constituyen una permutaciÃ³n mÃ³dulo m de r1 , r2 , . . . , r Ï•(m) .
Pimero observemos que cada ri âˆˆ {1, 2, ..., m âˆ’ 1} y son todos distintos, por tanto si i 6= j; ri y
r j estÃ¡n en clases de equivalencia distintas y no pueden ser congruentes.
Sea i 6= j con i, j âˆˆ {1, ..., Ï•(m)}. Si a Â· ri â‰¡ a Â· r j (mod m) entonces, como mcd ( a, m) = 1, podemos cancelar a y nos queda ri â‰¡ r j (mod m), pero esto no puede pasar.
Si mcd ( a Â· ri , m) > 1 entonces sea p un divisor primo de a Â· ri y de m. Si p| a Â· ri , entonces p|ri
o p| a. Pero esto no puede pasar pues si p|ri , como p|m entonces contradice el hecho de que
mcd (ri , m) = 1. Por otra parte p| a contradice el hecho de que mcd ( a, m) = 1.

De nuevo, vamos a dar un ejemplo antes de enunciar el teorema de Euler.

Ejemplo 4.14
Ï•(12) = 4 cuenta los primos relativos con 12 que son inferiores a 12, es decir 1, 5, 7, 11.
Ahora, mcd (12, 35) = 1 y 35 Â· 1 â‰¡ 11 (mod 12), 35 Â· 5 â‰¡ 7 (mod 12), 35 Â· 7 â‰¡ 5 (mod 12)
y 35 Â· 11 â‰¡ 1 (mod 12).
Luego,
354 (1 Â· 5 Â· 7 Â· 11)

â‰¡ (35 Â· 1)(35 Â· 5)(35 Â· 7)(35 Â· 11) (mod 12)
â‰¡ (11 Â· 7 Â· 5 Â· 1) (mod 12)

âˆ´ 354

â‰¡ 1 (mod 12)

81

pues mcd (11 Â· 7 Â· 5 Â· 1, 12) = 1.

Teorema 4.10 (Teorema de Euler).
Sea m entero positivo y mcd ( a, m) = 1, entonces
a Ï•(m) â‰¡ 1 (mod m)

Prueba: Sean r1 , r2 , . . . , r Ï•(m) Ï•(m) los enteros positivos â‰¤ m y primos relativos con m. Entonces,
por el lema (4.3),

a Ï• ( m ) (r1 Â· r2 Â· Â· Â· r Ï•(m) )

â‰¡ ( a Â· r1 )( a Â· r2 ) Â· Â· Â· ( a Â· r Ï•(m) ) (mod m)
â‰¡ (r1 Â· r2 Â· Â· Â· Â· r Ï•(m) ) (mod m)

âˆ´ a Ï•(m)

â‰¡ 1 (mod m)

pues mcd (r1 Â· r2 Â· Â· Â· Â· r Ï•(m) , m) = 1.

Ejemplo 4.15

Ï•(6566304875)

=

Ï•(53 Â· 132 Â· 310831)

= 52 (5 âˆ’ 1) Â· 13(13 âˆ’ 1) Â· (310831 âˆ’ 1)
= 4848948000.

Ï•(15)

=

Ï•(3 Â· 5) = Ï•(3) Ï•(5) = 2 Â· 4 = 8, pues mcd (3, 5) = 1.

Ejemplo 4.16
Calcular Ord39 (4).
SoluciÃ³n: Como Ï•(39) = 24, Ord39 (4)|24. Por tanto, debemos probar solo con los
divisores di de 24 hasta que 4id â‰¡ 1 (mod 39).

82

POTENCIAS mod m

4

â‰¡

rem(4, 39)

4

2

â‰¡

rem(16, 39)

4

3

â‰¡

rem(25, 39)

4

6

â‰¡

rem(1, 39)

Ord39 (4) = 6.

4.3.1

Un recÃ­proco del Teorema pequeÃ±o de Fermat

Esta es la versiÃ³n de E. Lucas del recÃ­proco del Teorema pequeÃ±o de Fermat: Si p es primo,
Ï•( p) = p âˆ’ 1 y si p no es primo Ï•( p) < p âˆ’ 1. Entonces si n âˆ’ 1 es el mÃ¡s pequeÃ±o entero
positivo tal que anâˆ’1 â‰¡ 1 (mod n), n deberÃ­a ser primo.

Teorema 4.11
Si existe un entero a primo relativo con n tal que anâˆ’1 â‰¡ 1 (mod n) y si as 6â‰¡ 1 (mod n), para
todo s < n âˆ’ 1, entonces n es primo.

Prueba: De acuerdo a la hipÃ³tesis del teorema, Ordn ( a) = n âˆ’ 1. Si n no fuera primo, Ï•(n) <
n âˆ’ 1, pero a Ï•(n) â‰¡ 1 (mod n), contradicciÃ³n con la definiciÃ³n de orden de un nÃºmero.

Una versiÃ³n refinada es

Teorema 4.12
Si a y n son enteros primos relativos tales que tales que anâˆ’1 â‰¡ 1 (mod n) y a(nâˆ’1)/q 6â‰¡ 1 (mod n)
para todos los divisores primos q de n âˆ’ 1, entonces n es primo.

Prueba: Como los divisores propios de n âˆ’ 1 dividen (n âˆ’ 1)/q para algÃºn primo q, entonces
Ordm ( a) no divide al entero (n âˆ’ 1)/q, segÃºn la hipÃ³tesis del teorema. Por tanto, la Ãºnica posibilidad es que Ordm ( a) = n âˆ’ 1. AsÃ­, (Z/nZ)âˆ— tiene n âˆ’ 1 elementos, entonces n debe ser
primo.

Con este teorema podrÃ­amos decidir si n es primo si conocemos la factorizaciÃ³n de n âˆ’ 1.

83

Ejemplo 4.17
Usar el teorema (4.12) para probar que n = 229 es primo.
SoluciÃ³n: n âˆ’ 1 = 22 Â· 3 Â· 19. Para probar que n es primo debemos encontrar 2 â‰¤ a â‰¤ 228
tal que a228 â‰¡ 1 (mod 229) y a(228)/q 6â‰¡ 1 (mod 229) para q = 2, 3, 19. Ahora hacemos una
bÃºsqueda exhaustiva:
a
2
3
4
5
6

rem( anâˆ’1 , 229)
1
1
1
1
1

rem( a(nâˆ’1)/2 , 229)
228
1
1
1
228

rem( a(nâˆ’1)/3 , 229)
1
134
1
94
134

rem( a(nâˆ’1)/19 , 229)
203
161
218
61
165

Tabla 4.2. n = 229 es primo segÃºn el teorema (4.12).

âˆ´ n = 229 cumple las condiciones del teorema (4.12) para a = 6. Por tanto, n = 229 es
primo.

4.4

Teorema de Wilson

 
n
n!
Sean n, r enteros no negativos. Recordemos que 0! = 1 y si n â‰¥ r,
=
. Se puede
r
r!
(
n
âˆ’ r )!
 
n
probar que
es un entero procediendo por inducciÃ³n y usando la identidad de Pascal:
r
  



n
nâˆ’1
nâˆ’1
=
+
r
râˆ’1
r
El teorema del binomio establece que si x, y âˆˆ R y n no negativo,
n  
n k nâˆ’k
( x + y)n = âˆ‘
x y
k
k =0
Se asume como convenio que 00 = 1 para el caso especial x 6= 0, y = 0, n = 0.

Teorema 4.13
 
 p
Si p es primo y 0 < r < p, entonces p 
r
 
p
Prueba:
es un entero asÃ­ que r!( p âˆ’ r )!| p!. Como p - r! y p - (( p âˆ’ r )!), entonces p - r!( p âˆ’ r )!.
r
AsÃ­ r!( p âˆ’ r )!| p! âˆ§ mcd ( p, r!( p âˆ’ r )!) = 1 =â‡’ r!( p âˆ’ r )!|( p âˆ’ 1)!.
 
p
( p âˆ’ 1) !
âˆ´
= pÂ·
.
r!( p âˆ’ r )!
r

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

84

POTENCIAS mod m

Teorema 4.14
Si p es primo, entonces ( x + y) p â‰¡ x p + y p (mod p) si x, y âˆˆ Z.
 
 p
si r = 1, 2, . . . , p âˆ’ 1, entonces
Prueba: Como p 
r
 
 


 
p p
p 1 p âˆ’1
p
p p
( x + y) p â‰¡
y +
x y
+ Â·Â·Â· +
x p âˆ’1 y 1 +
x (mod p)
0
1
pâˆ’1
p

â‰¡ 1 Â· y p + 0 + Â· Â· Â· + 0 + 1 Â· x p (mod p)

p

p

p

En general, si p es primo, entonces ( x1 + x2 + Â· Â· Â· + xn ) p â‰¡ x1 + x2 + Â· Â· Â· + xn (mod p) si xi âˆˆ Z.

Teorema 4.15
Sea p primo y P( x ) = an x n + Â· Â· Â· + a1 x + a0 âˆˆ Z[ x ] con an 6â‰¡ 0 (mod p). Entonces la ecuaciÃ³n
P( x ) â‰¡ 0 (mod p) tiene a lo sumo n soluciones (enteras) distintas mÃ³dulo p.
Prueba: La prueba es por inducciÃ³n sobre el grado de P. .
Si n = 0 no hay soluciones pues a0 6â‰¡ 0 (mod p).
Si n = 1, la congruencia a1 x + a0 â‰¡ 0 (mod p) tiene una solo soluciÃ³n (mÃ³dulo p) pues a1 x â‰¡
âˆ’ a0 (mod p) tiene soluciÃ³n Ãºnica mÃ³dulo p si mcd ( a1 , p) = 1.
Supongamos que el resultado es cierto para polinomios de grado â‰¤ n âˆ’ 1. Para el resto de la
prueba vamos a razonar por contradicciÃ³n: Supongamos que P( x ) = an x n + Â· Â· Â· + a1 x + a0 tiene
s > n soluciones a1 , a2 , ..., as distintas mÃ³dulo p. Consideremos ahora
Q( x ) = P( x ) âˆ’ an ( x âˆ’ a1 )( x âˆ’ a2 ) Â· Â· Â· ( x âˆ’ an ).
Observe que Q es de grado â‰¤ n âˆ’ 1 pues
Q( x ) = P( x ) âˆ’ an ( x âˆ’ a1 )( x âˆ’ a2 ) Â· Â· Â· ( x âˆ’ an ) = an x n + ... âˆ’ ( an x n + ...)
y tiene al menos n raÃ­ces pues Q( x ) â‰¡ 0 (mod p) si x = a1 , x = a2 , ..., an . Por hipÃ³tesis de inducciÃ³n, como Q tiene grado n âˆ’ 1, la Ãºnica posibilidad es que Q sea el polinomio nulo, es decir,
Q( x ) â‰¡ 0 (mod p) para toda x âˆˆ Z. En particular, Q( as ) â‰¡ 0 (mod p), Entonces

Q( as )

â‰¡

P( as ) âˆ’ an ( as âˆ’ a1 )( as âˆ’ a2 ) Â· Â· Â· ( as âˆ’ an ) (mod p)

â‰¡ âˆ’ an ( as âˆ’ a1 )( as âˆ’ a2 ) Â· Â· Â· ( as âˆ’ an ) (mod p)
â‰¡ 0 (mod p)

85

Luego, p| an ( as âˆ’ a1 )( as âˆ’ a2 ) Â· Â· Â· ( as âˆ’ an ) y como p - an , p divide algÃºn factor ( as âˆ’ a j ) con lo
que a j â‰¡ as (mod p) en contradicciÃ³n con nuestra hipÃ³tesis.

Teorema 4.16
Sea p primo. Entonces,
x pâˆ’1 âˆ’ 1 â‰¡ ( x âˆ’ 1)( x âˆ’ 2) Â· Â· Â· ( x âˆ’ p + 1) (mod p)
Prueba: Como p es primo y como p es coprimo con 1, 2, ..., p âˆ’ 1, por el teorema de Euler tenemos, x pâˆ’1 â‰¡ 1 (mod p) para x = 1, 2, ..., p âˆ’ 1. Entonces, x pâˆ’1 âˆ’ 1 es un polinomio con p âˆ’ 1
raÃ­ces. Usando el teorema (4.15) tenemos
x pâˆ’1 âˆ’ 1 â‰¡ ( x âˆ’ 1)( x âˆ’ 2) Â· Â· Â· ( x âˆ’ p + 1) (mod p) si x = 1, 2, ..., p âˆ’ 1
Pero, como Q( x ) = x pâˆ’1 âˆ’ 1 âˆ’ ( x âˆ’ 1)( x âˆ’ 2) Â· Â· Â· ( x âˆ’ p + 1) tiene grado â‰¤ p âˆ’ 2 y p âˆ’ 1 raÃ­ces,
Q( x ) â‰¡ 0 (mod p), es decir,
x pâˆ’1 âˆ’ 1 â‰¡ ( x âˆ’ 1)( x âˆ’ 2) Â· Â· Â· ( x âˆ’ p + 1) (mod p) si x âˆˆ Z

Teorema 4.17 (Teorema de Wilson).
p es primo si y solo si ( p âˆ’ 1)! â‰¡ âˆ’1 (mod p)
Prueba: Si p es primo, por el teorema (4.16),
x pâˆ’1 âˆ’ 1 â‰¡ ( x âˆ’ 1)( x âˆ’ 2) Â· Â· Â· ( x âˆ’ ( p âˆ’ 1)) (mod p) para cualquier x âˆˆ Z.
Poniendo x = 0, âˆ’1 â‰¡ (âˆ’1) pâˆ’1 1 Â· 2 Â· Â· Â· ( p âˆ’ 1) (mod p). Si p es impar, obtenemos el resultado.
Si p = 2 el resultado es directo.
Si ( p âˆ’ 1)! â‰¡ âˆ’1 (mod p) y p tiene un divisor d, 1 < d < p, entonces d|( p âˆ’ 1)! + 1 pero
d|( p âˆ’ 1)! pues 1 < d < p, asÃ­ que d|1, contradicciÃ³n.

Es claro que no es prÃ¡ctico usar este teorema para verificar si p es o no primo.

4.5

Teorema de Carmichael

El cÃ¡lculo del orden de un nÃºmero a puede ser complicado. Algo que nos puede ayudar es saber
que este orden es inferior a Ï•( a) y un factor de la funciÃ³n Î»( a) de Carmichael.

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

86

POTENCIAS mod m

DefiniciÃ³n 4.3 (FunciÃ³n de Carmichael).
Sean p, p1 , p2 , ..., ps primos, la funciÃ³n Î» se define asÃ­:
Î» (1)
Î» (2)
Î» (4)
Î» (2Î± )
Î»( pÎ± )
Î»(n)

=
=
=
=
=
=

ï£¼
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£½

1,
1,
2,
2Î± âˆ’2
Ï• ( p Î± ) = p Î± âˆ’1 ( p âˆ’ 1 )
Î±
Î±
mcm (Î»( p1 1 ), Î»( p2Î±2 ), . . . , Î»( pk k ))

si Î± â‰¥ 3,
si pi â‰¥ 3 y Î± â‰¥ 1,
Î±
si n = âˆik=1 pi i

ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£´
ï£¾

Ejemplo 4.18
Î»(1) = 1, Î»(2) = 1, Î»(3) = 2, etc.
n
Î»(n)

1
1

2
1

3
2

4
2

5
4

6
2

7
6

8
2

9
6

10
4

100
20

101
100

102
16

103
102

Teorema 4.18 (Teorema de Carmichael).
Sean a, n âˆˆ Z+ y mcd ( a, n) = 1. Entonces
aÎ»(n) â‰¡ 1 (mod n)
Prueba: n = âˆik=2 2Î± pi i , pi primo y mcd ( a, n) = 1. Por la definiciÃ³n de la funciÃ³n Î», se tiene
Î±

Î±

(1)

aÎ»(2 ) â‰¡ 1 (mod 2Î± )

(2)

a Î» ( p1

Î±1

)

Î±
Î» ( p2 2 )

(3)

a
...

(k)

aÎ»( pk

Î±k

)

â‰¡ 1 (mod p1Î±1 )
â‰¡ 1 (mod p2Î±2 )
Î±

â‰¡ 1 (mod pk k )

Ahora, en la primera congruencia, elevamos a ambos lados a la potencia entera Î»(n)/Î»(2Î± ) y en
Î±
la congruencia i âˆ’Ã©sima elevamos a ambos lados a la potencia entera Î»(n)/Î»( pi i ), obtenemos
aÎ»(n) â‰¡ 1 (mod 2Î± )
Î±
aÎ»(n) â‰¡ 1 (mod p1 1 )
aÎ»(n) â‰¡ 1 (mod p2Î±2 )
...
Î±
Î»
(
n
)
a
â‰¡ 1 (mod pk k )
Para concluir, recordemos que si m1 , m2 , ..., mk âˆˆ Z+ y si a â‰¡ b (mod mi ), i = 1, 2, ..., k; entonces
a â‰¡ b (mod mcm (m1 m2 Â· Â· Â· mk )). Usando este hecho, podemos concluir que aÎ»(n) â‰¡ 1 (mod n).

Â¿Se gana algo usando Î»(n) en vez de Ï•(n)? Con un esfuerzo razonablemente pequeÃ±o,
podemos obtener, en general, mejores resultados con Î».

87

Ejemplo 4.19
Sea n = 65520 = 24 Â· 32 Â· 5 Â· 7 Â· 13. Entonces Ï•(n) = 8 Â· 6 Â· 4 Â· 6 Â· 12 = 13824 mientras que
Î»(n) = mcm (4, 6, 4, 6, 12) = 12. Entonces, si mcd ( a, n) = 1,
aÎ»(n) â‰¡ 1 (mod 65520) =â‡’ a12 â‰¡ 1 (mod 65520)
a Ï•(n) â‰¡ 1 (mod 65520) =â‡’ a13824 â‰¡ 1 (mod 65520)
Para encontrar el orden de a, se puede probar con los divisores de 12 en vez de calcular
y usar los divisores de 13824

Ejemplo 4.20
Calcular Ord39 (4).
SoluciÃ³n: Como Î»(39) = 12, Ord39 (4)|12. Por tanto, debemos probar solo con los
divisores di de 12 hasta que 4id â‰¡ 1 (mod 39).
4
42
43
46

â‰¡
â‰¡
â‰¡
â‰¡

rem(1, 39)
rem(16, 39)
rem(25, 39)
rem(1, 39)

ï£¼
ï£´
ï£´
ï£½

=â‡’ Ord39 (4) = 6.

ï£´
ï£´
ï£¾

Uno de los resultados importantes es: Î»(n) es el mÃ¡s pequeÃ±o entero positivo para tal que aÎ»(n) â‰¡
1 (mod m) para todo a tal que mcd ( a, m) = 1 (ver [1]).
Î»(n) y Ï•(n) si mcd ( a, n) > 1 . El teorema de Euler y Carmichael requieren mcd ( a, n) = 1. Sin
embargo hay una versiÃ³n Ãºtil para el caso en que mcd ( a, n) no sea necesariamente 1.

Teorema 4.19
Sea d = mcd ( a, n),
 n
= 1.
a Ï•(n)+1 â‰¡ a (mod n) â‡â‡’ mcd d,
d
Si n es producto de primos distintos,
aÎ»(n)+1 â‰¡ a (mod n) para cualquier a âˆˆ Z.

Prueba: Ver ([9], pÃ¡g. 274).

88

POTENCIAS mod m

Ejemplo 4.21
Sea a = 7 y n = 210, mcd ( a, n) = 7 > 1, Ï•(n) = 48, 749 â‰¡ 7 (mod 210) y mcd (7, 30) = 1
(tambiÃ©n 71 â‰¡ 7 (mod 210) , 75 â‰¡ 7 (mod 210), etc.).
Sea n = 2 Â· 3 Â· 5 Â· 7, Î»(n) = 12, 213 â‰¡ 2 (mod 210) , 313 â‰¡ 3 (mod 210), etc.
Sea n = 22 Â· 5, en este caso Î»(n) = 4 y 25 6â‰¡ 2 (mod n), 35 â‰¡ 3 (mod n), . . . , 65 6â‰¡ 6 (mod n),
etc.

EJERCICIOS
4.1

Verifique, usando el teorema de Fermat, que 2340 â‰¡ 1 (mod 11).

4.2

Verifique que 2340 â‰¡ 1 (mod 31). Ayuda: 25 â‰¡ 1 (mod 31)

4.3

Verifique que mcd (341, 2) = 1 y 2340 â‰¡ 1 (mod 341). Â¿Es 341 primo?

4.4

Verifique que Ï•(666) = 6 Â· 6 Â· 6
n

4.5 Consideremos los nÃºmeros de Fermat, Fn = 22 + 1. Vamos a probar, usando congruencias, que si n 6= m, mcd ( Fn , Fm ) = 1. Para probar esto, vamos a suponer, por contradicciÃ³n, que
mcd ( Fn , Fm ) = d > 1. Entonces hay un primo p tal que p| Fn y p| Fm . Bajo esta suposiciÃ³n,
n

a) verifique que 22 â‰¡ âˆ’1 (mod p),
n +1

b) verifique que 22 â‰¡ 1 (mod p).
c) Sea Ord p (2) = 2s . Â¿PorquÃ© 2s â‰¤ n + 1 ?
d) Verifique que s  n. Ayuda: considere 2n = 2s 2t con s + t = n y obtenga una contran
dicciÃ³n con 22 â‰¡ âˆ’1 (mod p).
e) Deduzca que el orden de 2 mÃ³dulo p es 2n+1
f) Deduzca que el orden de 2 mÃ³dulo p deberÃ­a ser tambiÃ©n 2m+1
g) Â¿CuÃ¡l es la contradicciÃ³n?
4.6 Use el resultado anterior para dar otra prueba de que los primos son un conjunto infinito.
Ayuda: para cada Fn considere uno de sus divisores primos.
4.7

Sea mcd ( a, m) = 1 y Ordm ( a) = t. Si i, j âˆˆ Z, ai â‰¡ a j (mod m) â‡â‡’ i â‰¡ j (mod t).

4.8 Muestre que si m es compuesto y mcd ( a, m) = 1, entonces Ordm (b) < m âˆ’ 1. Ayuda: Use
el teorema de Euler.
4.9 Muestre que si p es primo y t - ( p âˆ’ 1), entonces no pueden haber elementos de orden t
en Z p . Ayuda: Use Fermat.
4.10

Sea Ordm ( a) = t. Muestre que Ordm ( ai ) = t si y solo si mcd (i, t) = 1.

4.11

Calcule Ord13 (5) y Ord13 (7)

4.12

Sea mcd ( a, m) = 1. Muestre que Ordm ( a) divide a Ï†(m).

4.13

Muestre que si p es primo y mcd ( a, p) = 1, entonces Ord p ( a)| p âˆ’ 1.

EJERCICIOS

89

4.14 Muestre que si Ordm ( a) = t y k es cualquier entero positivo, entonces Ordm ( ak ) = 1 si y
solo si mcd (t, k) = 1.
4.15

Sean a = 7 y m = 310.
a) Calcule Ï•(m) y Î»(m).
b) Â¿Se puede afirmar, sin calcular, que aÎ»(m) â‰¡ 1 (mod m) ?
c) Obtenga Ordm ( a) Ayuda: solo debe probar con los divisores de Î»(m).

4.16

Sean a = 7 y m = 210.
a) Â¿Tiene sentido hablar de Ordm ( a) ?
b) Calcule s tal que as â‰¡ a (mod m).

4.17

Calcule Ord2337 (2)

4.18 Muestre que si p es primo y Ord p ( a) = t, entonces las soluciones, mÃ³dulo p, de x t âˆ’ 1 â‰¡
0 (mod p) son {1, a, a2 , ..., atâˆ’1 }. Â¿porquÃ© no hay mÃ¡s soluciones mÃ³dulo p?
4.19 Sea p primo impar. Muestre que si P( x ) es un polinomio con coeficientes enteros de
grado n â‰¥ 1 y coeficiente principal an 6â‰¡ 0 (mod p), entonces hay un polinomio Q( x ) âˆˆ Z[ x ] de
grado 0 < m < p tal que P( x ) â‰¡ Q( x ) (mod p).
4.20

Muestre el teorema â€œpequeÃ±oâ€ de Fermat usando el teorema de Euler.

4.21

Muestre el teorema de Euler usando el teorema de Carmichael.

4.22 Muestre que si n es par entonces Ï•(2n) = 2Ï•(n) y que si n es impar entonces Ï•(2n) =
2Ï•(n). Ayuda: Teorema (4.8).
4.23

Calcule Ï•(25) usando el teorema (5.2).

4.24

Factorizar n = 2337 y calcular Ï•(n) y Î»(n)

4.25

Calcule las raÃ­ces (si hubiera) de P( x ) = x5 + 1 mÃ³dulo 5

4.26

Calcule las raÃ­ces (si hubiera) de P( x ) = x5 âˆ’ 1 mÃ³dulo 5

4.27 Calcule 96âˆ’1 mÃ³dulo 97. Luego calcule el resto de dividir 95! por 97. Ayuda: Fermat y
Wilson.
4.28 Sea p primo impar y mcd ( a, p) = 1. Mostrar que a( pâˆ’1)/2 â‰¡ 1 (mod p) o a( pâˆ’1)/2 â‰¡
âˆ’1 (mod p). Ayuda: Usar la tercera fÃ³rmula notable y el teorema de Fermat.
4.29 Resuelva 7x â‰¡ 1 (mod 26 Â· 3 Â· 5 Â· 17) usando primero el teorema pequeÃ±o de Fermat y luego
usando el teorema de Carmichael.
p

p

p

4.30 Mostrar que si p es primo, entonces ( x1 + x2 + Â· Â· Â· + xn ) p â‰¡ x1 + x2 + Â· Â· Â· + xn (mod p) si
xi âˆˆ Z.
4.31

Sean mcd ( a, b) = 1 y S = a Ï•(b) + b Ï•(a) . Muestre que S â‰¡ 1 (mod ab)

4.32 Use el teorema â€œpequeÃ±oâ€ de Fermat para probar que si p es primo y mcd ( p, n) = 1 y
p|4n2 + 1, entonces p â‰¡ 1 (mod 4). Ayuda: Muestre que p 6â‰¡ 3 (mod 4) por contradicciÃ³n: Si
p = 4k + 1 y si y = 2n, y2 â‰¡ âˆ’1 (mod p) luego, como mcd ( p, y) = 1, aplique Fermat.
4.33

Muestre que si p es primo y mcd ( p, n) = 1 y p|n2 + 1, entonces p â‰¡ 1 (mod 4) o p = 2.

4.34 Muestre que en Z8 , el polinomio P( x ) = x2 âˆ’ 1 tiene 4 raÃ­ces: x = 1, 3, 5, 7, es decir,
P(1) â‰¡ 0 (mod 8), etc. Â¿Contradice esto el teorema (4.15)?

90

POTENCIAS mod m

4.35

Muestre el teorema â€œpequeÃ±oâ€ de Fermat usando el teorema del binomio. Ayuda: xi = 1.

4.36 Muestre que si a â‰¡ 1 (mod 2), entonces a2 â‰¡ 1 (mod 23 ) . Ayuda: a = 2h + 1, eleve al
cuadrado y observe que h(h + 1) es par.
2

4.37

Muestre que si a2 â‰¡ 1 (mod 23 ) entonces a2 â‰¡ 1 (mod 24 ).

4.38

Use inducciÃ³n para demostrar que si Î± > 2, entonces a2

4.39

Verifique que si Î± > 2, entonces a 2 Ï•(2 ) â‰¡ 1 (mod 2Î± ).

4.40

Muestre que si n = âˆik=1 pi i , pi primo; entonces Î»( pi i )|Î»(n)

4.41

Muestre que Î»(n)| Ï•(n)

4.42

Muestre que Î»(n) = Ï•(n) si n = 1, 2, 4, pÎ± , 2pÎ±

1

Î± âˆ’2

â‰¡ 1 (mod 2Î± ).

Î±

Î±

Î±

EJERCICIOS

91

VersiÃ³n actualizada de este libro: https://tecdigital.tec.ac.cr/revistamatematica/Libros/

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

235711
131719
232931
235711

5
5.1

RAIÌCES PRIMITIVAS Y
LOGARITMO DISCRETO

IntroducciÃ³n

Se puede demostrar que si p es primo, existe b âˆˆ Z tal que Z p = {Z p = {0, b, b2 , ..., b pâˆ’1 }. A b
se le llama â€œraÃ­z primitivaâ€ mÃ³dulo p. Como cualquier elemento a âˆˆ Z p debe ser una potencia
de b, tiene sentido definir un logaritmo discreto (indicador) que resulta tener propiedades similares al logaritmo usual. Es muy Ãºtil en el cÃ¡lculo de residuos y para resolver algunos tipos de
ecuaciones congruenciales. Las raÃ­ces primitivas mÃ³dulo n son usadas a menudo en criptografÃ­a.

5.2

RaÃ­ces Primitivas

DefiniciÃ³n 5.1 (RaÃ­ces primitivas).
Sea m âˆˆ Z+ y mcd ( a, m) = 1. Si Ordm ( a) = Ï•(m) entonces a se dice raÃ­z primitiva mÃ³dulo m

Teorema 5.1
Si p es primo y b raÃ­z primitiva mÃ³dulo p, entonces Z p = {0, b, b2 , ..., b pâˆ’1 }.

Prueba: Ejercicio.

Ejemplo 5.1
Ord5 (3) = 4 pues 32 â‰¡ 4 (mod 5), 33 â‰¡ 2 (mod 5) y 34 â‰¡ 1 (mod 5). Entonces,
Z5 = {0, 3, 32 , 33 , 34 }

Existencia de las raÃ­ces primitivas. Para establecer la existencia de las raÃ­ces primitivas en
cualquier Z p , p primo; necesitamos algunos resultados.
El teorema que sigue establece que

âˆ‘ Ï•(d) = n.

Para la demostraciÃ³n, se usa un conjunto

d|n
d >0

Sd = { d1 , 2d , . . . , dd } y otros conjuntos de fracciones irreducibles (disjuntos):


i
Td =
âˆˆ Sd tal que mcd (i, d) = 1 .
d
La idea es contar la cantidad de primos relativos como el nÃºmero de fracciones irreducibles. El
siguiente ejemplo muestra la idea de la prueba.
Ejemplo 5.2
Sea n = 4. Los divisores positivos de 4 son 1, 2, 4. Entonces,



S4 =

Observemos que Ti

T


1 2 3 4
, , ,
4 4 4 4


1 3
,
T4 =
4 4
 
1
T2 =
2
 
1
T1 =
1

=â‡’ |S4 | = 4
=â‡’ | T4 | = Ï•(4) = 2
=â‡’ | T2 | = Ï•(2) = 1
=â‡’ | T1 | = Ï•(1) = 1

Tj = âˆ… y que |S4 | = | T4 | + | T2 | + | T1 |, es decir,

4 = Ï• (1) + Ï• (2) + Ï• (4)

Teorema 5.2
Sea n un entero positivo, entonces

âˆ‘ Ï•(d) = n

d|n
d >0

93

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

94

RAIÌCES PRIMITIVAS Y LOGARITMO DISCRETO

Prueba: Sea Sn = { n1 , n2 , . . . , nn } y sea Tn = { ni âˆˆ Sn tal que mcd (i, n) = 1}. Claramente |Sn | = n
y | Tn | = Ï•(n). Ahora, si d|n, d > 0; Td = { di âˆˆ Sd tal que mcd (i, d) = 1}, entonces
Sn =

[

Td = T1 âˆª . . . âˆª Tn

d|n
d >0

En efecto,
â€œâŠ† â€:

i
âˆˆ Sn tenemos dos casos. Si mcd (i, n) = 1,
n

i
n

âˆˆ Tn . Si

i
no estÃ¡ en forma reducida,
n

i
k
=
con
n
h
âˆˆ Th y por tanto estÃ¡ en la uniÃ³n de los â€œTd â€™sâ€.

entonces, usando la factorizaciÃ³n prima de i y de n, simplificamos y nos queda
mcd (k, h) = 1 y 1 â‰¤ k â‰¤ h. Como h|n, entonces
â€œâŠ‡ â€: Ahora si s âˆˆ

S

d|n Td ,
d >0

k
h

entonces s âˆˆ Th para algÃºn h|n. Por tanto, s =

y 1 â‰¤ j â‰¤ h. Si n = k0 h, se tiene jk0 â‰¤ n, asÃ­ s =

j
con mcd ( j, h) = 1
h

j
k0 j
= 0 âˆˆ Sn .
h
kh

Si d y d0 son divisores distintos de n, Td âˆ© Td0 = âˆ…. Esto es asÃ­ pues si s estÃ¡ en esta la interj
i
secciÃ³n, s = = 0 =â‡’ id = jd0 y entonces, como mcd ( j, d) = mcd (i, d0 ) = 1, d|d0 y d0 |d. Esto
d
d
contradice que d 6= d0 .
Finalmente, |Sn | =

âˆ‘ |Td |, entonces, como |Td | = Ï•(d), n = âˆ‘ Ï•(d).

d|n
d >0

d|n
d >0

El teorema (5.2) nos da una fÃ³rmula recursiva para calcular Ï•(n). No es un fÃ³rmula adecuada
para cÃ¡lculos porque requiere todos los divisores (primos y compuestos) de n

Ejemplo 5.3
Como Ï•(1) = 1, Ï•(3) = 2 y Ï•(5) = 4, entonces
Ï•(1) + Ï•(3) + Ï•(5) + Ï•(15) = 15 =â‡’ Ï•(15) = 8.

Teorema 5.3
Sea p primo y t un entero positivo. Si t - ( p âˆ’ 1) entonces Z p no tiene elementos de orden t. Si
t|( p âˆ’ 1), hay exactamente Ï•(t) elementos de orden t en Z p
Prueba: De acuerdo al teorema â€œpequeÃ±oâ€ de Fermat, para cada a âˆˆ Z p , a 6= 0, a pâˆ’1 â‰¡ 1 (mod p).
Luego, si a es de orden t, t|( p âˆ’ 1), o lo que es lo mismo, si t - ( p âˆ’ 1) no hay elementos de
orden t.
Para probar la segunda parte, definimos una nueva funciÃ³n Ïˆ(t) : Para cada entero positivo s
que divide a p âˆ’ 1, sea Ïˆ(s) el nÃºmero de elementos de orden s en Z p . Ahora, como cada

95

elemento en Zâˆ—p tiene algÃºn orden s que divide a p âˆ’ 1, entonces

âˆ‘

Ïˆ(t) = p âˆ’ 1

t|( pâˆ’1)

Por el teorema (5.2), âˆ‘t|( pâˆ’1) Ï•(t) = p âˆ’ 1, entonces

âˆ‘

( Ï•(t) âˆ’ Ïˆ(t)) = 0

t|( pâˆ’1)

Pero, para cualquier entero t, no hay elementos de orden t o hay exactamente Ï•(t) elementos
de orden t; entonces Ï•(t) âˆ’ Ïˆ(t) â‰¥ 0 para todo t. Como los sumandos son â‰¥ 0 y la suma da
cero, cada sumado vale cero: Ï•(t) = Ïˆ(t) para cada t|( p âˆ’ 1).

Corolario 5.1 Si p es primo, en Z p hay Ï•( p âˆ’ 1) elementos de orden p âˆ’ 1, es decir, hay Ï•( p âˆ’ 1)
raÃ­ces primitivas.

Ejemplo 5.4
Cuando tenemos un primo pequeÃ±o, podemos localizar las raÃ­ces primitivas por â€œensayo
y errorâ€, construyendo una tabla de potencias.
a
1
2
3
4
5
6

a1
1
2
3
4
5
6

a2
1
4
2
2
4
1

a3
1
1
6
1
6
6

a4
1
2
4
4
2
1

a5
1
4
5
2
3
6

a6
1
1
1
1
1
1

Ord7 ( a)
1
3
6
3
6
2

Tabla 5.1. Potencias de los elementos de Z7

Solo hay Ï•(6) = 2 raÃ­ces primitivas mÃ³dulo 7, 3 y 5 tienen orden 6, es decir, son las
Ãºnicas dos raÃ­ces primitivas mÃ³dulo 7. TambiÃ©n, por ejemplo, Z7 = {0, 5, 52 , 53 , 54 , 55 , 56 }.

Ejemplo 5.5
La tabla que sigue es un listado de las raÃ­ces primitivas de los primeros seis primos.

96

RAIÌCES PRIMITIVAS Y LOGARITMO DISCRETO

p
2
3
5
7
11
13

Ï• ( p âˆ’ 1)
1
1
2
2
4
4

RaÃ­ces primitivas
1
2
2, 3
3, 5
2, 6, 7, 8
2, 6, 7, 11

Tabla 5.2. RaÃ­ces primitivas mÃ³dulo p

Si b es raÃ­z primitiva del primo p, hay Ï•( p âˆ’ 1) raÃ­ces primitivas no congruentes, a saber,
bÎ±1 , bÎ±2 , ..., bÎ± Ï•( pâˆ’1) , donde Î±1 , Î±2 , ..., Î± Ï•( pâˆ’1) son los Ï•( p âˆ’ 1) enteros menores que p âˆ’ 1 y coprimos con p âˆ’ 1.

Ejemplo 5.6
Determinar las raÃ­ces primitivas de 17 sabiendo que 3 es raÃ­z primitiva mÃ³dulo 17.
SoluciÃ³n: Como Ï•(17) = 8, los ocho enteros menores que 16 y coprimos con 16 son
1, 3, 5, 7, 9, 11, 13 y 15. AsÃ­, la raÃ­ces primitivas son 33 , 35 , 37 , 39 , 31 1, 31 3. Haciendo la
reducciÃ³n a mÃ³dulo 17, no queda 3, 10, 5, 11, 14, 7, 12, 6.

Ya probamos la existencia de raÃ­ces primitivas para p primo. El siguiente teorema define la
situaciÃ³n general.

Teorema 5.4 (Gauss).
Un entero n > 1 tiene raÃ­ces primitivas mÃ³dulo n si y solo si n = 2, 4, pÎ± o 2pÎ± donde p es
primo impar y Î± entero positivo.

En particular, todos los primos tienen raÃ­ces primitivas.

Ejemplo 5.7
Los primeros n para los que hay raÃ­ces primitivas son 2, 3, 4, 5, 6, 7, 9, 10, 11, 13,
14, 17, 18, 19, 22, ... . En particular, no hay raÃ­ces primitivas mÃ³dulo n = 24 = 16.
En resumen, podemos determinar si hay o no hay raÃ­ces primitivas mÃ³dulo n y el cÃ¡lculo de estas raÃ­ces se hace usando â€œprueba y errorâ€ (aunque hay unas pocas tÃ©cnicas generales de cÃ¡lculo).

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

97

5.3

Logaritmo discreto o Indicador

El problema que queremos resolver es el siguiente: Si sabemos que a â‰¡ bk (mod m), Â¿CÃ³mo determinar k?
Recordemos que en Zn hay Ï•(n) elementos primos relativos con n.

DefiniciÃ³n 5.2 (Sistema reducido de residuos).
Sea n âˆˆ Z+ . El conjunto { a1 , a2 , ..., a Ï•(n) } es un sistema reducido de residuos mÃ³dulo n, si
contiene exactamente un elemento de cada una de las clases ri âˆˆ Zn para las que mcd (ri , n) = 1.

Ejemplo 5.8
Si n = p es primo, {1, 2, ..., p âˆ’ 1} es un sistema reducido de residuos mÃ³dulo p.
Si n = 10, Ï•(10) = 4. En este caso, {1, 3, 7, 9} es un sistema reducido de residuos mÃ³dulo
10.

Claramente, si b es una raÃ­z primitiva mÃ³dulo n, el conjunto {b, b2 , ..., b Ï•(n) } es un sistema
reducido de residuos. Entonces, si a âˆˆ Zn con mcd ( a, n) = 1, existe 1 â‰¤ k â‰¤ Ï•(n) tal que
a â‰¡ bk (mod n). En particular 1 â‰¡ b Ï•(n) (mod n), por el teorema de Euler.

DefiniciÃ³n 5.3
Sea b una raÃ­z primitiva mÃ³dulo n. Si mcd ( a, n) = 1, entonces el mÃ¡s pequeÃ±o entero positivo
k tal que a â‰¡ bk (mod n) se denota con Indb ( a) y se llama indicador de a respecto a la base b
mÃ³dulo n.

Entonces tenemos,
a â‰¡ bIndb (a) (mod n)

A veces se pone Indb ( a) = logb a y se le llama â€œlogaritmo discretoâ€.
Propiedades.Las propiedades de Indb ( a) son similares a las de la funciÃ³n logaritmo.

98

RAIÌCES PRIMITIVAS Y LOGARITMO DISCRETO

Teorema 5.5
Sea b raÃ­z primitiva mÃ³dulo n y mcd ( a, n) = mcd (c, n) = 1. Entonces,
a.) b x â‰¡ by (mod n) â‡â‡’ x â‰¡ y (mod Ï•(n))
b.) Indb (1) â‰¡ 0 (mod Ï•(n))
c.) Indb ( ac) â‰¡ [Indb ( a) + Indb (c)] (mod Ï•(n))
d.) Indb ( ak ) â‰¡ k Â· Indb ( a) (mod Ï•(n)), si k es entero positivo.

Prueba: Ejercicio.

El teorema 5.5 a.) nos dice que,
a â‰¡ bk (mod n) â‡â‡’ Indb ( a) = rem(k, Ï•(n))

(5.1)

La reducciÃ³n mÃ³dulo Ï•(n) es necesaria para obtener el menor exponente positivo, excepto
cuando 1 â‰¡ b Ï•(n) (mod n), es claro que, como 1 â‰¡ b Ï•(n) (mod n), Indb (1) = Ï•(n).
Ejemplo 5.9
Se sabe que b = 5 es raÃ­z primitiva mÃ³dulo 7 y Ï•(7) = 6,
a.) 2 â‰¡ 510 (mod 7)
2 â‰¡ 54 (mod 7).

â‡â‡’ Ind5 (2) = rem(10, 6) = 4, es decir, efectivamente

b.) 1 â‰¡ 56 (mod 7) â‡â‡’ Ind5 (1) = rem(6, 6) = 0, es decir, como efectivamente indica
5.5 b.) , 6 = Ind5 (1) â‰¡ 0 (mod 6).

Observe que el teorema 5.5 nos dice que â€œIndâ€ se puede aplicar igual que se aplican los logaritmos para resolver ecuaciones (siempre y cuando se cumplan las hipÃ³tesis),
g( x ) â‰¡ f ( x ) (mod m) =â‡’ Indb ( g( x )) â‰¡ Indb ( f ( x )) (mod Ï•(m)).
Por supuesto, la aplicaciÃ³n de esta parte del teorema requiere tener a la mano una tabla de
indicadores. En el ejemplo que sigue construimos una breve tabla para Ind2 ( a) mÃ³dulo 13.
Ejemplo 5.10
Como es usual, para usar el teorema (5.5) necesitamos una tabla de logaritmos discretos.
Por ejemplo, para construir una tabla parcial en base b = 2 mÃ³dulo 13, calculamos las
potencias de 2 mÃ³dulo 13.

99

2
4
8
3
6
12

â‰¡
â‰¡
â‰¡
â‰¡
â‰¡
â‰¡

21 (mod 13),
22 (mod 13),
23 (mod 13),
24 (mod 13),
25 (mod 13),
26 (mod 13),

11
9
5
10
7
1

â‰¡ 27 (mod 13),
â‰¡ 28 (mod 13),
â‰¡ 29 (mod 13),
â‰¡ 210 (mod 13),
â‰¡ 211 (mod 13),
â‰¡ 212 (mod 13).

Luego, ponemos la informaciÃ³n en una tabla,
a
Ind2 ( a)

1
12

2
1

3
4

4
2

5
9

6
5

7
11

8
3

9
8

10
10

11
7

12
6

Tabla 5.3. Logaritmos discreto base b = 2 mÃ³dulo 13

Ejemplo 5.11
Resolver 8x5 â‰¡ 2 (mod 13) con mcd ( x, 13) = 1
SoluciÃ³n: Como b = 2 es raÃ­z primitiva mÃ³dulo 13 y como conocemos una tabla de logaritmos discretos para esta base, podemos aplicar â€œInd2 (Â·)â€ a ambos lados de la ecuaciÃ³n
8x5 â‰¡ 2 (mod 13),
8x5 â‰¡ 2 (mod 13) =â‡’ Ind2 (8x5 ) â‰¡ Ind2 (2) (mod Ï•(13))
Ahora operamos,
Ind2 (8x5 )
Ind2 (8) + 5Ind2 ( x )
3 + 5Ind2 ( x )
5Ind2 ( x )
Ind2 ( x )
Ind2 ( x )
x

â‰¡
â‰¡
â‰¡
â‰¡
â‰¡
â‰¡
â‰¡

Ind2 (2) (mod Ï•(13))
1 (mod 12),
1 (mod 12),
âˆ’2 (mod 12),
âˆ’10 (mod 12),
2 (mod 12),
rem(22 , 13),

pues mcd (8, 13) = 1 y mcd ( x, 13) = 1,
pues Ind2 (8) = 3
pues 5 Â· 5 â‰¡ 1 (mod 12)
pues âˆ’ 10 â‰¡ 2 (mod 12)
por 5.1

Y, efectivamente, 8 Â· 45 = 8192 â‰¡ 2 (mod 13).

Ejemplo 5.12
Resolver 23x â‰¡ 8 (mod 13) .
SoluciÃ³n: Como b = 2 es raÃ­z primitiva mÃ³dulo 13, podemos aplicar â€œInd2 (Â·)â€ a ambos
lados,
23x â‰¡ 8 (mod 13)

=â‡’ Ind2 (23x ) â‰¡ Ind2 (8) (mod 12)
=â‡’ 3x â‰¡ 3 (mod 12)
=â‡’ x â‰¡ 1 (mod 4)

100

RAIÌCES PRIMITIVAS Y LOGARITMO DISCRETO

Ahora, los elementos en Z13 que son congruentes con 1 mÃ³dulo 4 son x = 1, 5, 9.

Ejemplo 5.13
Calcule el residuo de dividir 12729 Â· 797 por 17.
SoluciÃ³n: 3 es raÃ­z primitiva mÃ³dulo 17. AsÃ­ que podemos tomar logaritmo discreto en
base 3. En particular, Ind3 (12) = 13 y Ind3 (7) = 11.
Sea x â‰¡ 12729 Â· 797 (mod 17), aplicando logaritmo discreto,
Ind3 ( x ) â‰¡ Ind3 (12729 Â· 797 ) (mod 16),
entonces Ind3 ( x ) â‰¡ 729 Â· Ind3 (12) + 97 Â· Ind3 (7) â‰¡ 9 Â· 13 + 1 Â· 11 â‰¡ 0 (mod 16), es decir,
x â‰¡ 1 (mod 17.)

Ejemplo 5.14
Probar que la congruencia 25x5 â‰¡ 17 (mod 71) no tiene soluciÃ³n
SoluciÃ³n: Para aplicar logaritmo discreto a ambos lados, necesitamos una raÃ­z primitiva
mÃ³dulo 71. Como Ord71 (7) = 70, g = 7 es raÃ­z primitiva mÃ³dulo 71. En particular,
Ind7 (17) = 49 y Ind7 (25) = 15. Ahora,
Ind7 (25x5 ) â‰¡ Ind7 (17) (mod 70) â‡” 5 Â· Ind7 ( x ) â‰¡ Ind7 (17) âˆ’ Ind7 (25) (mod 70), es decir,
5 Â· Ind7 ( x ) â‰¡ 34 (mod 70).
Esta Ãºltima congruencia no tiene soluciÃ³n pues mcd (5, 70) = 5 - 34.

Comparado con el logaritmo comÃºn, el logaritmo discreto tiene dos defectos: (1) las tablas se
deben construir para cada mÃ³dulo primo y hay Ï•( p âˆ’ 1) posibles bases; (2) los datos en las
tablas no estÃ¡n en orden ascendente.
El siguiente teorema establece algunas fÃ³rmulas Ãºtiles para el cÃ¡lculo de Ã­ndices.

EJERCICIOS

101

Teorema 5.6
Sea b una raÃ­z primitiva mÃ³dulo m.
a.) Si mcd ( a, m) = 1, entonces Indb ( aâˆ’1 ) = Ï•(m) âˆ’ Indb ( a)
b.) Si m â‰¥ 3, Indb (m âˆ’ 1) = Ï•(m)/2
c.) Si p es primo impar, Indb ( p âˆ’ 1) = Ï•( p âˆ’ 1)/2
d.) Si m â‰¥ 3 y mcd ( a, m) = 1, entonces Indb (m âˆ’ 1) = Indb ( a) + Ï•(m)/2
e.) Si m es primo impar y mcd ( a, m) = 1, entonces Indb (m âˆ’ 1) = Indb ( a) + Ï•(m âˆ’ 1)/2

Ejemplo 5.15
Podemos usar la parte e.) del teorema (5.6) para construir una tabla para logaritmo discreto en base 3 mÃ³dulo 7,
a
Ind3 ( a)

1
6

2
2

3
1

4
.

5
.

6
.

Tabla 5.4. Logaritmos discreto base b = 3 mÃ³dulo 7

EJERCICIOS
5.1

Muestre que en Z7 , las Ãºnicas raÃ­ces primitivas son 3 y 5.

5.2

Calcule las raÃ­ces primitivas de mÃ³dulo 71.

5.3 Muestre que si b es raÃ­z primitiva mÃ³dulo p y b â‰¡ c (mod p), entonces c es raÃ­z primitiva
mÃ³dulo p.
5.4 Sea p = 2n + 1. Verifique que si p es primo, entonces n es par Ayuda: Solamente puede
pasar p â‰¡ 2 (mod 3). Ahora use logaritmo discreto.
5.5

Verifique que no hay raÃ­ces primitivas mÃ³dulo 8.

5.6

Verifique que 8 no es raÃ­z primitiva mÃ³dulo 13.

5.7

Â¿Hay raÃ­ces primitivas en Z12 ?

5.8

Calcule las raÃ­ces primitivas de Z11

5.9 Si p es primo y t un entero, muestre que si en Z p hay elementos de orden t, entonces hay
exactamente Ï•(t) elementos de este orden.
5.10 Sea p primo y Ord p ( a) = t. Muestre que si b âˆˆ Z p y bt â‰¡ 1 (mod p), entonces b debe ser
una potencia de a.
5.11
5.12

Construya una tabla para el logaritmo discreto en base 11
Resolver
a) 7x â‰¡ 13 (mod 18)
b) 2x4 â‰¡ 5 (mod 13)
c) 85x â‰¡ 5 (mod 13)

102

RAIÌCES PRIMITIVAS Y LOGARITMO DISCRETO

d) 34x+1 â‰¡ 10 (mod 19)
e) 8x2 â‰¡ 2 (mod 13) . Sugerencia: x â‰¡ 2Ind2 ( x) (mod 13) con Ind2 ( x ) â‰¡ 5 (mod 6) y Ind2 ( x ) âˆˆ
{1, 2, ..., 12} .
5.13

Sea m = m1 m2 con mcd (m1 , m2 ) = 1 y mi â‰¥ 3.
a) Muestre que si m â‰¥ 3 , Ï•(m) es par
b) Sea n = Ï•(m1 ) Ï•(m2 )/2 y mcd ( a, m) = mcd ( a, m1 ) = mcd ( a, m2 ) = 1. Muestre que
a Ï•(m1 ) Ï•(m2 )/2 â‰¡ 1 (mod m1 ) y que a Ï•(m2 ) Ï•(m1 )/2 â‰¡ 1 (mod m2 )
c) Muestre que an â‰¡ 1 (mod m)

5.14

Usar logaritmo discreto para encontrar el residuo de dividir 231001 por 13.

EJERCICIOS

103

VersiÃ³n actualizada de este libro: https://tecdigital.tec.ac.cr/revistamatematica/Libros/

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

235711
131719
232931
235711

6
6.1

RESIDUOS
CUADRÃTICOS

Congruencias cuadrÃ¡ticas mÃ³dulo m

DefiniciÃ³n 6.1
Una congruencia cuadrÃ¡tica es una congruencia de la forma
x2 â‰¡ a (mod m)
donde mcd ( a, n) = 1. Si la congruencia tiene soluciÃ³n, a es llamado residuo cuadrÃ¡tico mÃ³dulo
m.
Ejemplo 6.1
Calcular los residuos cuadrÃ¡ticos mÃ³dulo 7.
SoluciÃ³n: Una manera directa es hacer una tabla de cuadrados,
b
Residuo rem(b2 , 7)

1
1

2
4

3
2

4
2

5
4

6
1

â†âˆ’ residuos cuadrÃ¡ticos

Tabla 6.1. Residuos cuadrÃ¡ticos mÃ³dulo 7

Tenemos,
12 â‰¡ 62
22 â‰¡ 52
32 â‰¡ 42

â‰¡ 1 (mod 7)
â‰¡ 4 (mod 7) =â‡’ 1, 2, 4 son residuos cuadrÃ¡ticos mod 7.
â‰¡ 2 (mod 7)

La congruencia Ax2 + Bx + C â‰¡ 0 (mod p) . Observemos que si p es primo y p - A; la congruencia Ax2 + Bx + C â‰¡ 0 (mod p) es equivalente a (2Ax + B)2 â‰¡ B2 âˆ’ 4AC (mod p) (ver ejercicios),
o lo que es lo mismo, u2 â‰¡ a (mod p) con u = 2Ax + B y a = B2 âˆ’ 4AC.
RepresentaciÃ³n simÃ©trica. En principio podemos decidir si la congruencia x2 â‰¡ a (mod p)
tiene soluciÃ³n o no, por ensayo y error. La teorÃ­a que sigue estÃ¡ orientada a buscar respuestas
a preguntas como Â¿cuÃ¡ndo es soluble o no, esta congruencia?, si es soluble, Â¿cuÃ¡ntas soluciones
tiene mÃ³dulo p?. La teorÃ­a requiere trabajar con la representaciÃ³n simÃ©trica de Z p .

Zp =


ï£± 
pâˆ’1
pâˆ’1
ï£´
ï£´
,
...,
âˆ’
1,
0,
1,
...
âˆ’
ï£´
ï£´
2
2
ï£²

si p es impar



ï£´
ï£´
pâˆ’1
pâˆ’1
ï£´
ï£´
ï£³ âˆ’
+ 1, ..., âˆ’1, 0, 1, ...
2
2

si p es par

En las aplicaciones, el caso comÃºn es cuando p es impar. La regla de conversiÃ³n para pasar de
{0, 1, ..., p âˆ’ 1} a representaciÃ³n simÃ©trica es sencilla:
ï£±
ï£´
ï£´
ï£´
ï£²

âˆ’â†’ i

i

ï£´
ï£´
ï£´
ï£³ pâˆ’1 +k
2

âˆ’â†’ âˆ’

si 0 â‰¤ i â‰¤
pâˆ’1
+kâˆ’1
2

pâˆ’1
,
2

con 1 â‰¤ k â‰¤

pâˆ’1
.
2

Ejemplo 6.2
Consideremos Z7 ,

pâˆ’1
= 3.
2
0,
â†“
0,

1,
â†“
1,

2,
â†“
2,

3,
â†“
3,

4,
â†“
âˆ’3,

5,
â†“
âˆ’2,

6
â†“
âˆ’1

Si volvemos a calcular como en el ejemplo (6.1), pero esta vez usando la representaciÃ³n simÃ©trica,
se nos harÃ¡ evidente nuestro siguiente teorema,
b
rem(b2 , 7)

âˆ’3
2

âˆ’2
4

âˆ’1
1

1
1

2
4

3
2

â†âˆ’ residuos cuadrÃ¡ticos mod 7

Tabla 6.2. Residuos cuadrÃ¡ticos mÃ³dulo 7

Tenemos,

(âˆ’1)2 â‰¡ 12
(âˆ’2)2 â‰¡ 22
(âˆ’3)2 â‰¡ 32

â‰¡ 1 (mod 7)
â‰¡ 4 (mod 7)
â‰¡ 2 (mod 7)

Teorema 6.1
Sea p primo impar y mcd ( a, p) = 1.
a.) x2 â‰¡ a (mod p) no tiene soluciÃ³n o tiene exactamente dos soluciones mod p,
b.) Hay exactamente
y



pâˆ’1
pâˆ’1 2
residuos cuadrÃ¡ticos rem(12 , p), rem(22 , p), ..., rem(
, p)
2
2

pâˆ’1
residuos no cuadrÃ¡ticos.
2

105

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

106

RESIDUOS CUADRÃTICOS

Prueba: a.) Si x2 â‰¡ a (mod p) y y2 â‰¡ a (mod p) entonces p| x2 âˆ’ y2 =â‡’ p| x + y âˆ¨ p| x âˆ’ y =â‡’
x â‰¡ Â±y (mod p).
b.) Sea Z p = {âˆ’( p âˆ’ 1)/2, ..., âˆ’1, 0, 1, ..., ( p âˆ’ 1)/2}. Entonces tenemos ( p âˆ’ 1)/2 residuos cuadrÃ¡ticos a j con (âˆ’ j)2 = j2 â‰¡ a j (mod p), âˆ’( p âˆ’ 1)/2 â‰¤ j â‰¤ ( p âˆ’ 1)/2 y j 6= 0. Claramente son residuos
cuadrÃ¡ticos distintos pues si i 6â‰¡ j (mod p) entonces i2 6â‰¡ j2 (mod p) si i, j âˆˆ {1, ..., ( p âˆ’ 1)/2}
(ya que 0 < |i âˆ’ j| < i + j < p âˆ’ 1 ). Hay exactamente ( p âˆ’ 1)/2 residuos cuadrÃ¡ticos pues ya
agotamos los cuadrados en Z p .

En el caso p = 2 el teorema no aplica: sÃ³lo hay un residuo cuadrÃ¡tico mÃ³dulo 2 : 12 â‰¡ 1 (mod 2).

6.2

Criterio de Euler

Euler divisÃ³ un criterio sencillo, para decidir si un nÃºmero es residuos cuadrÃ¡tico mÃ³dulo p. El
criterio no es muy prÃ¡ctico computacionalmente pero si de gran valor teÃ³rico.
La idea es la siguiente: Si a es residuo cuadrÃ¡tico mÃ³dulo p, hay un entero x tal que a â‰¡ p x2 ,
entonces, por el teorema pequeÃ±o de Fermat se tiene
a( pâˆ’1)/2 â‰¡ ( x2 )( pâˆ’1)/2 â‰¡ x pâˆ’1 â‰¡ 1 (mod p),
es decir, si a es residuo cuadrÃ¡tico mÃ³dulo p,
a( pâˆ’1)/2 â‰¡ 1 (mod p).
Ejemplo 6.3
Sea p = 11. Vamos a calcular todas las potencias a( pâˆ’1)/2 mÃ³dulo p en representaciÃ³n
estÃ¡ndar y en representaciÃ³n simÃ©trica,
a
Residuo rem( a( pâˆ’1)/2 , p)
Residuo rems ( a( pâˆ’1)/2 , p)

1
1
1

2
10
âˆ’1

3
1
1

4
1
1

5
1
1

6
10
âˆ’1

7
10
âˆ’1

8
10
âˆ’1

9
1
1

10
10
âˆ’1

â† estÃ¡ndar
â† simÃ©trica

Teorema 6.2 (Criterio de Euler).
Sea p primo impar y mcd ( a, p) = 1, entonces
a.)
b.)

a es residuo cuadrÃ¡tico
a no es residuo cuadrÃ¡tico

â‡â‡’ a( pâˆ’1)/2 â‰¡ 1 (mod p),
â‡â‡’ a( pâˆ’1)/2 â‰¡ âˆ’1 (mod p),

Prueba: Para la demostraciÃ³n usamos el teorema pequeÃ±o de Fermat y logaritmo discreto.
La parte a.) requiere probar dos dos direcciones,
IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

107

â€ =â‡’ â€ Si a es un residuo cuadrÃ¡tico mÃ³dulo p, existe x âˆˆ Z tal que x2 â‰¡ a (mod p.) Como
mcd( a, p) = 1 entonces mcd( x2 , p) = 1. Ahora aplicamos el teorema pequeÃ±o de Fermat,
1

â‰¡ x pâˆ’1 (mod p)
â‰¡ ( x2 )( pâˆ’1)/2 (mod p)
â‰¡ a( pâˆ’1)/2 (mod p)

â€ â‡= â€ Si a( pâˆ’1)/2 â‰¡ 1 (mod p), sea b una raÃ­z primitiva de p (todos los primos tienen raÃ­ces
primitivas) y sea t âˆˆ Z tal que a â‰¡ bt (mod p). Entonces,

bt
bt( pâˆ’1)/2

=â‡’

â‰¡ a (mod p)
â‰¡ a( pâˆ’1)/2 â‰¡ 1 (mod p)

=â‡’ Indb (bt( pâˆ’1)/2 ) â‰¡ Indb (1) â‰¡ 0 (mod p)
=â‡’

t( p âˆ’ 1)/2

=â‡’

t ( p âˆ’ 1)

=â‡’



bt/2

2

â‰¡ 0 (mod ( p âˆ’ 1))
= 2k( p âˆ’ 1), k âˆˆ Z, i.e. t es par.
= bt â‰¡ a (mod p), i.e. a es residuo cuadrÃ¡tico mÃ³dulo p.

b.). Para probar esta parte se suficiente observar que, por el PequeÃ±o Teorema de Fermat,

( a( pâˆ’1)/2 âˆ’ 1)( a( pâˆ’1)/2 + 1) = a pâˆ’1 âˆ’ 1 â‰¡ 0 (mod p).
Como p es primo, no hay divisores de cero en Z p , por lo que si a no es residuo cuadrÃ¡tico
mÃ³dulo p, la Ãºnica opciÃ³n que queda es a( pâˆ’1)/2 â‰¡ âˆ’1 (mod p). La otra implicaciÃ³n es consecuencia de la parte a.)

El criterio de Euler, en su versiÃ³n cruda, es Ãºtil en el cÃ¡lculo directo si p es pequeÃ±o, dado que
tenemos que calcular la potencia a( pâˆ’1)/2 .

Ejemplo 6.4
Â¿Es a = 72 residuo cuadrÃ¡tico mÃ³dulo 229 ?
SoluciÃ³n: Tenemos que calcular rem(72114 , 229). Para simplificar el cÃ¡lculo descomponemos en potencias de 2,
72114 = 722 Â· ((((722 )2 )2 )2 )7 â‰¡ 228 â‰¡ âˆ’1 mod 229; no es residuo cuadrÃ¡tico.

108

RESIDUOS CUADRÃTICOS

Ejemplo 6.5
Sea p primo impar. Muestre que si b es raÃ­z primitiva mÃ³dulo p, entonces b no es
residuo cuadrÃ¡tico mÃ³dulo p.
SoluciÃ³n: Como Ord p (b) = p âˆ’ 1, entonces b( pâˆ’1)/2 6â‰¡ 1 (mod p) y por el criterio de Euler, la Ãºnica posibilidad es que b( pâˆ’1)/2 â‰¡ âˆ’1 (mod p), es decir, b no es residuo cuadrÃ¡tico
mÃ³dulo p.

6.3

SÃ­mbolos de Legendre y Jacobi

El sÃ­mbolo de Legendre nos permite establecer si un nÃºmero a es o no es residuo cuadrÃ¡tico
mÃ³dulo un primo p, mediante un cÃ¡lculo automÃ¡tico. La ley de la reciprocidad cuadrÃ¡tica, una
de las joyas de la teorÃ­a de nÃºmeros, simplifica notablemente este cÃ¡lculo.
El sÃ­mbolo de Jacobi es una generalizaciÃ³n del sÃ­mbolo de Legendre que permite una simplificaciÃ³n del cÃ¡lculo cuando el mÃ³dulo no es primo.
Los estudios en residuos cuadrÃ¡ticos de Euler fueron extendidos por Legendre. El sÃ­mbolo de
Legendre nos proporciona una serie de reglas para el cÃ¡lculo automÃ¡tico. Estas reglas en el
fondo, son aplicaciones simplificadas del criterio de Euler.

DefiniciÃ³n 6.2
 
a
Sea p un primo impar y mcd ( a, p) = 1. El sÃ­mbolo de Legendre
es definido por,
p
ï£±
  ï£²
a
=
ï£³
p

1

âˆ’1

si a residuo cuadrÃ¡tico mÃ³dulo p
si a no es residuo cuadrÃ¡tico mÃ³dulo p

En algunos textos se usa una definiciÃ³n alternativa: Si p es primo impar,

ï£±
  ï£²
a
=
ï£³
p

1
0
âˆ’1

si a residuo cuadrÃ¡tico mÃ³dulo p
si p| a
si a no es residuo cuadrÃ¡tico mÃ³dulo p

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

109

Ejemplo 6.6
     
 
1
2
4
3
Los residuos cuadrÃ¡ticos de Z7 son 1, 2, 4, es decir,
=
=
=1 y
=
7
7
7
7
   
6
5
=
= âˆ’1
7
7
Para el cÃ¡lculo del sÃ­mbolo de Legendre es necesario establecer las siguientes propiedades,

Teorema 6.3
Sea p primo impar y mcd( p, a) = mod( p, b) = 1. Entonces,

a.)
b.)
c.)
d.)
e.)

 
a
= rems ( a( pâˆ’1)/2 , p) (rems es el residuo en representaciÃ³n simÃ©trica).
p
 
 2
1
a
= 1. En particular
= 1.
p
p
   
  

a
b
a
rem( a, p)
Si a â‰¡ b (mod p) entonces
=
, En particular,
=
.
p
p
p
p
    
ab
a
b
=
.
p
p
p



âˆ’1
1
si p â‰¡ 1 (mod 4)
(
p
âˆ’
1
)
/2
= (âˆ’1)
=
âˆ’1
si p â‰¡ âˆ’1 (mod 4)
p

Prueba: El item a.) es el criterio de Euler: a( pâˆ’1)/2 â‰¡ 1 (mod p) o a( pâˆ’1)/2 â‰¡ âˆ’1 (mod p). Entonces
rems ( a( pâˆ’1)/2 , p) = Â±1 y el signo depende de que a sea residuo cuadrÃ¡tico o no.

( a2 ,

a2



a2
p

â‰¡ r a (mod p), es decir,
   
b
a
(
p
âˆ’
1
)
/2
(
p
âˆ’
1
)
/2
=
.
c.): a â‰¡ b (mod p) =â‡’ a
â‰¡b
(mod p). Luego, por a.),
p
p
b.): Sea r a = rems

p). Entonces mcd (r a , p) = 1 y



= 1.

d.): Como a( pâˆ’1)/2 â‰¡ Â±1 (mod p) y b( pâˆ’1)/2 â‰¡ Â±1 (mod p), entonces ( ab)( pâˆ’1)/2 â‰¡ Â±1 (mod p)
y entonces el signo de rems (( ab)( pâˆ’1)/2 , p) = Â±1 depende de los signos de rems ( a( pâˆ’1)/2 , p) y
rems (b( pâˆ’1)/2 , p) por separado. En resumen, aplicando a.),



ab
p



=

rems (( ab)( pâˆ’1)/2 , p)

=

rems ( a( pâˆ’1)/2 b( pâˆ’1)/2 , p)

=

  
a
b
p
p

110

RESIDUOS CUADRÃTICOS

e.): Por a.)



âˆ’1
p



â‰¡ rems ((âˆ’1)( pâˆ’1)/2 , p) = (âˆ’1)( pâˆ’1)/2 (en representaciÃ³n simÃ©trica)

Ahora, como p âˆˆ Z4 y p es primo impar, entonces las Ãºnicas posibilidades son: p â‰¡ 1 (mod 4)
o p â‰¡ 3 (mod 4). Si p = 4k + 1 para algÃºn entero k, ( p âˆ’ 1)/2 = 2k = par. Si p = 4k âˆ’ 1 para
algÃºn entero k, ( p âˆ’ 1)/2 = 2k âˆ’ 1 = impar. Por lo tanto,


âˆ’1
p





=

si p â‰¡ 1 (mod 4)
si p â‰¡ âˆ’1 (mod 4)

1
âˆ’1

Corolario 6.1 Sea p primo impar,
a.) Sea mcd (n, p) = 1. Si n = âˆik=1 pi i es la descomposiciÃ³n prima de n,
Î±

âˆik=1 pi i
p
Î±

!

k

=âˆ

i =1



pi
p

 Î±i

b.) El producto de dos residuos cuadrÃ¡ticos mÃ³dulo p es residuo cuadrÃ¡tico mÃ³dulo p.
c.) El producto de dos residuos no cuadrÃ¡ticos mÃ³dulo p es residuo cuadrÃ¡tico mÃ³dulo p.
d.) El producto de un residuo cuadrÃ¡tico y otro no cuadrÃ¡tico mÃ³dulo p, es un residuo no cuadrÃ¡tico
mÃ³dulo p.
Prueba: Ejercicio.

Ejemplo 6.7
 
2
= rems (2(5âˆ’1)/2 , 5) = rems (4, 5) = âˆ’1 por el teorema 6.3 a.).
5

Ejemplo 6.8
El criterio de Euler, bajo el sÃ­mbolo de Legendre, nos da un criterio rÃ¡pido para decidir
si a = âˆ’1 es o no es residuo cuadrÃ¡tico mÃ³dulo p.


âˆ’1
a.) a = âˆ’1 no es residuo cuadrÃ¡tico mÃ³dulo 3 pues
= (âˆ’1)(3âˆ’1)/2 = âˆ’1
3

111


b.) a = âˆ’1 es residuo cuadrÃ¡tico mÃ³dulo 229 pues

âˆ’1
229



= (âˆ’1)(229âˆ’1)/2 = (âˆ’1)114 = 1.

Ejemplo 6.9
En este ejemplo vamos a aver como se aplican algunas de las propiedades del sÃ­mbolo
de Legendre.

a.) Â¿Es 10 residuo cuadrÃ¡tico del primo 3 ?

SoluciÃ³n:

âˆ’10
3





=

âˆ’1
3



10
3



 
1
=
= âˆ’1 por el teorema (6.3), c.).
3

b.) Â¿Es 63 residuo cuadrÃ¡tico del primo 11 ?
SoluciÃ³n:



63
11





=


=


=

8
11



2
11



2
11



por (6.3), c.)
22
11


por (6.3), d.)

Â·1

= âˆ’1 Â· 1

por (6.3), a.)
por cÃ¡lculo directo.

por tanto 63 no es residuo cuadrÃ¡tico mÃ³dulo 11.

Ejemplo 6.0 (continuaciÃ³n).
c.) Â¿Es 72 residuo cuadrÃ¡tico del primo 229 ?
SoluciÃ³n: Por el corolario (6.1),


72
229





=

23 Â· 32
229





=

2
229

3 

3
229

2



=1Â·

2
229



Â· 1 = âˆ’1

112

RESIDUOS CUADRÃTICOS

Ejemplo 6.10
Probar que hay una cantidad infinita de primos de la forma 4k + 1.
SoluciÃ³n: Por contradiccÃ³n, supongamos que solo hay una cantidad finita
P = { p1 , p2 , ..., ps } de primos de la forma 4k + 1. Sea N = (2p1 p2 Â· Â· Â· ps )2 + 1. Observemos que si pi âˆˆ P, N = k0 pi + 1, es decir, los pi â€™s no dividen N. Como N es de la
forma 4k + 1 y no es un pi , es compuesto. Entonces serÃ­a divisible por un primo p 6âˆˆ P.
Por tanto, âˆ’1 es residuo cuadrÃ¡tico mÃ³dulo p y p deberÃ­a ser de la forma 4k + 1.
ContradicciÃ³n.

6.3.1

Lema de Gauss

El lema de Gauss es una herramienta teÃ³rica que al igual que el criterio de Euler, nos provee de
mÃ©todo para calcular el sÃ­mbolo de Legendre vÃ­a un conteo de signos.
La idea es la siguiente: Si p es primo impar y mcd ( a, p) = 1, entonces
Z p = {0, a Â· 1, a Â· 2, ..., ( p âˆ’ 1) Â· a}
Los nÃºmeros a Â· 1, a Â· 2, ..., a Â·
sentaciÃ³n simÃ©trica, tenemos

pâˆ’1
son distintos mÃ³dulo p. Si consideramos Z p en repre2

pâˆ’1
} âŠ†
{ a Â· 1, a Â· 2, ..., a Â·
2



pâˆ’1
pâˆ’1
âˆ’
, ..., âˆ’1, 0, 1, ...,
2
2



Por ejemplo, si p = 13 y a = 3, tenemos

3Â·i
rem(3 Â· i, 13)

3Â·1
3

3Â·2
6

3Â·3
âˆ’4

3Â·4
âˆ’1

3Â·5
2

3Â·6
5

Tabla 6.3. RepresentaciÃ³n simÃ©trica de 3 Â· i, i = 1, ..., 6

En representaciÃ³n simÃ©trica los nÃºmeros aparecen con una copia positiva y otra negativa, es
decir, aparece el 1 y el âˆ’1, el 2 y el âˆ’2, etc. Pero, al pasar cada elemento del conjunto
{ a Â· i, i = 1, ..., ( p âˆ’ 1)/2} a representaciÃ³n simÃ©trica, solo aparece una copia: aparece el 1 o
el âˆ’1, el 2 o el âˆ’2, etc.
Ahora, sacando a factor comÃºn a y los signos, tenemos
a( pâˆ’1)/2 Â· 1 Â· 2 Â· Â· Â·

pâˆ’1
pâˆ’1
pâˆ’1
(âˆ’1)Ï‰ = a Â· 1 Â· a Â· 2 . . . a Â·
â‰¡ 1 Â· 2Â·Â·Â·
mod p,
2
2
2

por tanto, cancelando: a( pâˆ’1)/2 â‰¡ (âˆ’1)Ï‰ (mod p). AsÃ­, el nÃºmero Ï‰ de signos â€œâˆ’â€ en { aÂ·, a Â·
pâˆ’1
} define si a es residuo cuadrÃ¡tico o no.
2, ..., a Â·
2

113

Lema 6.1 (Lema de Gauss).
Sea p primo impar y mcd ( a, p) = 1. Si Ï‰ es la cantidad de enteros en el conjunto

{ a Â· 1 mod p, a Â· 2 mod p, ..., a Â·

pâˆ’1
mod p}
2

que son mÃ¡s grandes que ( p âˆ’ 1)/2 (negativos en representaciÃ³n simÃ©trica), entonces
 
a
= (âˆ’1)Ï‰
p
pâˆ’1
Â· a , p)}. En R no hay elementos con2
gruentes pues mcd ( a, p) = 1. Vamos a denotar con r1 , r2 , ..., rk los elementos de R que son
â‰¤ ( p âˆ’ 1)/2 y s1 , s2 , ..., sÏ‰ los elementos de R que son > ( p âˆ’ 1)/2. Por tanto, k + Ï‰ = ( p âˆ’ 1)/2.
Prueba: : Sea R = { rem( a, p), rem(2 Â· a, p), ..., rem(

Los ( p âˆ’ 1)/2 enteros r1 , r2 , ..., rk , p âˆ’ s1 , p âˆ’ s2 , ..., p âˆ’ sÏ‰ son positivos y â‰¤ ( p âˆ’ 1)/2. Todos
estos nÃºmeros son distintos mÃ³dulo p : En efecto, ya conocemos que r1 , r2 , ..., rk , s1 , s2 , ..., sÏ‰ son
distintos mÃ³dulo p, como si 6â‰¡ s j (mod p) entonces p âˆ’ si 6â‰¡ p âˆ’ s j (mod p). TambiÃ©n p âˆ’ si 6â‰¡
r j (mod p) si i 6= j, 1 â‰¤ i, j â‰¤ ( p âˆ’ 1)/2; para probarlo, supongamos que p âˆ’ si â‰¡ r j (mod p),
entonces âˆ’si â‰¡ r j (mod p) =â‡’ si + r j â‰¡ 0 (mod p) pero esto es imposible pues 0 < si + r j â‰¤
( p âˆ’ 1)/2. Esto demuestra que

{r1 , r2 , ..., rk , p âˆ’ s1 , p âˆ’ s2 , ..., p âˆ’ sÏ‰ } = {1, 2, ..., ( p âˆ’ 1)/2}.
Entonces
1 Â· 2 Â· Â· Â· ( p âˆ’ 1)/2

â‰¡ r1 Â· r2 Â· Â· Â· rk Â· ( p âˆ’ s1 ) Â· ( p âˆ’ s2 ) Â· Â· Â· ( p âˆ’ sÏ‰ ) (mod p)
â‰¡ r1 Â· r2 Â· Â· Â· rk Â· âˆ’s1 Â· âˆ’s2 Â· Â· Â· âˆ’ sÏ‰ (mod p), pues p â‰¡ 0
sacamos los Ï‰ signos â€œâˆ’â€ a factor comÃºn,

â‰¡ (r1 Â· r2 Â· Â· Â· rk Â· s1 Â· s2 Â· Â· Â· sÏ‰ )(âˆ’1)Ï‰ (mod p),
â‰¡ ( a Â· 1 Â· a Â· 2 Â· Â· Â· a Â· ( p âˆ’ 1)/2)(âˆ’1)Ï‰ (mod p),
sacamos a a factor comÃºn,

â‰¡ ( a( pâˆ’1)/2 (1 Â· 2 Â· Â· Â· ( p âˆ’ 1)/2)(âˆ’1)Ï‰ (mod p),
cancelamos,
1
a( pâˆ’1)/2

â‰¡ a

( pâˆ’1)/2

(âˆ’1)Ï‰ (mod p), es decir,

â‰¡ (âˆ’1)Ï‰ (mod p).

 
a
Ahora, por el criterio de Euler,
= (âˆ’1)Ï‰ .
p
Nota: En la prÃ¡ctica, en vez de contar los signos negativos, contamos los residuos rem( a Â· i, p) >
p/2. Usamos p/2 en vez de ( p âˆ’ 1)/2 pues
pâˆ’1
p
pâˆ’1
p+1
< <
+1=
.
2
2
2
2
El siguiente ejemplo ilustra el cÃ¡lculo. Recordemos que la importancia del lema es de orden
teÃ³rico no computacional.

114

RESIDUOS CUADRÃTICOS

Ejemplo 6.11
Â¿Es a = 63 residuo cuadrÃ¡tico mÃ³dulo p = 11 ?
SoluciÃ³n:
{63 Â· i, i = 1, ..., 5} = {8, 5, 2, 10, 7}. Hay Ï‰ = 3 nÃºmeros > Jp/2K = 5. Por tanto
 
63
= (âˆ’1)3 = âˆ’1. âˆ´ 63 no es residuo cuadrÃ¡tico mÃ³dulo 11.
11
Ya sabemos cÃ³mo decidir si Â±1 es residuo cuadrÃ¡tico mÃ³dulo p. Podemos aplicar el lema de
Gauss para decidir si 2 es residuo cuadrÃ¡tico mÃ³dulo p.

Teorema 6.4
Si p es primo impar, entonces
 

2
2
1
= (âˆ’1)( p âˆ’1)/8 =
âˆ’1
p
En particular, si a es par,

si p â‰¡ Â±1 (mod 8)
si p â‰¡ Â±3 (mod 8)

(6.1)



 
a/2
a
2
= (âˆ’1)( p âˆ’1)/8
.
p
p

 
2
contamos los nÃºmeros en {2 Â· i, i = 1, ..., ( p âˆ’ 1)/2} tales que 2 Â· i >
p
p/2, es decir, i > p/4 (aquÃ­ no hay que hacer reducciÃ³n mÃ³dulo p pues 0 â‰¤ 2i â‰¤ p âˆ’ 1 ). Entonces 2i > p/2 si Jp/4K < i â‰¤ ( p âˆ’ 1)/2. Por lo tanto,

Prueba: Para calcular

Ï‰=

p âˆ’ 1 r pz
âˆ’
.
2
4

Esto nos da
r pz
 
(
p âˆ’ 1)/2 âˆ’
2
4
= (âˆ’1)
p
q py
AquÃ­ lo que interesa es saber si ( p âˆ’ 1)/2 âˆ’ 4 es par o impar, asÃ­ que hacemos una reducciÃ³n
mÃ³dulo 2 :
p âˆ’ 1 r p z p2 âˆ’ 1
â‰¡
âˆ’
(mod 2).
(6.2)
2
4
8
Para probar esto Ãºltimo usamos el hecho de que, como p es primo impar, âˆƒ k âˆˆ Z tal que
p = 8k + r con r = 1, âˆ’1, 3 o âˆ’3. Luego,
ï£±
ï£´
ï£´
ï£²

2k
2k âˆ’ 1
=
ï£´
2k
4
ï£´
ï£³
2k âˆ’ 1

r pz

si
si
si
si

r=1
r = âˆ’1
r=3
r = âˆ’3

En estos cuatro casos se cumple (6.2) y ademÃ¡s si r = Â±1,
impar.

p2 âˆ’ 1
p2 âˆ’ 1
es par y si r = Â±3,
es
8
8

115

AquÃ­ solo vamos a probar los casos r = 3 y r = âˆ’1, los otros casos son similares.
Si p = 8k + 3, entonces
p âˆ’ 1 r pz
= 1 + 4k âˆ’ 2k = 1 + 4k â‰¡ 1 (mod 2)
âˆ’
2
4
p2 âˆ’ 1
= 1 + 6k + 8k2 â‰¡ 1 (mod 2). Esto prueba (6.2) para este caso.
8
 
p2 âˆ’ 1
2
2
Como
es impar,
= (âˆ’1)( p âˆ’1)/8 = âˆ’1 si p â‰¡ 3 (mod 8)
8
p
Si p = 8k âˆ’ 1, entonces
p âˆ’ 1 r pz
= 4k âˆ’ 1 âˆ’ (2k âˆ’ 1) = 2k â‰¡ 0 (mod 2)
âˆ’
2
4
p2 âˆ’ 1
= âˆ’2k + 8k2 â‰¡ 0 (mod 2). Esto prueba (6.2) para este caso.
8
 
2
p2 âˆ’ 1
2
es par,
Como
= (âˆ’1)( p âˆ’1)/8 = 1 si p â‰¡ âˆ’1 (mod 8).
8
p

La idea de la congruencia es muy Ãºtil: es mÃ¡s fÃ¡cil verificar la congruencia que calcular la potencia.
Ejemplo 6.12
a.) Â¿Es 2 residuo cuadrÃ¡tico mÃ³dulo 97 ?

SoluciÃ³n: SÃ­,

2
97



= 1 pues 97 â‰¡ 1 (mod 8)

b.) Â¿Es 2 residuo cuadrÃ¡tico mÃ³dulo 229 ?

SoluciÃ³n: No,

6.3.2

2
97



= âˆ’1 pues 229 â‰¡ 3 (mod 8)

Ley de Reciprocidad CuadrÃ¡tica.

   
p
q
La ley de reciprocidad cuadrÃ¡tica establece una sorprendente relaciÃ³n entre
y
. Esta
q
p
ley fue conjeturada, basÃ¡ndose en evidencia numÃ©rica, por Euler en 1783 y Lagrange en 1785.
Legendre le dio la forma actual a esta ley, pero no pudo dar una prueba completa. La primera
prueba rigurosa fue dada por Gauss en a la edad de 18 aÃ±os. Hasta el 2004 se conocÃ­an 190

116

RESIDUOS CUADRÃTICOS

pruebas diferentes. Gauss llamÃ³ a este teorema â€œAureum Theoremaâ€. Su importancia en la teorÃ­a
de nÃºmeros no tienen discusiÃ³n. Al respecto, Hecke afirmÃ³ al respecto: â€œLa teorÃ­a de nÃºmeros
moderna comenzÃ³ con el descubrimiento de la Ley de Reciprocidad CuadrÃ¡ticaâ€.
La prueba del teorema sigue es la tercera prueba que dio Gauss. La prueba se basa e un argumento geomÃ©trico.
s
{
4Â·q
Primero veamos un ejemplo concreto. Sea p = 11 y q = 7. El nÃºmero
= 2 cuenta la
p
4Â·q
cantidad de nÃºmeros â‰¤
. GeomÃ©tricamente corresponde a la cantidad de pares ordenados
p
con componentes enteros (llamados punto reticulares) sobre la parte positiva de la recta x = 4 y
4Â·q
q
.
por debajo de la recta y = x. Estos puntos son de la forma (4, y) con y â‰¤
p
p

}
1

2

3

4

5

Tabla 6.4. Puntos reticulares (4, y) con y â‰¤ 4 Â·
11/7

La suma

( pâˆ’1)/2 s

âˆ‘

k =1

kÂ·q
p

{

1

2

3

4

Tabla 6.5. Puntos reticulares en ABCD

= 7 corresponde a los puntos reticulares en el polÃ­gono ABCD de la

figura (6.5).
Podemos cambiar el punto
s
{de vista y ver las cosas desde el eje Y de una manera totalmente
3Â· p
3Â· p
simÃ©trica: El nÃºmero
= 4 cuenta la cantidad de nÃºmeros â‰¤
. GeomÃ©tricamente corq
q
responde a la cantidad de de puntos reticulares sobre la parte derecha de la recta y = 3 y por
p
3Â· p
debajo de la recta x = y. Estos puntos son de la forma ( x, 3) con x â‰¤
.
q
q
{
(qâˆ’1)/2 s
kÂ·p
La suma âˆ‘
= 8 corresponde a los puntos reticulares en el polÃ­gono APQR de la
q
k =1
figura (6.1).

117

3

2

1

4

Figura 6.1. Puntos reticulares en APQR

Finalmente, la figura (6.1) tambiÃ©n nos sugiere que
( pâˆ’1)/2 s

âˆ‘

k =1

kÂ·q
p

{

+

(qâˆ’1)/2 s

âˆ‘

k =1

kÂ·p
q
s

{

= 7 + 8 = 15 =
{

qâˆ’1
. La prueba se puede hacer de
2
s
{
p qâˆ’1
manera directa y estÃ¡ en los ejercicios. Note que, por simetrÃ­a, si q > p, entonces
=
q 2
pâˆ’1
.
2
Observemos ademÃ¡s, que si p > q entonces

q pâˆ’1
p 2

pâˆ’1 qâˆ’1
Â·
2
2

=

Ahora que hemos establecido el significado geomÃ©trico de estas sumas, consideremos el siguiente lema,

Lema 6.2
Sean p, q primos impares distintos. Entonces,
( pâˆ’1)/2 s

âˆ‘

k =1

kÂ·q
p

{

+

(qâˆ’1)/2 s

âˆ‘

k =1

kÂ·p
q

{

=

pâˆ’1 qâˆ’1
Â·
2
2

Prueba: Sea p > q. El nÃºmero Jk Â· q/pK cuenta la cantidad de nÃºmeros â‰¤ (k Â· q)/p. GeomÃ©tricamente corresponde a la cantidad de puntos reticulares sobre la parte positiva de la recta x = k y
por debajo de la recta y = q/p x. Estos puntos son de la forma (k, y) con y â‰¤ k Â· q/p.
Cuando x = ( p âˆ’ 1)/2, la cantidad de puntos es y = (q âˆ’ 1)/2 pues
qâˆ’1
q pâˆ’1
qâˆ’1
â‰¤
<
+ 1.
2
p 2
2
( pâˆ’1)/2

La suma S( p, q) =

âˆ‘

k =1

de la figura (6.2).

Jk Â· q/pK corresponde a la suma de los puntos reticulares en el polÃ­gono ABCD

118

RESIDUOS CUADRÃTICOS

...

...

...

...

...
...

Figura 6.2. Puntos reticulares
(qâˆ’1)/2

De manera simÃ©trica, la suma S(q, p) =

âˆ‘

k =1

Jk Â· p/qK corresponde a la suma de los puntos

reticulares en el polÃ­gono APQR de la figura (6.2).
Hay que notar que no hay puntos reticulares sobre la recta y =

q
x pues mcd ( p, q) = 1.
p

Finalmente, la suma de los puntos reticulares en el polÃ­gono ABCR se puede expresar de dos
pâˆ’1 qâˆ’1
formas:
Â·
y S(q, p) + S( p, q).
2
2

Teorema 6.5 (Ley de Reciprocidad CuadrÃ¡tica).
Sea p y q primos impares distintos. Entonces
  
p âˆ’1 q âˆ’1
p
q
= (âˆ’1) 2 2
q
p
 
 
p âˆ’1 q âˆ’1
p
q
En particular,
= (âˆ’1) 2 2
.
q
p
pâˆ’1
Â· q, p)}. Vamos a denotar con r1 , r2 , ..., rk
2
los elementos de R que son > p/2. Claramente

Prueba: Sea R = { rem(q, p), rem(2 Â· q, p), ..., rem(
los elementos de R que
 son
 â‰¤ p/2 y s1 , s2 , ..., sÏ‰
q
k + Ï‰ = ( p âˆ’ 1)/2 y
= (âˆ’1)Ï‰ .
p

Los elementos de R son todos distintos. Si i, j âˆˆ R y i 6= j, entonces i 6â‰¡ p âˆ’ j (mod p). AsÃ­, los
( p âˆ’ 1)/2 nÃºmeros r1 , r2 , ..., rk , p âˆ’ s1 , p âˆ’ s2 , ..., p âˆ’ sÏ‰ son todos distintos e inferiores a p/2, por
tanto estos nÃºmeros corresponden a los nÃºmeros 1, 2, ..., ( p âˆ’ 1)/2 en algÃºn orden. Entonces
k

âˆ‘ rk

i =1

( pâˆ’1)/2

Ï‰

+

âˆ‘ ( p âˆ’ si )

=

i =1

=

Por tanto,

âˆ‘

i

i =1

( p âˆ’ 1)( p + 1)
8

119

k

âˆ‘ ( p âˆ’ si ) =

i =1

Sea S( p, q) =

k

Ï‰

âˆ‘ rk +

i =1

( pâˆ’1)/2
Jk Â· q/pK ,
âˆ‘ k =1

S1 =

Ï‰

âˆ‘ rk + Ï‰p âˆ’ âˆ‘ si =

i =1

âˆ‘ik=1 rk

i =1

y S2 =

âˆ‘iÏ‰=1 si .

p2 âˆ’ 1
8

Con esta notaciÃ³n,

p2 âˆ’ 1
= S1 + Ï‰ Â· p âˆ’ S2
8

(6.3)

Por el algoritmo de la divisiÃ³n,
kq = Tkq/pU Â· p + tk con 0 â‰¤ tk < p.
Entonces,
( pâˆ’1)/2

âˆ‘

( pâˆ’1)/2

âˆ‘

kÂ·q=

k =1

k =1

( pâˆ’1)/2

Tkq/pU Â· p +

âˆ‘

tk .

k =1

Esto es,
( pâˆ’1)/2

qÂ·

âˆ‘

k

=

p Â· S( p, q) + S1 + S2

p2 âˆ’ 1
8

=

p Â· S( p, q) + S1 + S2

k =1

qÂ·

(6.4)

Ahora restando (6.3) con (6.4) obtenemos,
p2 âˆ’ 1
= p Â· (S( p, q) âˆ’ Ï‰ ) + 2S2
8
S( p,q)âˆ’Ï‰
S( p,q) = (âˆ’1)Ï‰ .
De aquÃ­ se sigue que S( p, q) âˆ’ Ï‰ 
es par.
 Por tanto, (âˆ’1)  = 1; es decir (âˆ’1)
q
q
= (âˆ’1)Ï‰ , entonces
= (âˆ’1)S( p,q) . De manera similar,
Pero, el lema de Gauss dice que
p
p
 
p
= (âˆ’1)S(q,p) . En conclusiÃ³n,
q
  
p
q
= (âˆ’1)S(q,p) Â· (âˆ’1)S( p,q)
q
p

( q âˆ’ 1) Â·

= (âˆ’1)

p âˆ’1 q âˆ’1
2 Â· 2

, por el lema de Gauss.

El corolario que sigue es una reformulaciÃ³n de la Ley de Reciprocidad CuadrÃ¡tica en tÃ©rminos
de congruencias.
Corolario 6.2 Sea p y q primos impares distintos. Entonces
ï£±  
p
ï£´
  ï£´
si p â‰¡ 1 (mod 4) o q â‰¡ 1 (mod 4)
ï£²
q
q
 
=
p
ï£´
p
ï£´
si p â‰¡ q â‰¡ 3 (mod 4)
ï£³
q
Prueba: Ejercicio.

120

RESIDUOS CUADRÃTICOS

Ejemplo 6.13
Â¿Es 152 residuo cuadrÃ¡tico mÃ³dulo 43 ?
SoluciÃ³n: 152 â‰¡ 23 (mod 43), entonces


153
43





=
=
=

=
=
=


23
43
 
43
, pues 43 â‰¡ 23 â‰¡ 3 (mod 4), (Corolario 6.2)
âˆ’
23
 
20
, pues 43 â‰¡ 20 (mod 23)
âˆ’
23
 
 2  
5
5
2
Â·
=âˆ’
âˆ’
23
23
23
 
23
âˆ’
pues 5 â‰¡ 1 (mod 4)
5
 
 
2
2
âˆ’
= âˆ’1 pues
= (âˆ’1)(25âˆ’1)/8 = 1.
5
5

Ejemplo 6.14
Muestre que si p = 2n + 1 es primo =â‡’ 3 es raÃ­z primitiva mÃ³dulo p .
SoluciÃ³n: p 6â‰¡1 (
mod 3) y, como p es primo, p 6â‰¡ 0 (mod 3). AsÃ­, p â‰¡ 2 (mod 3). Por
 p
2
n âˆ’1
=
tanto,
= âˆ’1. Ahora, por el criterio de Euler, 32 â‰¡ âˆ’1 (mod p) y tambiÃ©n
3
3
n
32 â‰¡ 1 (mod p). Sea ahora Ord p (3) = s, entonces s|2n â‡’ s = 2k con k â‰¤ n. Si k < n,
entonces
 k  2n âˆ’ k âˆ’1
n âˆ’1
1 â‰¡ 32
â‰¡ 32 â‰¡ âˆ’1 (mod p),
lo cual es una contradicciÃ³n. âˆ´ 3 es raÃ­z primitiva.

Ejemplo 6.15

Sea p primo > 3. Muestre que si p â‰¡ 1 (mod 4) y p â‰¡ 1 (mod 3) entonces
SoluciÃ³n: Por la Ley de Reciprocidad CuadrÃ¡tica,

 
3
=1
p

121

 
p âˆ’1 3âˆ’1  p 
p âˆ’1  p 
3
= (âˆ’1) 2 2
= (âˆ’1) 2
p
3
3
y como p = 4k + 1, entonces,
 
 p  p
3
=
.
= (âˆ’1)2k
p
3
3
Ahora, como p â‰¡ 1 (mod 3) entonces
     
3
1
p
=
=
=1
p
3
3

6.4

SÃ­mbolo de Jacobi.

El sÃ­mbolo de Jacobi es una extensiÃ³n del sÃ­mbolo de Legendre pero solo decide siun 
nÃºmero es
a
solo que
un residuo no cuadrÃ¡tico. La notaciÃ³n es la misma, el sÃ­mbolo de Jacobi se denota
m
esta vez m debe ser impar y mcd ( a, m) = 1. No hay peligro de confusiÃ³n pues si m es primo
impar, el sÃ­mbolo de Jacobi coincide con el sÃ­mbolo de Legendre. Si m no es primo, estamos en
el contexto del sÃ­mbolo de Jacobi.

DefiniciÃ³n 6.3 (SÃ­mbolo de Jacobi).
k

Sea m entero positivo impar con descomposiciÃ³n prima m =

âˆ pi i ,
e

y sea a entero tal que

i =1

mcd ( a, m) = 1. El sÃ­mbolo de Jacobi se define por
!
a
k   ei
a
a
=
=
âˆ pi
ei
k
m
p
âˆ i =1
i =1
i


En esta definiciÃ³n, formalmente

a
pi


corresponde al sÃ­mbolo de Legendre.

Ejemplo 6.16


2
15



  
2
2
=
= (âˆ’1)(âˆ’1) = 1 (aunque 2 no es residuo cuadrÃ¡tico mÃ³dulo 15!)
3
5

Si m es primo, el sÃ­mbolo de Jacobi coincide con el sÃ­mbolo de Legendre.
Si m no es primo, el sÃ­mbolo de Jacobi no decide si a es residuo cuadrÃ¡tico
m: 2
 mÃ³dulo

2
no es residuo cuadrÃ¡tico mÃ³dulo 15 pero, usando el sÃ­mbolo de Jacobi,
= 1.
15
IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

122

RESIDUOS CUADRÃTICOS

a
El sÃ­mbolo de Jacobi si decide residuos no cuadrÃ¡ticos. Si
= âˆ’1, a no es residuo
m
a
cuadrÃ¡tico mÃ³dulo m. Esto es asÃ­ pues si
= âˆ’1, entonces por definiciÃ³n, si m es
m
 
a
compuesto, hay un divisor primo impar pi de m tal que
= âˆ’1. Si suponemos que a
pi
es residuo cuadrÃ¡tico mÃ³dulo m tendrÃ­amos una contradicciÃ³n pues x2 â‰¡ a (mod m) =â‡’
x2 â‰¡ a (mod pi ).

El sÃ­mbolo de Jacobi simplifica el cÃ¡lculo del sÃ­mbolo de Legendre cuando a es compuesto
impar y p primo, como veremos mÃ¡s adelante.

Teorema 6.6 Propiedades del sÃ­mbolo de Jacobi
Sea m un entero positivo impar, a, b, n enteros con mcd ( a, m) = mcd (b, m) = 1 entonces,

a.)
b.)
c.)
d.)
e.)

 a   rem( a, m) 
=
m
m
    
ab
a
b
=
m
m
m
 2
 
a
1
= 1. En particular,
=1
m
m


âˆ’1
= (âˆ’1)(mâˆ’1)/2
m
 
2
2
= (âˆ’1)(m âˆ’1)/8
m

f.) Ley generalizada de reciprocidad cuadrÃ¡tica.
es impar y mcd (m, n) = 1

n
m

=

m
n

(âˆ’1)(mâˆ’1)(nâˆ’1)/4 si tambiÃ©n n

Ejemplo 6.17



391
corresponde al sÃ­mbolo de Legendre pues 439 es primo. Como
439
mcd (391, 439) = 1, podemos usar la ley generalizada de reciprocidad cuadrÃ¡tica
calculando como sÃ­mbolo de Jacobi.

EJERCICIOS



391
439



= (âˆ’1)

(439âˆ’1)(391âˆ’1)/4



439
391

123


(Reciprocidad cuadrÃ¡tica generalizada)

 



rem(439, 391)
48
439
=
=âˆ’
391
391
391
 2 





4
3
3
391
âˆ’
=âˆ’
= âˆ’(âˆ’1)(391âˆ’1)(3âˆ’1)/4
391
391
391
3
 
1
=1
3


= âˆ’1 Â·
=
=

EJERCICIOS
6.1
6.2
6.3

Calcule los residuos cuadrÃ¡ticos mÃ³dulo 9.
p âˆ’1  
a
Muestre que si p es primo impar, âˆ‘
=0
p
a =1
Use el sÃ­mbolo de Jacobi para verificar si 48 no es residuo cuadrÃ¡tico mÃ³dulo 391.

6.4 Use el sÃ­mbolo de Legendre para verificar que si q es el mÃ¡s pequeÃ±o residuo no cuadrÃ¡tico
mÃ³dulo p (primo impar), entonces q debe ser primo.


âˆ’1
= 1 â‡â‡’ p â‰¡ 1 (mod 4).
6.5 Muestre que
p
6.6 Sea p es primo impar. Muestre que p âˆ’ 1 es residuo cuadrÃ¡tico mÃ³dulo p, si y solo si
p â‰¡ 1 (mod 4). Ayuda: Verifique que si x2 â‰¡ p âˆ’ 1 (mod p), entonces x2 â‰¡ âˆ’1 (mod p).
 
a
6.7 Sea p es primo impar y
= 1. Muestre que p âˆ’ a es residuo cuadrÃ¡tico mÃ³dulo p, si
p
y solo si p â‰¡ 1 (mod 4).
a
a
6.8 Muestre que
= 1 si a â‰¡ Â±1 (mod 5), y
= âˆ’1 si a â‰¡ Â±2 (mod 5). Ayuda: recipro5
5
cidad cuadrÃ¡tica y reducciÃ³n mÃ³dulo 5.
Sea n > 1. Muestre que si p es factor primo de n2 + 1, entonces p â‰¡ 1 (mod 4).
 
a
6.10 Sea p es primo impar y
= 1. Muestre que p âˆ’ a es no es residuo cuadrÃ¡tico mÃ³dulo
p
p, si y solo si p â‰¡ 3 (mod 4).
 
a
6.11 Sea p primo impar. Muestre que si
= 1, entonces el inverso de a es residuo
p
cuadrÃ¡tico mÃ³dulo p.
6.9

6.12 Sea p primo y p - A. Si Ax2 + Bx + C â‰¡ 0 (mod p), muestre que (2Ax + B)2 â‰¡ B2 âˆ’
4AC (mod p) Ayuda: En Ax2 + Bx + C â‰¡ 0 (mod p) multiplique por 4A y agrupe.
6.13

Resolver la congruencia 3x2 âˆ’ 4x + 7 â‰¡ 0 (mod 13)

Muestre que 3x2 + 7x + 5 â‰¡ 0 (mod 13) no tiene soluciÃ³n.
p âˆ’ 1 r pz
p2 âˆ’ 1
6.15 Si p es primo impar, probar que
âˆ’
â‰¡
(mod 2) para los casos p =
2
4
8
8k + 1, p = 8k âˆ’ 3.
6.14

124

RESIDUOS CUADRÃTICOS

6.16 Sea p primo impar, mcd ( a, p) = 1 y b raÃ­z primitiva mÃ³dulo p. Sea a â‰¡ bs (mod p).
Muestre que si s es par, entonces a es residuo cuadrÃ¡tico; sino, a no es residuo cuadrÃ¡tico.
6.17
6.18
6.19
6.20
qâˆ’1
2
6.21
6.22

Usar el criterio de Euler para determinar si a = 54 es residuo cuadrÃ¡tico mÃ³dulo p = 97.
a
Â¿QuÃ© puede decir de
?
2
Â¿Es 2 residuo cuadrÃ¡tico mÃ³dulo 3181 ?
s
{
q pâˆ’1
qâˆ’1
. Ayuda: Muestre que
Sean p > q ambos primos impares. Muestre que
=
p 2
2
q pâˆ’1
qâˆ’1
â‰¤
<
+ 1.
p 2
2
Â¿Es 3797 residuo cuadrÃ¡tico mÃ³dulo 7297 ?


 
âˆ’1
1
Â¿
=âˆ’
?
17
17

 
3
6.23 Sea p primo > 3. Muestre que si p â‰¡ 3 (mod 4), entonces
= âˆ’1 si p â‰¡ 2 (mod 3).
p
Ayuda: Ley de Reciprocidad CuadrÃ¡tica.
 
3
6.24 Sea p primo impar.
= 1 si y solo si p â‰¡ 1 (mod 12).
p
6.25 Sea p primo impar. Muestre que la congruencia x2 + 3 â‰¡ 0 (mod p) tiene soluciÃ³n si y
solo si p es un primo de la forma 3h + 1.
6.26
6.27

Probar que x ( pâˆ’1)/2 â‰¡ 1 (mod p) tiene ( p âˆ’ 1)/2 soluciones mÃ³dulo p.
Sea p1 , ..., ps primos de la forma 8k + 7 y sea N = (4p1 p2 Â· Â· Â· ps )2 âˆ’ 2.
a) Probar, usando residuos cuadrÃ¡ticos, que los divisores primos impares de N tienen la
forma 8k + 1 o 8k + 7.
b) Probar que no todos los divisores primos impares de N tienen la forma 8k + 1
c) Probar que hay infinitos primos de la forma 8k + 7.

EJERCICIOS

125

VersiÃ³n actualizada de este libro: https://tecdigital.tec.ac.cr/revistamatematica/Libros/

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

235711
131719
232931
235711

7

ESTIMACIONES,
ESTADÃSTICAS Y
PROMEDIOS

El propÃ³sito de este capÃ­tulo es estudiar comportamiento â€œtÃ­picoâ€ de algunas funciones aritmÃ©ticas para tomar decisiones a la hora de crear heurÃ­sticas para resolver algÃºn problema. Por
ejemplo, nos interesa tener estimaciones para poder responder preguntas tales como: Â¿La mayorÃ­a de los nÃºmeros tienen factores primos pequeÃ±os?, Â¿Los nÃºmeros altamente compuestos son
escasos?, Â¿CuÃ¡l es el tamaÃ±o tÃ­pico del factor mÃ¡s grande de un nÃºmero?, etc.

7.1

Funciones AritmÃ©ticas

La funciÃ³n aritmÃ©tica Ï„ (n) cuenta cuÃ¡ntos divisores positivos, primos y compuestos, tiene n.
Por ejemplo, los divisores de 8 son 1, 2, 4; asÃ­ Ï„ (8) = 4. La funciÃ³n Ïƒ (n) es definida como la
suma de los divisores, tanto primos como compuestos, de n. Por ejemplo, Ïƒ(8) = 1 + 2 + 4 = 7.
Formalmente,
Ï„ (n) = âˆ‘ 1 y Ïƒ(n) = âˆ‘ d
d|n

d|n

Sea s(n) = Ïƒ (n) âˆ’ n, es decir, s(n) es la suma de divisores propios de n (a veces se usa el
arcaÃ­smo â€œparte alÃ­cuotaâ€ en vez de divisor propio). Decimos que un entero n es deficiente si
s(n) > n, es abundante si s(n) > n y que es perfecto si s(n) = n. Por ejemplo, s(8) = 7 < 8, asÃ­
que 8 es deficiente. s(12) = 16, asÃ­ 12 es abundante. Los divisores de 6 son 1, 2, 3 y 6, por tanto
s(6) = 1 + 2 + 3 + 6 âˆ’ 6 = 6, por tanto 6 es perfecto.
Ï„ y Ïƒ se calculan fÃ¡cil si n es potencia de un primo.
Lema 7.1
Sea p primo y n = pk , , entonces Ï„ (n) = k + 1 y Ïƒ (n) =

p k +1 âˆ’ 1
.
pâˆ’1

Prueba: Los divisores de d de pk son 1, p, p2 , ..., pk . Hay k + 1 divisores. La suma es
1 + p + p2 + ... + pk =

1 âˆ’ p k +1
p k +1 âˆ’ 1
=
1âˆ’ p
pâˆ’1

En el siguiente lema se muestra que Ï„ y Ïƒ son multiplicativas, esto nos permite calcular Ï„ y Ïƒ
si conocemos la descomposiciÃ³n prima de n.

Lema 7.2
Si mcd (m, n) = 1, entonces Ï„ (nm) = Ï„ (n)Ï„ (m) y Ïƒ (nm) = Ïƒ (n)Ïƒ (m)
Prueba: La a idea la podemos ver con un ejemplo: Sea n = 9 y n = 4, ambos son primos relativos.
Ahora, hacemos un arreglo rectangular como el que estÃ¡ a la izquierda de la tabla (7.1). Las
Ãºnicas filas en consideraciÃ³n son las filas que inician con un divisor de 9. Luego, solo marcamos
las entradas5 di Â· d j si di |9 y d j |4. Simplificando, lo que nos queda es un arreglo rectangular
Ï„ (9) Ï„ (4).

1
2
3
4
5
6
7
8
9

1
1Â·1

2
1Â·2

3Â·1

3Â·2

3

4
1Â·4
3Â·4

âˆ’â†’

9Â·1

9Â·2

1
3
9

1
1Â·1
3Â·1
9Â·1

2
1Â·2
3Â·2
9Â·2

4
1Â·4
3Â·4
9Â·4

9Â·4

Tabla 7.1. Si mcd (9, 4) = 1, entonces Ï„ (9 Â· 4) = Ï„ (9)Ï„ (4)

La prueba para Ïƒ(nm) es una modificaciÃ³n de la prueba de Ï„ (m)Ï„ (n). Solo necesitamos notar
que Ïƒ (nm) es la suma de todas las entradas de la tabla simplificada.
La prueba formal queda como ejercicio.

Teorema 7.1
k

Si la factorizaciÃ³n prima de n es p11 Â· p2k2 Â· Â· Â· pks s , entonces
s

Ï„ (n) = (k1 + 1)(k2 + 2) Â· Â· Â· (k s + 1) y Ïƒ (n) = âˆ

i =1

k

pi i âˆ’ 1
pi âˆ’ 1

k

Prueba: Como p11 , p2k2 , Â· Â· Â· , pks s son primos relativos dos a dos, entonces
   
 
k
Ï„ (n) = Ï„ p11 Â· Ï„ p2k2 Â· Â· Â· Ï„ pks s = (k1 + 1)(k2 + 2) Â· Â· Â· (k s + 1)
y similarmente para Ïƒ (n)

Ïƒ y Ï„ son ejemplos de funciones definidas sobre los nÃºmeros naturales. En vez de considerar
este tipo de funciones como objetos aislados, es de mucha ayuda verlas como objetos mÃ¡s generales y estudiar la relaciÃ³n entre ellas por medio de una operaciÃ³n â€œâˆ—â€ (llamada convoluciÃ³n).
5 Recordemos

que si mcd (m, n) = 1 y si d|mn, entonces d = ab con a|m y b|n .

127

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

128

ESTIMACIONES, ESTADËSTICAS Y PROMEDIOS

Una funciÃ³n f definida sobre los nÃºmeros naturales, se llama funciÃ³n aritmÃ©tica. Por ejemplo,
u(n)
N (n)

= 1 para todo n,
= n para todo n,

1
si n = 1
e(n) =
0
si n > 1

DefiniciÃ³n 7.1 (ConvoluciÃ³n).
Sean f y g funciones aritmÃ©ticas. La convoluciÃ³n de f y g, se denotada f âˆ— g, es una funciÃ³n
aritmÃ©tica definida por
f âˆ— g(n) = âˆ‘ f (d) g(n/d)
d|n

Como los divisores de n ocurren en pares (es decir, si d|n =â‡’ n = dk y entonces (n/d)|n),
podemos escribir
f âˆ— g(n) = âˆ‘ f (d) g(c)
c,d
n=cd

Ejemplo 7.1
Calcule N âˆ— u
SoluciÃ³n: N âˆ— u(n) =

âˆ‘

c,d
n=cd

N (d)u(c) = âˆ‘ d Â· 1 = Ïƒ(n)
d|n

Ejemplo 7.2
Calcule u âˆ— u
SoluciÃ³n: u âˆ— u(n) =

âˆ‘

c,d
n=cd

u(d)u(c) = âˆ‘ 1 = Ï„ (n)
d|n

Teorema 7.2
Sean f , g y h funciones aritmÃ©ticas, entonces
a.) f âˆ— g = g âˆ— f
b.) ( f âˆ— g) âˆ— h = f âˆ— ( g âˆ— h)
c.) f âˆ— e = f para cualquier funciÃ³n aritmÃ©tica f
Prueba: Ejercicio.

129

La funciÃ³n Âµ de MÃ¶bius se define asÃ­:
Âµ (1) = 1,
k

si n > 1 tiene factorizaciÃ³n prima n = p11 Â· p2k2 Â· Â· Â· pks s , entonces

Âµ (n) =

si k i > 1,
si k i = 1,

0
(âˆ’1)s

para algÃºn i = 1, 2, ..., s
para todo i = 1, 2, ..., s

AsÃ­, por ejemplo Âµ (2 Â· 3 Â· 13) = (âˆ’1)3 = âˆ’1 mientras que Âµ (2 Â· 32 Â· 13) = 0.
La funciÃ³n de MÃ¶bius es importante porque f = g âˆ— u â‡” g = f âˆ— Âµ . Esta es una fÃ³rmula muy
Ãºtil y se le llama fÃ³rmula de inversiÃ³n de MÃ¶bius.

Lema 7.3
Âµ âˆ— u = e, es decir,

âˆ‘Âµ ( d ) =
d|n



1
0

si n = 1,
si n > 1.

Prueba: Si n = 1, âˆ‘d|1 Âµ (d) = Âµ (1) = 1. Para probar el caso n > 1, empecemos con un ejemplo:
Si n = 3 Â· 53 Â· 7, los divisores de n que contribuyen con un sumando no nulo se pueden escribir
en pares, 3, 3 Â· 7, 3 Â· 5, 3 Â· 5 Â· 7, 5, 5 Â· 7. Los divisores se dividen en dos grupos de igual cardinalidad, los que son divisibles por 7 y los que no. Si d es divisor del primer grupo, d Â· 7
es divisor del segundo grupo. Observemos que Âµ (d) = âˆ’Âµ (d Â· 7), por tanto la suma cancela:
âˆ‘d|n Âµ (d) = Âµ (3) + Âµ (3 Â· 7) + ... = âˆ’1 + 1 + 1 âˆ’ 1 âˆ’ 1 + 1 = 0. Formalmente,
k

Si n > 1 tiene factorizaciÃ³n prima n = p11 Â· p2k2 Â· Â· Â· pks s ; los Ãºnicos divisores d de n que contribuyen
con un sumando no nulo, son los divisores que son productos de primos distintos. Estos divisores d se pueden dividir en dos grupos de igual tamaÃ±o; D1 = {d : ps |d} y D2 = {d : ps - d},
es decir, los productos que no tienen a ps y estos mismos agregando ps : d âˆˆ D1 â‡” dps âˆˆ D2 .
Ahora, como Âµ (d) = âˆ’Âµ (dps ), entonces hay tantos divisores que contribuyen con âˆ’1 a la suma
como divisores que contribuyen con 1, como se querÃ­a mostrar.

Teorema 7.3 (FÃ³rmula de InversiÃ³n).
Sean f y g son funciones aritmÃ©ticas,
Si f (n) = âˆ‘ g(d), entonces g(n) = âˆ‘ f (d)Âµ (n/d)
d|n

d|n

e inversamente.
Prueba: Usando la notaciÃ³n de convoluciÃ³n, hay que probar que f = g âˆ— u â‡â‡’ g = f âˆ— Âµ .
â€ =â‡’ â€ f = g âˆ— u =â‡’ f âˆ— Âµ = ( g âˆ— u) âˆ— Âµ = g âˆ— (u âˆ— Âµ ) = g âˆ— (Âµ âˆ— u) = g âˆ— e = g.

130

ESTIMACIONES, ESTADËSTICAS Y PROMEDIOS

â€ â‡= â€ Ejercicio.

Ejemplo 7.3
Muestre que

âˆ‘Ïƒ(d)Âµ (n/d) = n para toda n âˆˆ Z+ .
d|n

SoluciÃ³n: Como Ïƒ = N âˆ— u, entonces por inversiÃ³n de MÃ¶bius, N = Ïƒ âˆ— Âµ , que es lo que
se querÃ­a.

7.2

A los nÃºmeros primos les gusta los juegos de azar.

La probabilidad de que un nÃºmero natural, tomado al azar, sea divisible por p es 1/p.
Â¿QuÃ© significa â€œtomar un nÃºmero natural al azarâ€?. Los naturales son un conjunto infinito, asÃ­
que no tiene sentido decir que vamos a tomar un nÃºmero al azar. Lo que si podemos es tomar
un nÃºmero de manera aleatoria en un conjunto finito {1, 2, ..., n} y luego (atendiendo al modelo
frecuentista de probabilidad) ver que pasa si n se hace grande (i.e. n âˆ’â†’ âˆ).
Hagamos un pequeÃ±o experimento: Fijamos un nÃºmero p y seleccionamos de manera aleatoria un nÃºmero en el conjunto {1, 2, ..., n} y verificamos si es divisible por p. El experimento
lo repetimos m veces y calculamos la frecuencia relativa. En la tabla que sigue, hacemos este
experimento varias veces para n, m y p.
n
100000

m

p

Frecuencia relativa

10000

5

0.1944
0.2083
0.2053
0.1993

10000000

100000

5

0.20093
0.19946
0.1997
0.20089

100000000 1000000

5

0.199574
0.199647

Tabla 7.2. Resultado del experimento.

Y efectivamente, parece que â€œla probabilidadâ€ de que un nÃºmero tomado al azar en el conjunto
{1, 2, ..., n} sea divisible por p = 5 es 1/5 = 0.2
De una manera sintÃ©tica: Sea E p (n) = los mÃºltiplos de p en el conjunto {1, 2, ..., n}. Podemos
E p (n)
calcular la proporciÃ³n de estos mÃºltiplos en este conjunto, es decir, podemos calcular
n

131

para varios valores de n
n
100

MÃºltiplos de p = 5

ProporciÃ³n

20

0.2

10230

2046

0.2

100009

20001

0.199992

1000000

199999

0.199999

Tabla 7.3

Parece que en el conjunto {1, 2, ..., n}, la proporciÃ³n de los mÃºltiplos de p = 5 se aproxima a
1/5, conforme n se hace grande. Â¿Significa esto que la probabilidad de que un nÃºmero natural, tomado al azar, sea divisible por 5 es 1/5 ?. Por ahora, lo Ãºnico que podemos decir es que
este experimento sugiere que la densidad (o la proporciÃ³n) de los mÃºltiplos de 5 en {1, 2, ..., n}
parece ser 1/5 conforme n se hace grande. Generalizando,

DefiniciÃ³n 7.2
Sea E un conjunto de enteros positivos con alguna propiedad especial y sea E( N ) =
T
E {1, 2, ..., N }. La densidad (o medida relativa) de E se define como
E(n)
nâ†’âˆ n

D [ E] = lim
siempre y cuando este lÃ­mite exista.

Â¿Es esta densidad una medida de probabilidad en el modelo axiomÃ¡tico?. No, porque resulta no
ser aditiva, como el modelo exige (ver [10]). Aunque en el esquema frecuentista se puede ver la
densidad como la â€œprobabilidadâ€ de que un entero positivo, escogido aleatoriamente, pertenezca
a E, aquÃ­ identificamos este tÃ©rmino con densidad o proporciÃ³n. Tenemos,

Teorema 7.4
La densidad de los naturales divisibles por p es

1
, es decir, si E p es el conjunto de enteros
p

positivos divisibles por p, entonces
D [ E p ] = lim

nâ†’âˆ

E p (n)
1
=
n
p

Prueba: Para calcular el lÃ­mite necesitamos una expresiÃ³n analÃ­tica para E p (n). Como existen
p, r tales que n = pk + r con 0 â‰¤ r < p, entonces kp â‰¤ n < (k + 1) p, es decir, hay exactamente
nâˆ’r
k mÃºltiplos positivos de p que son menores o iguales a n . Luego E p (n) = k =
. Por lo
p
E p (n)
(n âˆ’ r )/p
1
r
1
tanto, D [ E p ] = lim
= lim
= lim âˆ’
=
nâ†’âˆ
nâ†’âˆ
nâ†’âˆ p
n
n
pn
p

132

ESTIMACIONES, ESTADËSTICAS Y PROMEDIOS

Un hecho de gran importancia es este: Si p, q son primos, ser divisible por p y por q son eventos
T
tÃ©cnicamente independientes, es decir, D [ E p
Eq ] = D [ E p ] D [ Eq ]. Una de sus consecuencias (no
tan inmediata) es que los divisores primos de n se distribuyen de acuerdo a la ley normal (ver
[10]).

7.3

Orden de Magnitud

Necesitamos un mecanismo flexible para comparar funciones. Esto es necesario, porque a menudo
nos interesa reemplazar funciones complicadas con otras mÃ¡s simples. En la parte prÃ¡ctica, esto
nos permite establecer tÃ©rminos de error en una estimaciÃ³n, de una manera mÃ¡s flexible.
Para comparar dos funciones f y g, es conveniente primero definir la relaciÃ³n â€œâ€ (se lee
â€œdominada porâ€): Decimos que
f ( x )  g( x ) conforme x â†’ âˆ
si podemos encontrar una constante C y x0 tal que
f ( x ) â‰¤ Cg( x ) cuando x > x0
Para establecer esta desigualdad, a menudo es muy Ãºtil usar el hecho de que si f es creciente,
entonces a â‰¤ b cuando f ( a) â‰¤ f (b). A veces se puede usar la derivada para establecer que f es
creciente (o decreciente) en un intervalo.

Ejemplo 7.4
Muestre que 3x3 âˆ’ x2 + 1  x3 conforme x â†’ âˆ
SoluciÃ³n: Tenemos que encontrar C y x0 tal que x3 âˆ’ x2 + 1 â‰¤ Cx3 cuando x â‰¥ x0 .
Como 1 âˆ’ x2 < 0 si x > 1, entonces 3x3 âˆ’ x2 + 1 < 3x3 si x > 1. Por tanto basta tomar
C = 3 y x0 = 1 para que se cumpla la definiciÃ³n.

Ejemplo 7.5
Muestre que exp(

p

log( x ))  x conforme x â†’ âˆ

SoluciÃ³n: exp( x ) y log( x )
p
exp( plog( x ))
log( x )
log( x )

son funciones crecientes, entonces

â‰¤ x
â‰¤ log( x )
â‰¤ log2 ( x ),

â‡â‡’
â‡â‡’
(âˆ—)

(tomando logaritmos)
(cuadrados a ambos lados)

133

ahora, como u â‰¤ u2 si u â‰¥ 1, la desigualdad (âˆ—) se cumple si x > e. Por tanto, basta
tomar C = 1, y x0 = e para que se cumpla la definiciÃ³n.

O grande de Landau. En general, nos interesa una manera de decir que f y g son funciones
parecidas en orden excepto por un tÃ©rmino de error dominado por una funciÃ³n h. Decimos que
f ( x ) = g( x ) + O(h( x )) si | f ( x ) âˆ’ g( x )|  h( x )
En particular, si g( x ) â‰¡ 0,
f ( x ) = O(h( x )) si f ( x )  h( x )
Ejemplo 7.6
Observe que f ( x ) = O(1) significa que f es una funciÃ³n acotada en un intervalo
p ] x0 , âˆ [.
3
2
3
TambiÃ©n, usando los dos ejemplos anteriores, 3x âˆ’ x + 1 = O(3x ) y exp( log( x )) =
O ( x ).

Ejemplo 7.7

Muestre que

x
=1+O
x+1

 
1
.
x

SoluciÃ³n: | x/( x + 1) âˆ’ 1| = 1/( x + 1) < 1/x si x > 0. AsÃ­, tomando C = 1 y x0 = 0, el
tÃ©rmino de error es O(1/x ).

Ejemplo 7.8
Sean n, d enteros positivos, Muestre que Jn/dK = n/d + O(1).
SoluciÃ³n: Por el algoritmo de la divisiÃ³n, existe k, r âˆˆ Z tal que n = k Â· d + r con 0 â‰¤ r < d
o tambiÃ©n n/d = k + r/d. Luego, Jn/dK = k = (n âˆ’ r )/d. Ahora, |Jn/dK âˆ’ n/d| = r/d < 1
para cada n â‰¥ 0. AsÃ­, tenemos Jn/dK = n/d + O(1), tomando C = 1.
o pequeÃ±a. La definiciÃ³n de O grande requiere la existencia de una constante C tal que f â‰¤ Cg.
La definiciÃ³n de la o pequeÃ±a es similar, solo que esta vez pedimos que 0 â‰¤ f â‰¤ Cg para toda
C > 0. En lo que sigue, solo hacemos referencia un par de veces a este concepto, asÃ­ que solo
vamos a dar la definiciÃ³n.

DefiniciÃ³n 7.3
Sea f , g funciones. Decimos que
0 â‰¤ f ( x ) â‰¤ c Â· g( x ) si x > xc .

f = o ( g) si para toda c âˆˆ R+ , existe xc tal que

134

ESTIMACIONES, ESTADËSTICAS Y PROMEDIOS

7.4

Teorema de los nÃºmeros primos

Ya sabemos que los primos son infinitos. De aquÃ­ en adelante hay una pregunta muy natural:
Â¿cuÃ¡ntos primos hay entre 2 y x?. Por ejemplo, 2, 3, 5, 7 son los primos inferiores a x = 10, asÃ­
que hay 4 primos entre 2 y 10.
La funciÃ³n que se usa paraâˆšcontar los primos por debajo de x se denota con Ï€ ( x ) : Por ejemplo,
Ï€ (2) = 1, Ï€ (10) = 4 y Ï€ ( 1000) = 11.
Para la funciÃ³n Ï€ ( x ) no hay una fÃ³rmula sencilla. Algunas fÃ³rmulas actuales son variaciones
un poco mÃ¡s eficientes que la fÃ³rmula recursiva de Legendre (1808).

7.4.1

FÃ³rmula de Legendre para Ï€ ( x ).

Esta fÃ³rmula esta basada en el principio de InclusiÃ³n-ExclusiÃ³n. BÃ¡sicamente dice que el conjunto {1, 2, ..., JxK} es la uniÃ³n del entero 1, los primos â‰¤ x y los enteros compuestos â‰¤ x,
JxK = 1 + Ï€ ( x ) + #{ enteros compuestos â‰¤ x }
Un entero compuesto en el conjunto A = {1, 2, ..., JxK} tiene al menos un divisor primo menor o
âˆš
igual a x. Esto nos ayuda a detectar los nÃºmeros compuestos en A : Solo tenemos que contar
âˆš
los elementos de A con un divisor primo â‰¤ x.
Los nÃºmeros divisibles por p e inferiores a x son los k nÃºmeros p < 2p < ... < k Â· p â‰¤ x. Como
kp â‰¤ x < (k + 1) p, entonces k = Tx/pU. AsÃ­, Tx/pU cuenta la cantidad de enteros â‰¤ x divisibles
por p.
Ahora, Â¿ #{ enteros compuestos â‰¤ x } es igual a al conteo total de los mÃºltiplos de cada primo
âˆš
pi â‰¤ x ? No, pues este conteo incluye a los propios primos pi , asÃ­ que hay que reponer con
âˆš
Ï€ ( x ) para hacer una correcciÃ³n. Pero tambiÃ©n habrÃ­a que restar los compuestos que son divisibles por pi y p j pues fueron contados dos veces, pero esto harÃ­a que los nÃºmeros divisibles por
pi , p j , pk fueran descontados una vez mÃ¡s de lo necesario asÃ­ que hay que agregar una correcciÃ³n
para estos nÃºmeros, y asÃ­ sucesivamente.

Ejemplo 7.9

âˆš
Si x = 30, los primos menores que T 30U = 5 son 2, 3 y 5.
T30/2U = 15 cuenta {2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30}
T30/3U = 10 cuenta {3, 6, 9, 12, 15, 18, 21, 24, 27, 30}
T30/5U = 6 cuenta {5, 10, 15, 20, 25, 30}
En el conteo T30/2U + T30/3U + T30/5U :
se contaron los primos 2, 3 y 5.
IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

135

6, 12, 18, 24, 30 fueron contados dos veces como mÃºltiplos de 2, 3
10, 20, 30 fueron contados dos veces como mÃºltiplos de 2, 5
15, 30 fueron contados dos veces como mÃºltiplos de 3, 5
30 fue contado tres veces como mÃºltiplo de 2, 3 y 5.

Ejemplo 7.0 (continuaciÃ³n).
Finalmente,
#{ enteros compuestos â‰¤ 30}

= T30/2U + T30/3U + T30/5U

âˆ’ T30/(2 Â· 3)U âˆ’ T30/(2 Â· 5)U âˆ’ T30/(3 Â· 5)U

+ T30/(2 Â· 3 Â· 5)U

= 31 âˆ’ 3 âˆ’ 5 âˆ’ 3 âˆ’ 2 + 1 = 19
El Ãºltimo sumando se agrega pues el 30 fue contado tres veces pero tambiÃ©n se resto tres veces.
Observe ahora que en {1, 2, ..., 30} hay 19 compuestos y el 1, asÃ­ que quedan 10 primos.

FÃ³rmula de Legendre para Ï€ ( x ).
Sea pi el i âˆ’Ã©simo primo. La fÃ³rmula de Legendre es,

âˆš 
1 + Ï€ (x) = Ï€
x + TxU âˆ’

âˆ‘



âˆš
pi â‰¤ x


x
+
pi

âˆ‘

âˆš
pi < p j â‰¤ x

"

x
pi p j

#

âˆ’

âˆ‘

âˆš
pi < p j < p k â‰¤ x

"

#
x
+ Â·Â·Â·
pi p j p k

âˆš
Para efectos de implementaciÃ³n es mejor poner Î± = Ï€ ( x ) y entonces la fÃ³rmula queda
âˆš 
1 + Ï€ (x) = Ï€
x + TxU âˆ’ âˆ‘

i â‰¤Î±



"
#
"
#

x
x
x
+ âˆ‘
âˆ’ âˆ‘
+ Â·Â·Â·
pi
pi p j
pi p j p k
i< jâ‰¤Î±
i < j<kâ‰¤Î±

Ejemplo 7.10
Calcular Ï€ (100)
SoluciÃ³n: Como

âˆš

100 = 10, solo usamos los primos {2, 3, 5, 7}.

136

ESTIMACIONES, ESTADËSTICAS Y PROMEDIOS

1 + Ï€ (100)

=

Ï€ (10) + T100U

âˆ’ (T100/2U + T100/3U + T100/5U + T100/7U)

+T100/2 Â· 3U + T100/2 Â· 5U + T100/2 Â· 7U + T100/3 Â· 5U + T100/3 Â· 7U + T100/5 Â· 7U
âˆ’ (T100/2 Â· 3 Â· 5U + T100/2 Â· 3 Â· 7U + T100/2 Â· 5 Â· 7U + T100/3 Â· 5 Â· 7U)

=

+T100/2 Â· 3 Â· 5 Â· 7U

4 + 100 âˆ’ (50 + 33 + 20 + 14) + (16 + 10 + 7 + 6 + 4 + 2) âˆ’ (3 + 2 + 0 + 1) + 0 = 26

El problema con esta fÃ³rmula es la cantidad de cÃ¡lculos que se necesita para calcular las correcciones.
Las cantidad de partes enteras Tx/( pi1 pi2 Â· Â· Â· pik )U corresponde a la cantidad de subconjuntos no
vacÃ­os {i1 , i2 , Â· Â· Â· , ik } de {1, 2, ..., Î±}, es decir, hay que calcular 2Î± âˆ’ 1 partes enteras.

âˆš
Si quisieramos calcular Ï€ (1033 ), entonces, puesto
que 1033i= 1018 , tendrÃ­amos que tener los
h
primos â‰¤ 1018 y calcular las partes enteras x/( pk1 pk2 ...pk j ) que corresponden al cÃ¡lculo de
todos los subconjuntos de {1, 2, ..., Ï€ (1018 )}. Como Ï€ (1018 ) = 24739954287740860, tendrÃ­amos
que calcular
224739954287740860 âˆ’ 1 partes enteras.
que constituye un nÃºmero nada razonable de cÃ¡lculos.

7.4.2

FÃ³rmula de Meisel para Ï€ ( x ).

La fÃ³rmula de Meisel es un re-arreglo de la fÃ³rmula de Legendre. Pongamos
Legendre( x, Î±) =

âˆ‘



i â‰¤Î±

#
"
#
"

x
x
x
+ âˆ‘
+ Â·Â·Â·
âˆ’ âˆ‘
pi
pi p j
pi p j p k
i< jâ‰¤Î±
i < j<kâ‰¤Î±

âˆš
AsÃ­ Ï€ ( x ) = JxK âˆ’ 1 + Î± âˆ’ Legendre( x, Î±) donde Î± = Ï€ ( x ), es decir, Legendre( x, Î±) âˆ’ Î± cuenta
la cantidad de nÃºmeros compuestos â‰¤ x o, en otras palabras, los nÃºmeros â‰¤ x con al menos un
âˆš
divisor primo inferior a Î± = x.
Ahora Legendre( x, Î±) va a tener un significado mÃ¡s amplio: Si Î± âˆˆ N,
Legendre( x, Î±) =

âˆ‘

i â‰¤Î±



"
#
"
#

x
x
x
âˆ’ âˆ‘
+ âˆ‘
+ Â·Â·Â·
pi
pi p j
pi p j p k
i< jâ‰¤Î±
i < j<kâ‰¤Î±

es decir, Legendre( x, Î±) âˆ’ Î± cuenta los compuestos â‰¤ x que son divisibles por primos â‰¤ pÎ± . La
resta es necesaria pues la manera de contar cuenta tambiÃ©n los primos p1 , p2 , ..., pÎ±
Ahora, dividamos los enteros en cuatro grupos: {1}, {primos â‰¤ x }, C3 âˆª C4 = los compuestos
â‰¤ x.
JxK = 1 + Ï€ ( x ) + #C3 + #C4

137

#C3 : Es la cantidad de nÃºmeros compuestos â‰¤ x con al menos un divisor primo â‰¤ pÎ± , es decir
Legendre( x, Î±) âˆ’ Î±.
#C4 : son los compuestos â‰¤ x cuyos divisores primos son > pÎ± : AquÃ­ es donde entra en juego
la escogencia de Î± para determinar la cantidad de factores primos de estos nÃºmeros.
Sea pi el i âˆ’Ã©simo primo. Sean pÎ± y p Î² tal que p3Î± â‰¤ x < p3Î±+1 y p2Î² â‰¤ x < p2Î²+1 . En otras palâˆš
âˆš
abras: Î± = Ï€ ( 3 x ) y Î² = Ï€ ( x ).
Consideremos la descomposiciÃ³n prima de n âˆˆ C4 , n = pi1 Â· pi2 Â· Â· Â· pik con Î± < pi1 < pi2 < ... < pik
y k â‰¥ 2. Como pkÎ±+1 â‰¤ pi1 Â· pi2 Â· Â· Â· pik â‰¤ x < p3Î±+1 =â‡’ k = 2.
AsÃ­ que estos nÃºmeros en C4 son de la forma pÎ±+k p j â‰¤ x, a + k â‰¤ j, k = 1, 2, ...
Pero la cantidad de nÃºmeros pÎ±+k p j es igual a la cantidad de p0j s tal que p j â‰¤ x/pÎ±+k : Ï€ ( x/pÎ±+k ) âˆ’
( Î± + k ).
AdemÃ¡s Î± < Î± + k â‰¤ Î² pues si Î± + k = Î², p Î² Â· p Î² = p2Î² â‰¤ x pero p Î²+1 p j â‰¥ p2Î²+1 > x.
AsÃ­, usando la fÃ³rmula âˆ‘in=âˆ’11 i = n(n âˆ’ 1)/2,

#C4 =

âˆ‘

{Ï€ ( x/pi ) âˆ’ (i âˆ’ 1)} =

Î± <i â‰¤ Î²

1
1
Î²( Î² âˆ’ 1) âˆ’ Î±(Î± âˆ’ 1) + âˆ‘ Ï€ ( x/pi )
2
2
Î± <i â‰¤ Î²

âˆš
Â¿CuÃ¡l es la ganancia? Mientras que con la fÃ³rmula de Legendre necesitamos conocer Ï€ ( x )
âˆš
âˆš
y calcular con primos â‰¤ x, con la fÃ³rmula de Meisel solo necesitamos conocer hasta Ï€ ( 3 x ) y
âˆš
âˆš
calcular con primos â‰¤ 3 x < x.

Ejemplo 7.11
Calcule Ï€ (100) usando la fÃ³rmula de Meisel.

âˆš
âˆš
SoluciÃ³n: Como Î± = Ï€ ( 3 100) = 2 y Î² = Ï€ ( 100) = 4, solo vamos a usar los primos
p1 = 2, p2 = 3, p3 = 5, p4 = 7.
Legendre(100, 2)

= T100/2U + T100/3U + T100/2 Â· 3U

= 50 + 33 âˆ’ 16 = 67

Meisel(100, 2, 4)

= Ï€ (100/5) + Ï€ (100/7)
= Ï€ (20) + Ï€ (4) = 8 + 6 = 14

AsÃ­, Ï€ (100) = 100 + 6 âˆ’ 0 âˆ’ 67 âˆ’ 14 = 25

138

ESTIMACIONES, ESTADËSTICAS Y PROMEDIOS

Mathematica (Wolfram Research Inc.) implementa Ï€ ( x ) con el comando PrimePi[ x ] hasta x â‰ˆ
8 Ã— 1013 . En esta implementaciÃ³n, si x es pequeÃ±o, se calcula Ï€ ( x ) usando colado y si x es
grande se usa el algoritmo Lagarias-Miller-Odlyzko.

7.5

EstimaciÃ³n de Ï€ ( x ). Teorema de los nÃºmeros primos.

El cÃ¡lculo de Ï€ ( x ) de manera directa es bastante complicado y requiere mucho esfuerzo computacional. En general, no podemos responder de manera exacta todo el tiempo. Curiosamente,
hay fÃ³rmulas relativamente simples para responder con una aproximaciÃ³n del valor de Ï€ ( x )
para valores grandes de x. Legendre y Gauss iniciaron el estudio de esta estimaciÃ³n contando
primos en intervalos de longitud adecuada y calculando proporciones, en busca de un ley que
gobernara esta distribuciÃ³n.
La frecuencia relativa Ï€ (n)/n calcula la proporciÃ³n de primos en el conjunto A = {1, 2, ..., n}.
Aunque la distribuciÃ³n de los primos entre los enteros parece irregular, el comportamiento
promedio si parece ser agradable. Como dijimos antes, basÃ¡ndose en un estudio empÃ­rico de
tablas de nÃºmeros primos, Legendre y Gauss (en 1792, a la edad de 15 aÃ±os) conjeturan que la
1
ley que gobierna el cociente Ï€ (n)/n es aproximadamente igual a
.
ln(n)
En [9] se indica que Gauss y Legendre llegaron a este resultado, de manera independiente,
estudiando la densidad de primos en intervalos que difieren en potencias de diez: Notaron que
la proporciÃ³n de primos en intervalos centrados en x = 10n decrece lentamente y disminuye
aproximadamente a la mitad cada vez que pasamos de x a x2 . Este fenÃ³meno es muy bien
modelado por 1/ ln( x ) pues 1/ ln( x2 ) = 0.5/ ln( x ).
n

Ï€ (n)

Ï€ (n)/n

1/ ln(n)

107

664579

0.0664579

0.0620420

1011

4118054813

0.0411805

0.0394813

1012

37607912018

0.0376079

0.0361912

Tabla 7.4

Acerca de este descubrimiento, Gauss escribiÃ³ a uno de sus ex-alumnos, Johann Franz Encke, en
1849
â€œCuando era un muchacho considere el problema de cuÃ¡ntos primos habÃ­a hasta un punto dado. Lo que
encontrÃ© fue que la densidad de primos alrededor de x es aproximadamente 1/ ln( x ). â€

La manera de interpretar esto es que si n es un nÃºmero â€œcercanoâ€ a x, entonces es primo con
â€œprobabilidadâ€ 1/ ln( x ). Claro, un nÃºmero dado es o no es primo, pero esta manera de ver las
cosas ayuda a entender de manera muy intuitiva muchas cosas acerca de los primos.

139

Ejemplo 7.12
pto Como Jln(1000)K = 7, podemos usar un dado de 6 caras para decidir si un nÃºmero
n cercano a 1000, es (probablemente) primo

Primo !

Para decidir con un dado si un nÃºmero n cercano a 10 000 es probablemente primo,
debemos contruir un dado de 8 lados pues Jln(10 000)K = 9.

Primo!

Lo que afirma Gauss es lo siguiente: Si âˆ†x es â€œpequeÃ±oâ€ comparado con x (en el mundillo
asintÃ³tico esto quiere decir que âˆ†x/x â†’ 0 conforme x â†’ âˆ) entonces
1
Ï€ ( x + âˆ†x ) âˆ’ Ï€ ( x )
â‰ˆ
âˆ†x
ln( x )

(Ï€ ( x + âˆ†x ) âˆ’ Ï€ ( x ))/âˆ†x es la densidad de primos en le intervalo [ x, x + âˆ†x ] y 1/ ln( x ) es el
promedio estimado en este intervalo. Por esto decimos: 1/ ln( x ) es la â€œprobabilidadâ€ de que
un nÃºmero n, en las cercanÃ­as de x, sea primo. Para hacer un experimento, podemos tomar
âˆš
âˆ†x = x (que claramente es dominada por x),

x

Ï€ ( x + âˆ†x ) âˆ’ Ï€ ( x )

Ï€ ( x + âˆ†x ) âˆ’ Ï€ ( x )
âˆ†x

1
ln( x )

10

2

0.632

0.434

100

4

0.4

0.217

1000

5

0.158

0.144

10000

11

0.11

0.108

100000000000

12491

0.0395

0.039

1000000000000

36249

0.0362

0.036

Tabla 7.5. Densidad de primos en le intervalo [ x, x + âˆ†x ] con âˆ†x =

âˆš

x

Hadamard y de la VallÃ©e Poussin probaron en 1896, usando mÃ©todos basados en anÃ¡lisis complejo, el

140

ESTIMACIONES, ESTADËSTICAS Y PROMEDIOS

Teorema 7.5 (Teorema de los NÃºmeros Primos).
Sea Li( x ) =

Z x
2

dt
Ï€ (x)
. Entonces Ï€ ( x ) âˆ¼ Li( x ), es decir limxâ†’âˆ
=1
ln(t)
Li( x )

La conjetura de Legendre era Ï€ ( x ) âˆ¼ x/ ln( x ). Esta expresiÃ³n se usa mucho cuando se hacen
estimaciones â€œgruesasâ€:

Teorema 7.6
Li( x ) âˆ¼ x/ ln( x ), es decir limxâ†’âˆ

7.5.1

Ï€ (x)
=1
x/ ln( x )

La funciÃ³n Zeta de Riemann

Este tema estÃ¡ en el Ã¡mbito de la teorÃ­a analÃ­tica de nÃºmeros. AquÃ­ solo podemos hacer una excursiÃ³n algo descriptiva con solo algunos cÃ¡lculos concretos que involucran a la funciÃ³n â€œzetaâ€
de Riemann. Los resultados que se mencionan aquÃ­ fueron tomados de [9] y [2].
La aproximaciÃ³n a Ï€ ( x ) dada por Gauss y Legendre fue encontrada por mÃ©todos empÃ­ricos.
Riemann fue el primero en deducir de manera sistemÃ¡tica relaciones entre los nÃºmeros primos y
las funciones matemÃ¡ticas conocidas. El punto de partida de Riemann fue la relaciÃ³n descubierta
por Euler
âˆ

Î¶ (s) =

1
1
= âˆ
s
n
1
âˆ’
pâˆ’s
p primo
n =1

âˆ‘

donde el producto es tomado sobre todos los primos.
Para entender esta fÃ³rmula debemos aplicar series geomÃ©tricas,
1
= 1 + pâˆ’s + ( pâˆ’s )2 + ...
1 âˆ’ pâˆ’s
AsÃ­,

p

1
1
âˆ’
pâˆ’s
primo

âˆ

= (1 +

1
1
+ 2s + ...)
2s
2

1
1
+ 2s + ...)
3s
3
1
1
Â·(1 + s + 2s + ...)
5
5
Â·Â·Â·

Â·(1 +

(7.1)

141

Ejemplo 7.13
Veamos un ejemplo concreto. Si s = 1 entonces
âˆ

Î¶ (1) =

1
1
= âˆ
n
1
âˆ’
p âˆ’1
p primo
n =1

âˆ‘

= (1 +

1
1
+ ...)
+
2 22

1
1
+ 2 + ...)
3 3
1
1
Â·(1 + + 2 + ...)
5 5
1
1
Â·(1 + + 2 + ...)
7 7
Â·Â·Â·

Â·(1 +

AsÃ­, el sumando

1 1
1
1
1
= Â· 2 Â· 2 Â· 1 Â· 1Â·Â·Â· .
se obtiene como
450
2 3
2 Â· 32 Â· 52
5

El producto de los dos primeros factores serÃ­a,
1
1
1
1
1
+ 2
+ 2+ 3+
p2
p
p
p2
p2 p1
p2
2 1
1
1
1
1
1
+ 3 +
+
+ 2+
2
p1
p2 p1
p1
p2 p1
p2 p31
1
1
1
1
1
+ 2 2+ 3 2+ 2 3+ 3 3+ 3
p2 p1
p2 p1
p2 p1
p2 p1
p1

(1 + p1âˆ’1 + p1âˆ’2 + ...)(1 + p2âˆ’1 + p2âˆ’2 + ...) = 1 +

Luego, Î¶ (1) =

1

âˆ‘ 2Î±1 3Î±2 Â· Â· Â· pÎ±nn

donde la suma cubre todas las combinaciones de expo-

nentes Î±i â‰¥ 0 y todos los primos pi . El teorema fundamental de la aritmÃ©tica dice que
âˆ
1
estos productos en los denominadores son todos los enteros positivos: Î¶ (1) = âˆ‘ .
n
n =1
Riemann toma esta identidad establecida por Euler y pone a trabajar la teorÃ­a de funciones
analÃ­ticas (funciones diferenciables de variable compleja). Extiende la relaciÃ³n (7.2), la cual estÃ¡
restringida a s > 1 por razones de convergencia, a s = Ïƒ + it con Ïƒ > 0 y s 6= 1 (en este caso
|Î¶ (1)| = âˆ). La nueva funciÃ³n luce asÃ­
Î¶ (s) =

1
1 âˆ’ 21 âˆ’ s

âˆ

(âˆ’1)nâˆ’1
ns
n =1

âˆ‘

(7.2)

Esta funciÃ³n converge para todos los s 6= 1 con Ïƒ > 0 si s 6= 1. Para calcular Î¶ (s) se usa la
fÃ³rmula de Euler-Maclaurin
N âˆ’1

Î¶ (s)

â‰ˆ

âˆ‘

n =1

+

nâˆ’s +

1
1
N 1âˆ’ s + N âˆ’ s
sâˆ’1
2

1 âˆ’sâˆ’1 s(s + 1)(s + 2) âˆ’sâˆ’3 s(s + 1)(s + 2)(s + 3)(s + 4) âˆ’sâˆ’5
N
âˆ’
N
+
N
,
12
720
30240

142

ESTIMACIONES, ESTADËSTICAS Y PROMEDIOS

Por ejemplo, tomando N = 1000,
Î¶ (2) â‰ˆ 1.6449340668482264... â‰ˆ Ï€ 2 /6 = 1.6449340668482262...
Î¶ (1/2 + 37.586178 Â· i ) = âˆ’8.910197857314728 Ã— 10âˆ’8 âˆ’ 2.9437792720132805 Ã— 10âˆ’7 i
En realidad, 0.5 + 37.586178158825675... Â· i es el sexto cero no trivial de Î¶, es decir, Î¶ (1/2 + 0.5 +
37.586178158825675... Â· i ) = 0. A este respecto, la famosa hipÃ³tesis de Riemann dice que todos los
ceros no triviales de Î¶ (s) son de la forma s = 1/2 + it. La importancia de esta hipÃ³tesis se debe
a que la estimaciÃ³n del error en varias fÃ³rmulas relacionadas con la distribuciÃ³n de los nÃºmeros
primos depende del conocimiento de regiones extensas libres de ceros de la funciÃ³n Î¶ (s). En
particular,

âˆš
Ï€ ( x ) = Li( x ) + O( x ln x )
Para obtener una fÃ³rmula para Ï€ ( x ), Riemann define la funciÃ³n f ( x ) = Ï€ ( x ) + 1/2Ï€ ( x1/2 ) +
1/3Ï€ ( x1/3 ) + ..., con x > 1 y no entero. Sorprendentemente,
âˆ

Ï€ (x) =

Âµ (n)
f ( x1/n )
n
n =1

âˆ‘

(7.3)

En 1859 Riemann hace la conjetura
f ( x ) = Li( x ) âˆ’ âˆ‘ Li( x Ï ) âˆ’ ln 2 +
Ï

Z âˆ
x

dt/(t(t2 âˆ’ 1) ln t)

donde la suma corre sobre todos los ceros no triviales Ï de Î¶ (s), contando multiplicidad. Esto
fue probado por Mangoldt en 1895. Ahora, cambiando f ( x1/n ) por Li( x1/n ) en (7.3), Riemann
obtiene
âˆ

Ri( x ) =

Âµ (n)
Li( x1/n ) âˆ¼ Ï€ ( x )
n
n =1

âˆ‘

En esta fÃ³rmula, es conveniente calcular Li( x ) = Ei( Log(z)) donde Ei(z) = âˆ’

Z âˆ
âˆ’z

eâˆ’t /t dt; suponiendo

que tenemos una buena implementaciÃ³n de esta funciÃ³n, por ejemplo en ([24]).
La funciÃ³n Ri(n), n âˆˆ Z+ , se puede calcular usando la serie de Gram (1893),
âˆ

Ri(n) = 1 +

(log n)k

âˆ‘ k! Â· kÎ¶ (k + 1),

k =1

esta serie exhibe convergencia muy veloz; sin embargo, la aproximaciÃ³n a Ï€ ( x ) es aceptable si
x < 109 .
Â¿QuÃ© tan bien se puede aproximar Ï€ ( x )? El teorema de los nÃºmeros primos indica que
Ï€ ( x ) âˆ¼ Li( x ), es decir, el error relativo


 Li( x ) âˆ’ Ï€ ( x ) 

 âˆ’â†’ 0 conforme x âˆ’â†’ 0.


Li( x )
Efectivamente, conforme x es grande, Li( x ) se aproxima mÃ¡s y mÃ¡s a Ï€ ( x ). Si x no es muy
grande, se puede tener un error porcentual pequeÃ±o y un error real de varios millones, que aÃºn
asÃ­, es despreciable respecto a la magnitud de Ï€ ( x ). En la tabla (7.7) se hace una comparaciÃ³n

143

entre Ï€ ( x ) Li( x ). Los valores de Ï€ ( x ) se obtuvieron de tablas especiales mientras que Li( x ) se
calculÃ³ con Ei ( x ).

x

Ï€ (x)

Li( x )

Li( x ) âˆ’ Ï€ ( x )

Ï€ ( x ) âˆ’ Li( x )
Li( x )

1013

346065536839

346065645810.

108 971

âˆ’3.14 Ã— 10âˆ’7

1018

24739954287740860

24739954309690415.

21949555

8.87 Ã— 10âˆ’7

1022

201467286689315906290

201467286691248261498.

1932355207

9.59 Ã— 10âˆ’12

Tabla 7.6. Comparando Ï€ ( x ) con Li( x )

Una mejora notable se obtiene si cambiamos Li( x ) por Ri( x ),
x

Li( x ) âˆ’ Ï€ ( x )

Ri( x ) âˆ’ Ï€ ( x )

1013

108971.

âˆ’5773

1018

21949555.

âˆ’3501366

1022

1932355207.

âˆ’127132665

Tabla 7.7. Comparando Ï€ ( x ) con Ri( x )

7.5.2

Teorema de Mertens.

En este apartado vamos a aplicar algunos cÃ¡lculos aproximados para establecer un resultado
muy curioso: TÃ­picamente, los nÃºmeros grandes tienen factores primos pequeÃ±os.
Observemos que en el conjunto {1, 2, 3, ..., 9} solo 3, 6 y 9 son divisibles por 3. En tÃ©rminos de
proporciones, una tercera parte. La tabla que sigue muestra las proporciones al variar n. Es Ã©sta
tabla, dn denota la cantidad de enteros positivos â‰¤ n que son divisibles por 3.

n
8680
76333
554615

dn /n â‰ˆ 1/3
0.33329493087557605
0.33332896650203714
0.333332131298288

Tabla 7.8. ProporciÃ³n de nÃºmeros divisibles por 3 .

Como 1/p es la proporciÃ³n aproximada de nÃºmeros, en el conjunto {1, 2, ..., n}, divisibles por p,
1 âˆ’ 1/p serÃ­a la proporciÃ³n de nÃºmeros en este conjunto que no son divisibles por p.
AquÃ­ estamos asumiendo demasiado porque esta proporciÃ³n no es exactamente 1/p. Este nÃºmero
solo es una
 aproximaciÃ³n.

 Si â€œser divisible por pâ€ es un evento independiente de â€œser divisible
1
1
1âˆ’
serÃ­a la proporciÃ³n de nÃºmeros en el conjunto {1, 2, ..., n}, que no son
por qâ€, 1 âˆ’
p
q
divisibles por p ni por q.

144

ESTIMACIONES, ESTADËSTICAS Y PROMEDIOS

En general,

âˆ

2â‰¤ pâ‰¤ G,
p primo,



1
1âˆ’
p


serÃ­a una estimaciÃ³n de la proporciÃ³n de nÃºmeros en el conjunto

{1, 2, ..., n}, que no son divisibles por ninguno de los primos menores o iguales a G. Esto si tiene
utilidad prÃ¡ctica, como veremos mÃ¡s adelante.

Ejemplo 7.14
Hagamos un experimento. Sea dn = #{m â‰¤ n : m es divisible por 2, 3, 5, o 7}.

n

dn

dn /n

103790

80066

0.7714230658059543

949971

732835

0.7714288120374201

400044

308605

0.7714276429592745

117131

90359

0.7714354013881893

124679

96181

0.7714290297483939

Tabla 7.9

La proporciÃ³n de nÃºmeros naturales â‰¤ n divisibles por 2, 3, 5 es â‰ˆ 0.7714. AsÃ­,
1 âˆ’ 0.7714 = 0.2286 es la proporciÃ³n de nÃºmeros en {1, 2, ..., n} que no son divisibles por
los primos 2, 3, 5 y 7.





1
1
1
1
Y efectivamente, 1 âˆ’
1âˆ’
1âˆ’
1âˆ’
= 0.228571.
2
3
5
7

Si intentamos calcular el producto para cantidades cada vez grandes de primos, rÃ¡pidamente
empezaremos a tener problemas con el computador. En vez de esto, podemos usar el

Teorema 7.7 (FÃ³rmula de Mertens).


1
eâˆ’Î³
âˆ 1 âˆ’ p = ln(x) + O(1/ ln(x)2 )
2â‰¤ pâ‰¤ x,
p primo

Î³ es la constante de Euler

Para efectos prÃ¡cticos consideramos la expresiÃ³n

âˆ

2â‰¤ pâ‰¤ x,
p primo



1
1âˆ’
p



âˆ¼

eâˆ’Î³
0.5615
â‰ˆ
si x âˆ’â†’ âˆ
ln( x )
ln( x )

(7.4)

145

Ejemplo 7.15
Veamos la fÃ³rmula en acciÃ³n,

âˆâˆš

x

primos

(1 âˆ’ 1/p)

pâ‰¤ x

2eâˆ’Î³
ln( x )

100000

0.0965

0.0975

100000000000000

0.034833774529614024

0.03483410793219253

Tabla 7.10

TambiÃ©n, multiplicando (7.4) por 2, la fÃ³rmula

G

âˆ



3 â‰¤ p,
p primo

1
1âˆ’
p



âˆ¼

1.12292
2eâˆ’Î³
â‰ˆ
ln( G )
ln( G )

nos darÃ­a la proporciÃ³n aproximada de nÃºmeros impares que no tienen un factor primo â‰¤ G.

Ejemplo 7.16
En este ejemplo se muestra que los nÃºmeros grandes sin factores primos pequeÃ±os no
son el caso tÃ­pico.
G

ProporciÃ³n approx de impares
sin factores primos â‰¤ G.

100

0.243839

1000

0.162559

10000

0.121919

100000

0.0975355

1000000

0.0812796

10000000

0.0696682

100000000

0.0609597

1000000000

0.0541864

10000000000

0.0487678
Tabla 7.11

Esta tabla nos informa que â€œtÃ­picamenteâ€, los nÃºmeros grandes tienen factores primos
pequeÃ±os.

146

ESTIMACIONES, ESTADËSTICAS Y PROMEDIOS

7.6

NÃºmeros ArmÃ³nicos
âˆ

Aunque la serie armÃ³nica

1

âˆ‘k

n

es divergente, la funciÃ³n Hn =

1

âˆ‘k

es muy Ãºtil en teorÃ­a

k =1

k =1

analÃ­tica de nÃºmeros.
Lema 7.4
Existe una nÃºmero real Î³, llamada constante de Euler, tal que
Hn = ln(n) + Î³ + O (1/n) .
Prueba: Hay que mostrar que âˆƒC tal que 0 < Hn âˆ’ ln(n) âˆ’ Î³ < C Â· 1/n para n > n0 . Usando
integral de Riemann,
n âˆ’1

1
âˆ‘k=
k =1

Z n
1
1

x

dx + En i.e. Hnâˆ’1 = ln(n) + En

(a)

(b)

Figura 7.1. Comparando el Ã¡rea ln(n) con la suma Hn .

GeomÃ©tricamente, Hnâˆ’1 corresponde a la suma de las Ã¡reas de los rectÃ¡ngulos desde 1 hasta n
y En la suma de las Ã¡reas de las porciones de los rectÃ¡ngulos sobre la curva y = 1/x.
En el grÃ¡fico (b) de la figura 7.1 vemos que En â‰¤ 1 para toda n â‰¥ 1, asÃ­ que En es una funciÃ³n
de n, que se mantiene acotada y es creciente, por lo tanto esta funciÃ³n tiene un lÃ­mite, el cual
vamos a denotar con Î³. AsÃ­, lim En = Î³. En particular, para cada n fijo, Î³ > En .
nâ†’âˆ

Como Î³ âˆ’ En corresponde a la suma (infinita) de las Ã¡reas de las regiones sombreadas en la
figura 7.6, se establece la desigualdad
Î³ âˆ’ En < 1/n
de donde
0 < Î³ âˆ’ ( Hnâˆ’1 âˆ’ ln(n)) < 1/n.
Ahora restamos 1/n a ambos lados para hacer que aparezca Hn , tenemos
1
> Hn âˆ’ ln(n) âˆ’ Î³ > 0
n
que era lo que querÃ­amos demostrar.

...

147

Aunque en la demostraciÃ³n se establece Hn âˆ’ ln(n) âˆ’ Î³ < 1/n, la estimaciÃ³n del error O(1/n)
corresponde a una funciÃ³n dominada por un mÃºltiplo de 1/n. Veamos ahora algunos cÃ¡lculos
que pretender evidenciar el significado de O(1/n).

n

Hn

ln(n)

| Hn âˆ’ ln(n) âˆ’ Î³|

1/n
5.88235294 Ã— 10âˆ’6

170000

12.62077232

12.62076938

2.94117358 Ã— 10âˆ’6

180000

12.67793057

12.67792779

2.77777520 Ã— 10âˆ’6

5.55555555 Ã— 10âˆ’6
5.26315789 Ã— 10âˆ’6
5. Ã— 10âˆ’6

190000

12.73199764

12.73199501

2.63157663 Ã— 10âˆ’6

200000

12.78329081

12.78328831

2.49999791 Ã— 10âˆ’6

Observando las dos Ãºltimas columnas se puede establecer una mejor estimaciÃ³n del error con
1
1
1
!
y todavÃ­a mejor con
âˆ’
2n
2n 12n2
1
1
âˆ’
2n
12n2

n

Hn

ln(n) + Î³ +

100000

12.090146129863427

12.090146129863427

150000

12.495609571309556

12.495609571309554

200000

12.783290810429621

12.783290810429623

TambiÃ©n, de estas tablas se puede obtener la aproximaciÃ³n Î³ â‰ˆ 0.577216

Lema 7.5
n

n

k =1

k =1

âˆ‘ Ï„ (k) = nH (n) + O(n) y âˆ‘ Ï„ (k)

= n ln(n) + O(n).

Prueba: Como Ï„ (k) = âˆ‘ 1, âˆ‘nk=1 Ï„ (k) = âˆ‘nk=1 âˆ‘d|k 1
d|k

La idea ahora es usar argumentos de divisibilidad para usar la expansiÃ³n del ejemplo 7.3. Si
d|k entonces k = d Â· c â‰¤ n. Esto nos dice que el conjunto de todos los divisores positivos de los
nÃºmeros k inferiores o iguales a n, se puede describir como el conjunto de todos los pares (c, d)
con la propiedad cd â‰¤ n (por supuesto, se puede hacer una demostraciÃ³n formal probando la
doble implicaciÃ³n â€œâ‡â‡’â€).
Ahora, cd â‰¤ n â‡â‡’ d â‰¤ n âˆ§ c â‰¤ n/d. Entonces podemos escribir,
n

âˆ‘ Ï„ (k) = âˆ‘ 1 = âˆ‘ âˆ‘

k =1

La suma

âˆ‘

câ‰¤n/d

sumandos, i.e.

c,d
cdâ‰¤n

1

dâ‰¤n câ‰¤n/d

1 corre sobre los enteros positivos menores o iguales que n/d. Esto nos da Jn/dK

âˆ‘

câ‰¤n/d

1 = Jn/dK . Finalmente, usando el ejemplo 7.3,

148

ESTIMACIONES, ESTADËSTICAS Y PROMEDIOS

n

âˆ‘ Ï„ (k)

=

âˆ‘ [n/d]

dâ‰¤n

k =1

=

âˆ‘ {n/d + O(1)}

dâ‰¤n

=

âˆ‘ n/d

+

dâ‰¤n

= n

âˆ‘ 1/d

âˆ‘ O (1)

dâ‰¤n

+

dâ‰¤n

âˆ‘ O (1)

dâ‰¤n

= n Hn + O(n)
En los ejercicios se pide mostrar, usando la figura 7.1, que Hn = log(n) + O(1). Usando este
hecho,
n

âˆ‘ Ï„ (k) = n Hn + O(n) = n {ln(n) + O(1)} + O(n) = n ln(n) + O(n).

k =1

(Los pequeÃ±os detalles que faltan se completan en los ejercicios)

7.7

Acerca de los factores de un nÃºmero grande

Los siguientes teoremas, los cuales podemos ver en ([8]), nos dan informaciÃ³n acerca de quÃ© se
podrÃ­a esperar cuando se intenta factorizar un nÃºmero grande. AquÃ­ hay que tener cuidado: Las
interpretaciones de los teoremas no son del todo rigurosas, solamente son argumentos heurÃ­sticos para obtener estimaciones gruesas.
Teorema 7.8
Sea Ï€k ( x ) el nÃºmero de enteros â‰¤ x que tienen exactamente k factores primos diferentes, k â‰¥ 2.
Entonces
6 x (ln ln x )kâˆ’1
Ï€k ( x ) âˆ¼ 2
= Ï€ âˆ— ( x ) cuando x âˆ’â†’ âˆ
Ï€ ln x (k âˆ’ 1)!
La aproximaciÃ³n Ï€ âˆ— ( x ) de Ï€k ( x ) funciona si k = (1 + o (1)) ln ln x, es decir, si k estÃ¡ en un
vecindario de ln ln x. Por ejemplo, si tomamos x = 10100 y k = 15, la proporciÃ³n de nÃºmeros
compuestos (de la totalidad de los compuestos inferiores a x ) no da â‰ˆ 0.15%. Esto no dice que
los nÃºmeros cercanos a x = 10100 , con 15 o mÃ¡s factores, no son muy populares.
Otro teorema Ãºtil es el siguiente,
Teorema 7.9
â€œNormalmenteâ€, el nÃºmero de factores primos diferentes de N es aproximadamente, ln ln N
En este teorema,â€œNormalmenteâ€ significa que la mayorÃ­a de los enteros cercanos a N tienen una
cantidad de factores primos entre (1 âˆ’ Îµ) ln ln N y (1 + Îµ) ln ln N con Îµ > 0.

149

Ahora, siguiendo un argumento heurÃ­stico, podemos concluir que tÃ­picamente, la cantidad de
dÃ­gitos del factor primo mÃ¡s grande de N es aproximadamente un 63% de la cantidad de dÃ­gitos de N. Si P es el factor primo mÃ¡s grande de N, puesto que log N es proporcional a la
cantidad de dÃ­gitos de N, esta estimaciÃ³n se puede poner como log P â‰ˆ 0.63 log N.
La heurÃ­stica es muy sencilla, si N tiene s factores, N/P tendrÃ­a s âˆ’ 1 â‰ˆ ln ln N/P = ln ln N +
ln(1 âˆ’ ln P/ ln N ) = s + ln(1 âˆ’ ln P/ ln N ). Entonces, tomando logaritmo, 1 âˆ’ ln P/ ln N â‰ˆ 1/e.
Luego, ln P â‰ˆ (1 âˆ’ 1/e) ln N = 0.632 ln N.
En particular, para el segundo factor primo P2 de N, tÃ­picamente tendrÃ­amos log P2 â‰ˆ 0.23 log N.
Para terminar, vamos a hablar un poco del teorema de ErdÃ¶s-Kac. El teorema del lÃ­mite central
dice que si una poblaciÃ³n (continua o discreta) tiene media Âµ y varianza finita Ïƒ2 , la media
muestral X tendrÃ¡ una distribuciÃ³n que se aproxima a la normal.

Teorema 7.10 (Limite Central)
Si tenemos X1 , X2 , ..., Xn variables aleatorias independientes, idÃ©nticamente distribuidas, con
media Âµ y varianza Ïƒ2 , entonces, si n es suficientemente grande, la probabilidad de que
âˆš
âˆš
Âµ + Î± Ïƒ n y nÂµ
Âµ + Î² Ïƒ n es
Sn = X1 + X2 + ... + Xn estÃ© entre nÂµ
1
âˆš
2Ï€

Z Î²

e

âˆ’t2 /2

dt

Î±

Ejemplo 7.17
Si lanzamos una moneda limpia unas 10000 veces, uno esperarÃ­a que aproximadamente
5000 veces salga â€œcaraâ€. Si denotamos con Xi = 1 el evento â€œen el lanzamiento i sale
caraâ€, como la probabilidadâˆšque asumimos para el evento â€œsale caraâ€ es 1/2, entonces
Âµ = n Â· 0.5 = 5000 y Ïƒ = n Â· 0.25 = 5. Luego, para calcular la probabilidad de que
nÂµ
el nÃºmero de caras estÃ© entre 4850 y 5150, debemos calcular los lÃ­mites Î± y Î². Por
razones de ajuste del caso
de correcciÃ³n de 1/2.
âˆšdiscreto al caso continuo, se usa un factor âˆš
Resolviendo, 5000 + (Î±) 50 = 4850 âˆ’ 0.5 =â‡’ Î± = âˆ’3.01 5000 + (Î±) 50 = 5150 + 0.5 =â‡’
Î² = 3.01
1
âˆš
2Ï€

Z 3.01
âˆ’3.01

e

âˆ’t2 /2

dt = 0.997388

AsÃ­, la probabilidad de que el nÃºmero de caras estÃ© entre 4850 y 5150 es de 0.997388
Si Ï‰ (n) denota la cantidad de factores primos de n, esta funciÃ³n se puede denotar como una
suma de funciones Ï p (n), estadÃ­sticamente independientes, definidas por

Ï p (n) =

1
0

si
si

p|n
p-n

150

ESTIMACIONES, ESTADËSTICAS Y PROMEDIOS

Esto sugiere que la distribuciÃ³n de los
âˆš valores de Ï‰ (n) puede ser dada por la ley normal (con
media ln ln n y desviaciÃ³n estÃ¡ndar ln ln n ).
Mark Kac y Paul ErdÃ¶s probaron que la densidad del conjunto de enteros
âˆš n para el cual
elâˆšnÃºmero de divisores primos Ï‰ (n) estÃ¡ comprendido entre ln ln n + Î± ln ln n y ln ln n +
Î² ln ln n, es
Î² âˆ’t2 /2
1
âˆš
e
dt
2Ï€ Î±
es decir, el nÃºmero de divisores primos estÃ¡ distribuido de acuerdo a la ley normal.

Z

Teorema 7.11
Denotamos con N ( x, a, b) la cantidad de enteros n en {3, 4, ..., x } para los cuales
Î±â‰¤

Ï‰ (n) âˆ’ ln ln n
âˆš
â‰¤Î²
ln ln n

Entonces, conforme x â†’ âˆ,
1
N ( x, a, b) = ( x + o ( x )) âˆš
2Ï€

Z Î²

e

âˆ’t2 /2

dt

Î±

EJERCICIOS
7.1

Muestre que 7x3 âˆ’ 12x + 9  x3 conforme x â†’ âˆ. Ayuda: Use la derivada.

7.2

Si f , g : N âˆ’â†’ R+ , muestre que MÃ¡x{ f (n), g(n)} = O( f (n) + g(n)).

7.3

Muestre que 2n+1 = O(2n ) pero 22n 6= O(2n )

7.4

Muestre que f âˆˆ O( g) no implica necesariamente que g âˆˆ O( f )

7.5 Si f (n) â‰¥ 1 y lg[ g(n)] â‰¥ 1 entonces muestre que si f âˆˆ O( g) =â‡’ lg[ f ] âˆˆ O(lg[ g])
Ayuda: Use la hipÃ³tesis para concluir que lg f (n) â‰¤ lg c + lg g(n) â‰¤ (lg c + 1) lg g(n).
7.6

Usando la figura 7.1, muestre que Hn = log(n) + O(1).

7.7

Muestre que

âˆ‘Ï„ (d)Âµ (n/d) = 1
d|n

EJERCICIOS

151

VersiÃ³n actualizada de este libro: https://tecdigital.tec.ac.cr/revistamatematica/Libros/

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

Parte II

INTRODUCCION A LA TEORIA
ALGORITMICA DE NUMEROS.

235711
131719
232931
235711

8

ALGORITMOS PARA EL
MCD

â€œ...tal parece que ni siquiera un procedimiento tan venerable como el algoritmo de
Euclides puede soportar el progresoâ€
Donald Knuth ([18], pÃ¡g 340).

El cÃ¡lculo del mÃ¡ximo comÃºn divisor (mcd) de dos enteros grandes (y tambiÃ©n de dos polinomios) es omnipresente en el cÃ¡lculo con racionales, criptografÃ­a de clave pÃºblica y Ã¡lgebra
computacional. De hecho los cÃ¡lculos algebraicos usuales gastan mÃ¡s de la mitad del tiempo
de ejecuciÃ³n en el cÃ¡lculo del mÃ¡ximo comÃºn divisor de enteros frecuentemente muy grandes
([16]). Como los cÃ¡lculos son muy demandantes, se requiere algoritmos muy eficientes para el
cÃ¡lculo del mcd.
Antes de la dÃ©cada de los 70â€™s, el cÃ¡lculo se hacÃ­a con el algoritmo de Euclides clÃ¡sico o con la
versiÃ³n mejorada de Lehmer6 (1938). El algoritmo de Euclides (ademÃ¡s de su gran valor teÃ³rico)
es sencillo de enunciar e implementar y es muy eficiente, pero hay algoritmos igual de sencillos
y mÃ¡s rÃ¡pidos. Si los nÃºmeros vienen codificados en binario, teÃ³ricamente habrÃ­a una mejora del
60% ([22]) en la eficiencia. Estos algoritmos se usan desde hace unos cuarenta aÃ±os atrÃ¡s. El mÃ¡s
popular es el algoritmo â€œbinarioâ€ para el cÃ¡lculo del mcd (algunos autores le llaman â€œalgoritmo
binario de Euclides). Este algoritmo fue descubierto por el fÃ­sico IsraelÃ­ J. Stein en 1961. D. Knuth
hace la observaciÃ³n de que este algoritmo podrÃ­a tener un pedigrÃ­ muy distinguido pues parece
ser que ya era conocido en la antigua China (un siglo d.C.). Este Ãºltimo algoritmo solo usa restas,
prueba de paridad y divisiones por dos (mucho menos costosas que las divisiones que requiere
el algoritmo de Euclides). Desde el punto de vista del computador la divisiÃ³n por dos (y tambiÃ©n
la multiplicaciÃ³n por 2) se hace en representaciÃ³n binaria, asÃ­ que solo se requiere un desplazamiento de bits. Por ejemplo, 344 = (101011000)2 , 344/2 = (10101100)2 y 2 Â· 344 = (101011000)2 .
RefiriÃ©ndose al algoritmo binario Donald Knuth decÃ­a en 1980, â€œ...parece que ni siquiera un procedimiento tan venerable como el algoritmo de Euclides puede soportar el progresoâ€ ([18], pÃ¡g
340).
Al igual que hay un algoritmo extendido de Euclides tambiÃ©n hay una versiÃ³n extendida del
algoritmo binario mÃ¡s eficiente y tambiÃ©n hay una versiÃ³n para polinomios (Z[ x ] es tanto un
dominio Euclidiano como un â€œdominio de Steinâ€). De nuevo aquÃ­, mientras que el algoritmo de
6 Esta

variante del algoritmo de Euclides se aplica para calcular el mcd( a, b) si a y b son nÃºmeros muy grandes. La idea
es aplicar el algoritmo de Euclides usando, en los primeros pasos, Ta/10k U y Tb/10k U en vez de a y b . Una descripciÃ³n
completa se puede ver en [18], pÃ¡gs 345-348.

153

154

ALGORITMOS PARA EL MCD

Euclides requiere, en general, divisiÃ³n por polinomios de grado mayor o igual a uno, el algoritmo binario solo requiere dividir por x. Sin embargo, el cÃ¡lculo del mÃ¡ximo comÃºn divisor de
dos polinomios con coeficientes enteros no se hace con ninguno de estos algoritmos, mÃ¡s bien se
usan algoritmos modulares (Mathematica) o el llamado â€œalgoritmo heurÃ­stico para polinomiosâ€
(Maple).
El algoritmo de Euclides es muy adecuado para el tratamiento teÃ³rico que se hace en los libros
de Ã¡lgebra y teorÃ­a de nÃºmeros. AdemÃ¡s es muy eficiente para el cÃ¡lculo. El algoritmo binario
y sus variantes (algunas mÃ¡s eficientes que el algoritmo original), aparece de manera natural en
el contexto de la teorÃ­a algorÃ­tmica de nÃºmeros porque aquÃ­ si importa ganar en eficiencia. En
todo caso, no estarÃ­a del todo mal si en los libros de teorÃ­a de nÃºmeros, ademÃ¡s de incluir notas
histÃ³ricas, apareciera un epÃ­logo contando por donde va la novela en nuestros dÃ­as.
En este trabajo se muestran cuatro algoritmos: El algoritmo clÃ¡sico de Euclides, el algoritmo
de Euclides con â€œmenor restoâ€, el algoritmo binario y el algoritmo LSBGCD (left-shift binary
algorithm) que vendrÃ­a a ser como una versiÃ³n binaria del algoritmo de Euclides. Como las implementaciones son sencillas, se implementan en la hoja electrÃ³nica de OpenOffice.org, usando
el lenguaje OOoBasic.

8.1

Parte entera.

La funciÃ³n parte entera superior de un nÃºmero x, denotada ceil(x), devuelve el menor entero
mayor o igual a x, es decir,
VxW = MÃ­n{n âˆˆ Z | n â‰¥ x }.
Por ejemplo, Ceil(2.25)=3, Ceil(2)=2 y Ceil(-2.25)=-2. La funciÃ³n parte entera inferior, denotada Floor(x), devuelve el mÃ¡s grande entero menor o igual a x, es decir,
TxU = MÃ¡x{n âˆˆ Z | n â‰¤ x }.
Por ejemplo, Floor(2.8)=2, Floor(-2)=-2 y Floor(-2.3)=-3.
Notemos que VxW = TxU si y sÃ³lo si x es entero, en otro caso VxW = TxU + 1.
El entero â€œmÃ¡s cercanoâ€ a x â‰¥ 0 es Tx + 1/2U ([17],pÃ¡g 70,ejercicio 5). En la secciÃ³n 8.4 usaremos
la fÃ³rmula (para x â‰¥ 0 ),

Tx + 1/2U =

ï£±
ï£² TxU

si

pfrac( x ) â‰¤ 1/2

ï£³

si

pfrac( x ) > 1/2

TxU + 1

(8.1)

donde la parte fraccionaria, denotada â€œpfracâ€, de un nÃºmero real x â‰¥ 0 se define con la ecuaciÃ³n

x = TxU + pfrac( x ).

155

Por ejemplo, 2.71 = 2 + 0.71 â‡’ pfrac( x ) = 0.71. En la figura (8.1) se muestra la fÃ³rmula desde el
punto de vista geomÃ©trico.

Figura 8.1

Aspectos computacionales. En OOoBasic tenemos la divisiÃ³n entera a\b (con barra invertida)
y la funciÃ³n Int.
Int( x ) = TxU
a\b =

e Int( x ) + 1 = VxW
ï£±
ï£² Ta/bU si a/b â‰¥ 0
ï£³

Por ejemplo, -7\2= âˆ’3 y 3\2= 1.

8.2

Va/bW si

a/b < 0

DivisiÃ³n con menor resto.

El teorema de la divisiÃ³n7 establece que si a, b âˆˆ Z con b 6= 0, existen q, r âˆˆ Z Ãºnicos tales que
a = b Â· q + r con 0 â‰¤ r â‰¤ |b|.
A q se le llama cociente y r se le llama resto y, por supuesto, r = a âˆ’ bq

Esta manera de enunciar este teorema es muy apropiada para fines teÃ³ricos. Que el resto sea
positivo es adecuado, como vimos, para mostrar unicidad.
Sin embargo el resto no tiene porque ser positivo, por ejemplo si a = 144 y b = 89,
144

= 89 Â· 1 + 55,

resto r2 = 55 < b = 89

144

= 89 Â· 2 âˆ’ 34,

resto r1 = 34 < b = 89

Cuando calculamos por ejemplo el mÃ¡ximo comÃºn divisor de dos nÃºmeros usando el algoritmo
de Euclides, el nÃºmero de pasos se reduce si tomamos el resto mÃ¡s pequeÃ±o en cada paso. Esto
no afecta el algoritmo.
7 ExtraÃ±amente

a veces a este teorema se le llama â€œalgoritmo de la divisiÃ³nâ€. En el contexto computacional, el algoritmo
de a divisiÃ³n se refiere a los pasos para dividir u por v en el caso de que u y v estÃ©n representados en base b . En este
caso, el algoritmo calcula Tu/vU.

156

ALGORITMOS PARA EL MCD

Veamos los cÃ¡lculos. Recordemos que

ï£±
ï£² sgn(b) = 1
ï£³

sgn(b) = âˆ’1

si

b > 0,

si

b < 0.

Teorema 8.1
Sean a, b âˆˆ Z con b 6= 0. Sea q âˆˆ Z definido como
ï£±
ï£² q = Ta/bU

si

b > 0,

ï£³

si

b < 0, y a/b âˆˆ
/Z

(8.2)

q = Ta/bU + 1

entonces la divisiÃ³n con resto se puede hacer de dos maneras,
ï£±
ï£² a.) a = bq + r2
ï£³

con 0 â‰¤ r2 < |b|

b.) a = b(q + sgn(b)) âˆ’ r1

con 0 â‰¤ r1 < |b|

AdemÃ¡s, si a â‰¥ 0, b > 0 y r = mÃ­n{r1 , r2 }, entonces r = | a âˆ’ b Â· Ta/b + 1/2U|

Â¿CÃ³mo llegamos a este resultado? Vamos a ver cÃ³mo.
CÃ¡lculo de q y ri Sean a, b âˆˆ Z con b 6= 0. Usando el principio del buen orden se puede
establecer que existe q âˆˆ Z tal que bq es el mÃºltiplo de b mÃ¡s cercano a a por la izquierda (ver
figura 8.2). Por tanto,
bq â‰¤ a < bq + b si b > 0

y

bq â‰¤ a < b(q âˆ’ 1) si b < 0.

Figura 8.2

Entonces, podemos expresar a en tÃ©rminos de bq con resto positivo o en tÃ©rminos de bq + |b| =
b(q + sng(b)) con resto negativo (esta fÃ³rmula funciona para b positivo o negativo).
Recordemos que q = Ta/bU si b > 0 y q = Va/bW si b < 0. Para usar un mismo q, usamos el
hecho de que si a/b âˆˆ
/ Z, entonces Va/bW = Ta/bU + 1 (si a/b âˆˆ Z el resto serÃ­a cero). Por tanto,
ï£±
ï£² q = Ta/bU

si

b>0

ï£³

si

b<0

q = Ta/bU + 1

Entonces tenemos (sin importar el signo de a y b ),

(8.3)

157

ï£±
ï£² a.) a = bq + r2
ï£³

b.) a = b(q + sgn(b)) âˆ’ r1

con

0 â‰¤ r2 < | b |

con

0 â‰¤ r1 < | b |

Ejemplo 8.1
a.) Si a = 144 y b = 89,

144

= 89 Â· 1 + 55,

con resto r2 = 55 < b = 89

144

= 89 Â· 2 âˆ’ 34,

con resto r1 = 34 < b = 89

b.) Si a = 144 y b = âˆ’89, entonces q = T144/(âˆ’89)U + 1 = âˆ’2 + 1 = âˆ’1 y q + sgn(b) =
âˆ’2. Entonces,

144

= âˆ’89 Â· âˆ’1 + 55,

con resto r2 = 55 < |b| = 89

144

= âˆ’89 Â· âˆ’2 âˆ’ 34,

con resto r1 = 34 < |b| = 89

CÃ¡lculo del menor resto. En la secciÃ³n 8.4 vamos a necesitar el teorema de la divisiÃ³n pero
con el menor resto. Para simplificar los cÃ¡lculos, queremos calcular el menor resto usando una
fÃ³rmula directa. Como se observa en la figura 8.3, uno de los restos es menor que |b|/2. Si
r = MÃ­n{r1 , r2 } entonces, existe q0 âˆˆ Z tal que
a = bq0 Â± r con 0 â‰¤ r â‰¤ |b|/2.

Figura 8.3

Para los cÃ¡lculos que vamos a hacer aquÃ­ solo necesitamos tratar el caso en que a â‰¥ 0 y b > 0.
Para comparar los restos a âˆ’ b Â· Ta/bU y b Â· (Ta/bU + 1) âˆ’ a usamos el hecho de que a/b =
Ta/bU + pfrac( a/b).

158

ALGORITMOS PARA EL MCD

El menor resto es a âˆ’ b Â· Ta/bU si pfrac( a/b) â‰¤ 1/2. En efecto,
a âˆ’ b Â· Ta/bU
2a

2a/b
pfrac( a/b)

â‰¤ b Â· (Ta/bU + 1) âˆ’ a
â‰¤ 2b Â· Ta/bU + b

â‰¤ 2Ta/bU + 1, como a/b = Ta/bU + pfrac( a/b),
â‰¤ 1/2.

De manera anÃ¡loga, a âˆ’ b Â· Ta/bU â‰¥ b Â· (Ta/bU + 1) âˆ’ a si pfrac( a/b) â‰¥ 1/2.
AsÃ­,

el menor resto es r =

ï£±
ï£² a âˆ’ b Â· Ta/bU
ï£³

si

pfrac( a/b) â‰¤ 1/2,

| a âˆ’ b Â· (Ta/bU + 1)| si pfrac( a/b) > 1/2.

Como habÃ­amos establecido antes (ecuaciÃ³n 8.2),

Ta/b + 1/2U =

ï£±
ï£² Ta/bU

si

pfrac( a/b) â‰¤ 1/2,

ï£³

si

pfrac( a/b) > 1/2,

Ta/bU + 1

entonces,
el menor resto es r = | a âˆ’ b Â· Ta/b + 1/2U|.

Aspectos computacionales. En OOoBasic de Libreoffice â€œel restoâ€ se calcula con la funciÃ³n
binaria Mod. Se implementa como a Mod b= a âˆ’ b Â· (a\b) y tenemos
a = b Â· a\b + a Mod b
Por ejemplo, si a = âˆ’144 y b = âˆ’89 entonces a\b= 1 y a Mod b= âˆ’55.
Si a Mod b< 0 y queremos el resto r2 positivo, la figura 8.3 nos sugiere r2 = a Mod b + |b|, en
este caso,
a = b Â· (a\b âˆ’ sgn(b)) + a Mod b+|b|

El menor resto se calcula como r = | a âˆ’ b Â· Ta/b + 1/2U| =Abs(a-b*Int(a/b-1/2)).

159

8.3

Algoritmo de Euclides II.

El algoritmo de Euclides encuentra el mÃ¡ximo comÃºn divisor de dos enteros. Este algoritmo usa
divisiones y restas y estÃ¡ basado principalmente en las identidades

mcd ( a, b) = mcd (b, a âˆ’ bq), mcd (r, 0) = r,

de tal manera que si a = bq + r1 y b = r1 q1 + r2 con 0 â‰¤ r2 < r1 < b,

mcd ( a, b) = mcd (b, r1 ) = mcd (r1 , r2 ),

es decir, conforme aplicamos esta relaciÃ³n, cambiamos el cÃ¡lculo del mcd de dos nÃºmeros a y b
por el mcd de dos nÃºmeros mÃ¡s pequeÃ±os. El proceso es finito y se detiene cuando encontramos
un resto nulo8 .
Formalmente: Sean a y b nÃºmeros naturales, b 6= 0. Aplicando el algoritmo de la divisiÃ³n se
obtiene una sucesiÃ³n finita r1 , r2 , ..., rn definida por

a
b
r1
r n âˆ’2
r n âˆ’1

= bq1 + r1 ,
= r1 q2 + r2 ,
= r2 q3 + r3 ,
..
.

0 â‰¤ r1 < r0
0 â‰¤ r2 < r1
0 â‰¤ r3 < r2

= r n âˆ’1 q n + r n ,
= r n q n +1 + 0

0 â‰¤ r n < r n âˆ’1

rn = mcd ( a, b) pues mcd ( a, b) = mcd (b, r1 ) = mcd (r1 , r2 ) = ... = mcd (rn , 0) = rn .

Ejemplo 8.2
Vamos a aplicar el algoritmo de Euclides para calcular mcd (89, 144). AquÃ­ estamos aplicando el algoritmo sobre dos nÃºmeros consecutivos de Fibonacci. Este tipo de pares son
los que le demandan mayor esfuerzo al algoritmo de Euclides ([13],pÃ¡gs 68-69) pues
siempre q = 1.
8 La

versiÃ³n original de Euclides no es esta, en ese tiempo no habÃ­a nociÃ³n del cero ni se consideraba a la unidad como un
divisor. Para los griegos antiguos dos enteros positivos eran o ambos iguales a la unidad o eran primos relativos o tenÃ­an
un mÃ¡ximo comÃºn divisor. La versiÃ³n original ([18],pÃ¡g 336) serÃ­a (sin usar lenguaje geomÃ©trico): Sean a, b mayores que
la unidad. Si b divide a a , el mcd es b , si el resto de dividir a por b es la unidad, los nÃºmeros son primos relativos, en
otro caso reemplace el par de valores ( a, b) por (r, b).

160

ALGORITMOS PARA EL MCD

144
89
55
34
21
13
8
5
3
2

=
=
=
=
=
=
=
=
=
=

89 Â· 1 + 55
55 Â· 1 + 34
34 Â· 1 + 21
21 Â· 1 + 13
13 Â· 1 + 8
8Â·1+5
5Â·1+3
3Â·1+2
2Â·1+1
1Â·2+0

=â‡’

mcd (89, 144)

=
=
=
=
=
=
=
=
=
=

mcd (89, 55)
mcd (55, 34)
mcd (34, 21)
mcd (21, 13)
mcd (13, 8)
mcd (8, 5)
mcd (5, 3)
mcd (3, 2)
mcd (2, 1)
mcd (1, 0) = 1.

mcd (89, 144) = 1.

8.3.1

Algoritmo e implementaciÃ³n.

La implementaciÃ³n de este algoritmo se hace solo con fines ilustrativos. El algoritmo funciona
bien si usamos r =a Mod b. Pero, para seguir el algoritmo al pie de la letra, vamos a usar restos
positivos. Se necesitan tres variables: c para el nuevo dividendo, d para el nuevo divisor y r
para el resto (positivo). La funciÃ³n que calcula q la llamamos cquo, es decir, q=cquo(a,b). La
funciÃ³n que calcula el resto positivo la llamamos crem, r=crem(a,b).

Algoritmo 8.1: MÃ¡ximo comÃºn divisor: Algoritmo de Euclides
Datos: a, b âˆˆ Z, b 6= 0.
Salida: mcd ( a, b)
1 if a = 0 then
2
return mcd ( a, b) = |b|

7

c = | a |, d = | b | ;
while d 6= 0 do
r =crem(c, d);
c = d;
d = r;

8

return mcd ( a, b) = |c|;

3
4
5
6

161

Ejemplo 8.3
Veamos como funciona el algoritmo, calculamos mcd (89, 144),
c

144

=

.

c

89

d

crem(c,d)

d

crem(c,d)

d

crem(c,d)

55 Â·1+

=

34 Â·1+

=

21 Â·1+

.

c

34

crem(c,d)

=

.

c

55

d

89 Â·1+

.

55
34
21
13

..
.
c

2

d

= 1 Â·2 + 0

mcd (89, 144) = 1.

ImplementaciÃ³n en LibreOffice. La funciÃ³n crem necesita la funciÃ³n cquo.

[Descargar]

Function cquo(a,b) As Long
Dim q As Long
If b=0 then
msgbox "Error, b=0"
Exit Function
End If
q = Int(a/b)
If b<0 Then
End If
cquo = q
End Function

q = q+1

162

ALGORITMOS PARA EL MCD

Function crem(a,b) As Long
crem = a-b*cquo(a,b) â€™rem resto positivo
End Function
Function mcdEuclides(a,b) As Long
Dim c As Long, d As Long, r As Long
If a=0 Then
c = abs(b)
Else
c=a : d=b
While d<> 0
r= crem(c,d)
c = d
d = r
Wend
End If
mcdEuclides = abs(c)
End Function

8.4

Algoritmo de Euclides con menor resto.

En la versiÃ³n â€œclÃ¡sicaâ€ del algoritmo de Euclides, el resto ri estÃ¡ entre 0 y riâˆ’1 . Podemos hacer
una pequeÃ±a variaciÃ³n para que cada nuevos resto ri estÃ© entre 0 y riâˆ’1 /2 con lo que, en general, podrÃ­a haber una reducciÃ³n en el nÃºmero de divisiones. Kronecker estableciÃ³ en 1901 que
el nÃºmero de divisiones en el algoritmo â€œcon menor restoâ€ es menor o igual que el nÃºmero de
divisiones en el algoritmo clÃ¡sico de Euclides.

Como mcd ( a, b) = mcd (| a|, |b|) vamos a suponer que a â‰¥ 0 y b > 0. Recordemos que
a = b Â· Ta/bU + r2 . 0 â‰¤ r2 < b
a = b Â· (Ta/bU + 1) âˆ’ r1 . 0 â‰¤ r1 < b
Para mejorar un poco el desempeÃ±o del algoritmo de Euclides, escogemos en cada paso el menor
resto, es decir, r = MÃ­n{r1 , r2 } = MÃ­n{| a âˆ’ b Â· Ta/bU|, | a âˆ’ b Â· (Ta/bU + 1)|}. De esta manera
r â‰¤ b/2.
El algoritmo de Euclides sigue siendo vÃ¡lido pues si tomamos el menor resto r en cada paso,
mcd ( a, b) = mcd (b, r ) y de nuevo obtenemos una sucesiÃ³n decreciente de restos, el Ãºltimo resto
no nulo |rn | es el mcd de a y b. Por supuesto,
r = MÃ­n{r1 , r2 } = a âˆ’ b Â· Ta/b + 1/2U.

163

Ejemplo 8.4
Vamos a aplicar el algoritmo de Euclides, usando el menor resto, para calcular
mcd (89, 144). Como mcd ( a, b) = mcd (| a|, |b|), en cada paso usamos dividendo y
divisor positivo.

144
89
34
13
5
2

=
=
=
=
=
=

89 Â· 2 âˆ’ 34
34 Â· 3 âˆ’ 13
13 Â· 3 âˆ’ 5
5Â·3+2
2Â·2+1
1Â·2+0

=â‡’

mcd (89, 144)

=
=
=
=
=
=

mcd (89, 34)
mcd (34, 13)
mcd (13, 5)
mcd (5, 2)
mcd (2, 1)
mcd (1, 0) = 1

mcd (89, 144) = 1.

8.4.1

ImplementaciÃ³n.

La implementaciÃ³n es la misma que la del algoritmo de Euclides clÃ¡sico. Solo vamos a cambiar la
funciÃ³n crem(a,b) por la nueva funciÃ³n srem(a,b)= a âˆ’ b Â· Ta/b + 1/2U. El valor absoluto no es
necesario porque lo que interesa en el algoritmo es que los restos disminuyan (en valor absoluto).

â€™-------- LibreOffice Basic
Function mcdMenorResto(a,b) As Long
Dim c As Long, d As Long, r As Long
If a=0 Then
c = b
Else
c=a
d=b
While d<> 0
r = c-d*Int(c/d+1/2) â€™rem q= Int(c/d+1/2)
c = d
d = r
Wend
End If
mcdMenorResto = Abs(c)
End Function

Por ejemplo, si imprimimos cada paso de la implementaciÃ³n con a = âˆ’144 y b = âˆ’89, se obtiene

164

ALGORITMOS PARA EL MCD

-144 = -89*2

+ 34

mcd(-144,-89)= mcd(89,34)

-89

=

34*-3

+ 13

= mcd(34,13)

34

=

13*3

- 5

= mcd(13,5)

13

=

-5*-3

- 2

= mcd(5,2)

-5

=

-2*3

+ 1

= mcd(2,1)

-2

=

+ 0

= mcd(1,0)=1

8.5

1*-2

Algoritmo binario.

El algoritmo binario opera con la misma idea, cambiar mcd ( a, b) por el mcd de dos nÃºmeros
eventualmente mÃ¡s pequeÃ±os, solo que esta vez solo restamos y dividimos por 2. El algoritmo
opera con las siguientes teoremas,


a b
Regla 1. Si a, b son pares, mcd ( a, b) = 2 mcd
,
2 2

Regla 2. Si a es par y b impar, mcd ( a, b) = mcd



a
,b
2






| a âˆ’ b|
| a âˆ’ b|
Regla 3. Si a, b son impares, mcd ( a, b) = mcd
, b = mcd
,a
2
2



La regla 3 se aplica como mcd ( a, b) = mcd


| a âˆ’ b|
, MÃ­n{ a, b} . La prueba de estas reglas estÃ¡n
2

al final de esta secciÃ³n.
El algoritmo procede asÃ­: Supongamos que a, b âˆˆ Z, a â‰¥ 0, b > 0. Si a y b son pares, aplicamos
la regla 1, digamos s veces, hasta que alguno de los dos sea impar. Al final hay que multiplicar
por 2s como compensaciÃ³n por haber usado la regla 1, s veces. Si todavÃ­a a o b es par, aplicamos la regla 2 hasta que ambos queden impares. Siendo los dos impares, aplicamos la regla 3
| a âˆ’ b|
y luego alternamos las reglas 2 y 3 conforme el cociente
sea par o impar.
2

Ejemplo 8.5
Vamos a aplicar el algoritmo de binario para calcular mcd (89, 144) y mcd (8, 48).
Recordemos que aquÃ­ la ganancia no esta en la disminuciÃ³n del nÃºmero de pasos (de

165

hecho podrÃ­an ser mÃ¡s pasos que los que utiliza el algoritmo de Euclides) sino en operar
dividiendo por 2.

mcd (89, 44)

mcd (8, 48)

= mcd (22, 89),
= mcd (11, 89),
= mcd (39, 11),
= mcd (14, 11),
= mcd (7, 11),
= mcd (2, 7),
= mcd (1, 7),
= mcd (3, 1),
= mcd (1, 1),
= mcd (0, 1),
= 1
=
=
=
=
=
=
=

2Â·
4Â·
8Â·
8Â·
8Â·
8Â·
8

mcd (4, 24),
mcd (2, 12),
mcd (1, 6)
mcd (1, 3),
mcd (1, 1),
mcd (0, 1),

por Regla 2
por Regla 2
por Regla 3
por Regla 3
por Regla 2
por Regla 3
por Regla 2
por Regla 2
por Regla 3
por Regla 3

por Regla 1
por Regla 1
por Regla 1
por Regla 2
por Regla 3
por Regla 3

Por supuesto, en cÃ¡lculo manual terminamos cuando obtenemos mcd (0, d) = d o
mcd (1, d) = 1.

El algoritmo funciona pues la aplicaciÃ³n de las reglas va produciendo una sucesiÃ³n de pares
tal que si ( a0 , b0 ) y ( a00 , b00 ) son dos pares consecutivos, entonces 0 â‰¤ a0 b0 < a00 b00 . Este un proceso finito que nos lleva hasta el par mcd (0, d). Para ver esto, observemos que la regla 1 y la
regla 2 siempre llevan a la regla 3. Al aplicar esta regla al nuevo par ( a, b), si a = b nos queda
bâˆ’a
< b/2 < b,
mcd (0, mÃ­n{ a, b}) y terminamos; sino, supongamos que 0 < a < b, entonces
2
b
âˆ’
a
es decir, en esta regla 3 cambiamos a y b por a0 = a y b0 =
< b, por tanto el nuevo
2
0
0
0
0
par ( a , b ) cumple a b < ab. El algoritmo termina cuando obtenemos el par (0, d) y entonces
mcd ( a, b) = 2s Â· mcd (0, d) = 2s Â· d.

8.5.1

Algoritmo e ImplementaciÃ³n.

En la primera parte del algoritmo,si a y b 6= 0 son pares, se dividen ambos por dos hasta que
uno de los dos sea impar.
Luego, mientras a 6= 0, si uno es par y el otro impar, aplicamos la regla dos hasta ambos sean
impares. Una vez que los dos son impares, aplicamos la regla tres. Las reglas dos y tres se aplican mientras a = Abs( a âˆ’ b)/2 no se anule.

166

ALGORITMOS PARA EL MCD

AquÃ­ suponemos que a, b âˆˆ Z, a â‰¥ 0, b > 0. La divisiÃ³n por 2, denotada quo ( a, 2) en el algoritmo, se hace con la divisiÃ³n entera usual a\2.

Algoritmo 8.2: Algoritmo binario para el mcd
Datos: a, b âˆˆ Z, a â‰¥ 0, b > 0
Salida: mcd ( a, b)
1 g = 1;
2 while rem( a, 2) = 0 And rem( b, 2) = 0 do
3
a = quo ( a, 2), b = quo (b, 2);
4
g = 2g //removiendo potencias de 2
5

while a 6= 0 do // Ahora, a o b es impar

6
7
8
9
10
11

if rem( a, 2) = 0 then
a = quo ( a, 2)
else if rem(b, 2) = 0 then
b = quo (b, 2)
else ; // ambos impares

12
13
14

t = quo (| a âˆ’ b|, 2) ;
if a â‰¥ b then ; // reemplazamos maÌx{ a, b} con quo (| a âˆ’ b|, 2)

15
16
17
18

a=t
else
b=t

19
20

return g Â· b;

ImplementaciÃ³n en LibreOffice. La implementaciÃ³n es directa. Usamos a\b para la divisiÃ³n
por dos y â€˜a Mod 2=0â€™ como prueba de paridad.

[Descargar]

167

Function mcdBinario(u,v) As Long
Dim t As Long,

g As Long, a As Long, b As Long

g=1
a=Abs(u) : b=Abs(v)
While a Mod 2=0 And b Mod 2 = 0
a=a\2
b=b\2
g=2*g
Wend
While a <> 0
a Mod 2 = 0 Then

If

a=a\2
b Mod 2 =0

ElseIf

Then

b=b\2
Else

t=Abs(a-b)/2
If

a >= b Then
a=t

Else b=t
End If
End If
Wend
mcdBinario=g*b
End Function

Prueba de las reglas. La prueba de las reglas es como sigue.

a b
,
. Por el teorema de Bezout, d es la
2 2
mÃ­nima combinaciÃ³n lineal positiva de a y b. Si d = ax + by > 0, como a y b son pares, d es par
d
a
b
y podemos dividir a ambos lados por 2,
= x + â‰¥ d0 por ser d0 es la mÃ­nima combinaciÃ³n
2
2
2
lineal positiva de a/2 y b/2. Por tanto d â‰¥ 2d0 . De manera anÃ¡loga se prueba que 2d0 â‰¥ d, con
lo cual se concluye d = 2d0 .

Prueba de la regla 1. Sean d = mcd ( a, b) y d0 = mcd




a
Prueba de la regla 2. Sean d = mcd ( a, b) y
= mcd
, b . Como d|b y b es impar, d es
2
a
k
impar. Si a = kd, como a es par y d impar, tenemos que k es par, entonces = d, por tanto
2
2
d|( a/2) y d|b, es decir, d â‰¤ d0 . Ahora como d0 |( a/2), a/2 = k0 d0 , es decir a = 2k0 d0 , por tanto
d0 | a, entonces d0 | a y d0 |b, asÃ­ d0 â‰¤ d. âˆ´ d = d0 .
d0




| a âˆ’ b|
Prueba de la regla 3. Sean d = mcd ( a, b) y
= mcd
, b . Como d| a y d|b entonces
2
d|| a âˆ’ b|. Como a es impar, d es impar pero | a âˆ’ b| es par ( a y b son impares), luego si
| a âˆ’ b|
k
| a âˆ’ b| = kd, k debe ser par, asÃ­ que podemos dividir por dos a ambos lados,
= d.
2
2
Por tanto d|(| a âˆ’ b|/2) y d|b, entonces d â‰¤ d0 . De manera similar, si b = k0 d0 y | a âˆ’ b| = 2k00 d0 ,
sustituyendo b en la Ãºltima ecuaciÃ³n obtenemos que d0 | a. Por tanto d0 â‰¤ d y entonces d = d0 .
d0



168

ALGORITMOS PARA EL MCD

8.6

Algoritmo LSBGCD (left-shift binary algorithm)

Este algoritmo debe su nombre al hecho de que se hace multiplicaciÃ³n por 2. En representaciÃ³n
binaria el efecto de multiplicar por dos es un desplazamiento (en una posiciÃ³n), de la representaciÃ³n binaria original, hacia la izquierda.
En este algoritmo se encuentra s âˆˆ N tal que
2s Â· b â‰¤ a â‰¤ b Â· (2s+1 ) y, como en el algoritmo de Euclides con menor resto, se toma r como el menor
resto entre a âˆ’ 2s Â· b y b Â· 2s+1 âˆ’ a.
0

De esta manera tenemos en el primer paso a = b Â· 2s Â± r =â‡’ mcd ( a, b) = mcd (b, r ); donde s0
es s o s + 1 dependiendo que cual resto sea el menor.
Ejemplo 8.6
Sea a = 55367 y b = 28731. En cada paso tomamos el menor resto r = mÃ­n{ a âˆ’ 2s Â· b, b Â·
2s +1 âˆ’ a } .
55367
28731
4789
2095
599
301
83
13
3
1

=
=
=
=
=
=
=
=
=
=

28731 Â· 21 âˆ’ 2095
2095 Â· 24 âˆ’ 4789
2095 Â· 21 + 599
599 Â· 22 âˆ’ 301
301 Â· 21 âˆ’ 3
3 Â· 27 âˆ’ 83
3 Â· 25 âˆ’ 13
3 Â· 22 + 1
1 Â· 21 + 1
1 Â· 20 + 0

=â‡’

mcd (55367, 28731)

=
=
=
=
=
=
=
=
=
=

mcd (28731, 2095)
mcd (2095, 4789)
mcd (2095, 599)
mcd (599, 301)
mcd (301, 3)
mcd (3, 83)
mcd (3, 13)
mcd (3, 1)
mcd (1, 1)
mcd (1, 0) = 1

Como se observa, la sucesiÃ³n de restos no es una sucesiÃ³n estrictamente decreciente, pero cada
resto ri estÃ¡ en un intervalo [0, di ] y el nuevo resto ri+1 estÃ¡ en en un intervalo [0, di+1 ] âŠ‚ [0, di ] ,
es decir, cada nuevo ri+1 estÃ¡ en un intervalo cada vez mÃ¡s pequeÃ±o.
Esto es asÃ­ pues si a > b, a = b Â· 2s1 + r1 =â‡’ 0 â‰¤ r1 < b Â· 2s1 . Si r1 > 0. En el siguiente paso
tendrÃ­amos dos casos posibles,
a.) si b > r1 entonces b = r1 Â· 2s2 + r2 =â‡’ 0 â‰¤ r2 < r1 Â· 2s2 < b Â· 2s1 . Si r2 > 0, la Ãºltima desigualdad se cumple pues si r1 Â· 2s2 â‰¥ b Â· 2s1 entonces b = r1 Â· 2s2 + r2 â‰¥ b Â· 2s1 + r2 (â‡’â‡).
b.) si r1 > b entonces r1 = b Â· 2s2 + r2 =â‡’ 0 â‰¤ r2 < b Â· 2s2 < b Â· 2s1 . Si r2 > 0, la Ãºltima desigualdad se cumple pues si b Â· 2s2 â‰¥ b Â· 2s1 entonces r1 = b Â· 2s2 + r2 â‰¥ b Â· 2s1 + r2 , por tanto
a = b Â· 2s1 + r1 â‰¥ b Â· 2s1 + b Â· 2s1 + r2 > b Â· 2s1 +1 en contradicciÃ³n con la escogencia de s1 (ver
figura 8.6).
Si llamamos a los nuevos dividendos d1 = b, d2 , d3 , etc., entonces en el nâˆ’Ã©simo resto tendrÃ­amos
0 â‰¤ rn < dn Â· 2sn < dnâˆ’1 Â· 2snâˆ’1 < ... < b Â· 2s1

169

Es decir, cada nuevo resto ri estÃ¡ en un intervalo [0, di Â· 2si ] cada vez mÃ¡s pequeÃ±o. Como el
nÃºmero de intervalos es finito, la sucesiÃ³n de restos es finita y por tanto en algÃºn momento
rn+1 = 0.
Este algoritmo no es tan rÃ¡pido como el algoritmo binario, pero su versiÃ³n extendida si es mÃ¡s
eficiente que la versiÃ³n extendida de Euclides y la versiÃ³n extendida del algoritmo binario.

8.6.1

Algoritmo e ImplementaciÃ³n.

El algoritmo es como sigue,

Algoritmo 8.3: Algoritmo LSBGCD

6

Datos: a, b âˆˆ Z+ y a > b
Salida: mcd ( a, b)
while b 6= 0 do
Calcule s tal que b Â· 2s â‰¤ a < 2s+1 b;
t = MÃ­n{ a âˆ’ b Â· 2s , b Â· 2s+1 âˆ’ a};
a = b; b = t;
if a < b then
Intercambiar( a, b)

7

return a

1
2
3
4
5

ImplementaciÃ³n en LibreOffice. Necesitamos una funciÃ³n Min(a,b). Aunque podemos usar
la funciÃ³n MÃ­n de Calc (vÃ­a createUnoService("com.sun.star.sheet.FunctionAccess")), aquÃ­ no
vamos a usar esta posibilidad, mÃ¡s bien usamos una funciÃ³n sencilla.

Function Min (a,b) As Long
Dim m As Long
m=a
If a>b Then m=b
End If
Min= m
End Function

â€™------ LibreOffice Basic

170

ALGORITMOS PARA EL MCD

Function LSBMCD(u,v) As Long
Dim a As Long, b As Long, t As Long, aux As Long
Dim s As Integer
a=Abs(u) : b=Abs(v)

rem debe ser a>b

While b<>0
s=0
While b*2^s <=a
s=s+1
Wend
s = s-1 : t=Min(a-b*2^s,b*2^(s+1)-a) : a = b : b = t
If a<b Then

aux=a

: a=b : b=aux

End If
Wend
LSBMCD = a
End Function

8.7

Algoritmo Extendido de Euclides.

Como ya habÃ­amos visto, el mÃ¡ximo comÃºn divisor mcd ( a, b) se puede expresar como una
combinaciÃ³n lineal de a y b.
Teorema 8.2 (Identidad de BÃ©zout)
Si a, b son dos enteros no ambos cero, existen sn , tn âˆˆ Z (no Ãºnicos) tales que sn a + tn b =
mcd ( a, b) donde sn y tn se definen recursivamente como
sj

= s jâˆ’2 âˆ’ q jâˆ’1 s jâˆ’1, para j = 2, 3, ..., n

s0

= 1, s1 = 0

tj

= t jâˆ’2 âˆ’ q jâˆ’1 t jâˆ’1, para j = 2, 3, ..., n

t0

= 1, t1 = 0

donde qkâˆ’1 es el cociente en el kâˆ’Ã©simo paso en el algoritmo de Euclides. En particular rk =
rkâˆ’2 âˆ’ rkâˆ’1 qkâˆ’1 y rk = sk a + tk b.
Como se ve, la implemntaciÃ³n a partir del teorema es directa.

8.8

Inversos multiplicativos en Zm

Si mcd ( a, m) = 1 entonces a tiene inverso x = aâˆ’1 , es decir, ax â‰¡ 1 (mod m). Este inverso es
Ãºnico mÃ³dulo m. Entonces, determinar el inverso de a mÃ³dulo m es equivalente a resolver la
congruencia ax â‰¡ 1 (mod m). Si mcd ( a, m) = 1, existen s, t âˆˆ Z tal que sa + tm = 1, con lo que

171

tenemos la soluciÃ³n x = s. En la prÃ¡ctica tomamos aâˆ’1 = rem(s, m).

Algoritmo 8.4: Inverso Multiplicativo mod m.
Datos: a âˆˆ Zm , m > 1
Salida: aâˆ’1 si mcd ( a, m) = 1.
1 Calcular s, t tal que sa + tm = mcd ( a, m ) ;
2 if mcd ( a, m ) > 1 then
3
aâˆ’1 no existe
4 else
5
return rem(s, m)

Java: Para calcular el inverso multiplicativo (si existe) se puede usar el mÃ©todo modInverse() de
la clase BigInteger. Por ejemplo, el cÃ³digo que sigue calcula e imprime en consola el inverso de
5 mÃ³dulo 7

BigInteger b = new BigInteger("5");
System.out.println(b.modInverse(new BigInteger("7")));

172

ALGORITMOS PARA EL MCD

VersiÃ³n actualizada de este libro: https://tecdigital.tec.ac.cr/revistamatematica/Libros/

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

235711
131719
232931
235711

9
9.1

NÃšMEROS PRIMOS Y
FACTORIZACIÃ“N.

IntroduccciÃ³n

En estos capÃ­tulos vamos a usar LibreOffice Basic para cÃ¡lculos pequeÃ±os y Java para cÃ¡lculos
un poco mÃ¡s grandes.
Java. Suponemos que tiene Java instalado en su sistema. En Java, cada algoritmo serÃ¡ un mÃ©todo
en la clase Teoria_Numeros.class. Las corridas las hacemos en la consola (terminal). Los algoritmos son implementados como mÃ©todos pÃºblicos y estÃ¡ticos en esta clase.
Recordemos que los mÃ©todos pÃºblicos y estÃ¡ticos los podemos llamar en la clase y desde
otras clases (que estÃ©n en el mismo folder) sin tener que construir un objeto â€œTeoria_Numerosâ€.
Todos los programa se pueden descargar aquÃ­
Esta clase importa la clase â€œBigIntegerâ€. TambiÃ©n vamos a implementar y usar una clase BigRational.
La plantilla de esta clase serÃ­a algo como,

import java.math.BigInteger;
import java.util.*;
public class Teoria_Numeros
{
static final BigInteger ZERO=new BigInteger("0");
static final BigInteger ONE=new BigInteger("1");
static final BigInteger TWO=new BigInteger("2");
static final BigInteger THREE=new BigInteger("3");
static final BigInteger FOUR=new BigInteger("4");
//--------------------- M\â€™etodos---------------------------------//
//----------------------------------------------------------------//
public static void main(String[] args)
{
BigInteger a

= new BigInteger("34423453453535424");

BigInteger b

= new BigInteger("-13444354332434344");

173

174

NÃšMEROS PRIMOS Y FACTORIZACIÃ“N.

BigInteger p,q;
BigInteger ls[]

= new BigInteger[3];

System.out.println("\n\n"+ a);
//-------------------------------------------------------------//-------------------------------------------------------------System.out.println("\n\n");
}//fin main
}//fin de la clase

Compilar y correr un prorama Java. Para hacer las cosas super sencillas, abrimos un editor
de textos (Bloc de Notas en Windows o Gedit en Ubuntu, por ejemplo) y pegamos el cÃ³digo
y salvamos el archivo como Teoria_Numeros.java. Digamos que guardamos este archivo en la
carpeta â€˜tn/javaâ€™. En Linux harÃ­amos las cosas asÃ­:
Abrimos una terminal y vamos a la carpeta que tiene el archivo Teoria_Numeros.java, en
mi caso, estÃ¡ en el â€˜Escritorioâ€™. Usamos el comando cd para ir a ese directorio,
walter-2@walter2-desktop:~$cd /home/walter-2/Escritorio/tn/java

[Enter]

Compilamos con javac nombre.java
walter-2@walter2-desktop:~/Escritorio/tn/java$ javac Teoria_Numeros.java

[Enter]

â€œCorremos el programaâ€ con â€˜java nombreâ€™ (sin extensiÃ³n). En nuestro caso imprime el
â€˜nÃºmero grandeâ€™ a definido en el cÃ³digo.
walter-2@walter2-desktop:~/Escritorio/tn/java$ java Teoria_Numeros

Figura 9.1. Compilando y corriendo la la clase Teoria_Numeros.java

[Enter]

175

9.2

Criba de EratÃ³stenes.

Para efectos de factorizaciÃ³n es necesario tener una lista con los â€œprimeros primosâ€ porque â€˜casi
todos los nÃºmerosâ€™ tiene factores primos pequeÃ±os. Esto lo hacemos con la criba de EratÃ³stenes.
Ya habÃ­amos implementado este algoritmo en la secciÃ³n (2.3). Solo vamos a proceder a la implementaciÃ³n en Java.
ImplementaciÃ³n en Java. Vamos a agregar un mÃ©todo a nuestra clase Teoria_Numeros. El
mÃ©todo recibe el nÃºmero natural n > 2 y devuelve un vector con los nÃºmeros primos â‰¤ n. Para
colar los nÃºmeros compuestos usamos un arreglo

boolean [] esPrimo = new boolean[(n-3)/2].

Al final llenamos un vector con los primos que quedan.

import java.math.BigInteger;
import java.util.*;
public class Teoria_Numeros
{ static final BigInteger ZERO=new BigInteger("0");
static final BigInteger ONE=new BigInteger("1");
static final BigInteger TWO=new BigInteger("2");
static final BigInteger THREE=new BigInteger("3");
//--------------------- M\â€™etodos---------------------------------//
public static Vector Primos(int n)
{

Vector
int k

salida = new Vector(1);
= 1;

int max = (n-3)/2;
boolean[]

esPrimo

= new boolean[max+1];

for(int i = 0; i <= max; i++)
esPrimo[i]=true;
for(int i = 0; (2*i+3) <= n/(2*i+3); i++)
{
k = i+1;
if(esPrimo[i])
{
while( 2*k+1<= n/(2*i+3) )
{
esPrimo[((2*k+1)*(2*i+3)-3)/2]=false;
k++;
}
}
}

176

NÃšMEROS PRIMOS Y FACTORIZACIÃ“N.

salida.addElement(new Integer(2));
for(int i = 0; i <=max; i++)
{ if(esPrimo[i])
salida.addElement(new Integer(2*i+3));
}
salida.trimToSize();
return salida;
}//Fin M\â€™todo Primos
//----------------------------------------------------------------//
public static void main(String[] args)
{
System.out.println("\n\n");
//-------------------------------------------------------------n = 20;

int

Vector primos;
primos = Primos(n);
//Cantidad de primos <= n
System.out.println("Primos <="+ n+": "+primos.size()+"\n");
//Imprimir vector (lista de primos)
for(int p = 1; p < primos.size(); p++)
{
Integer num = (Integer)primos.elementAt(p);
System.out.println(""+(int)num.intValue());
}
//-------------------------------------------------------------System.out.println("\n\n");
}//fin main
}//fin de la clase

Una corrida con n = 20 nos da la salida en terminal que sigue,
walter-2@walter2-desktop:~/Escritorio/tn/java$ javac Teoria_Numeros.java
Note: Teoria_Numeros2.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
walter-2@walter2-desktop:~/Escritorio/tn/java$ java
Primos <=20: 8
3
5
7
11
13
17
19
walter-2@walter2-desktop:~/Escritorio/tn/java$

Teoria_Numeros

177

Uso de la memoria. En teorÃ­a, los arreglos pueden tener tamaÃ±o mÃ¡ximo Integer.MAX_INT =
231 âˆ’ 1 = 2 147 483 647 (pensemos tambiÃ©n en la posibilidad de un arreglo multidimensional!).
Pero en la prÃ¡ctica, el mÃ¡ximo tamaÃ±o del array depende del hardware de la computadora.
El sistema le asigna una cantidad de memoria a cada aplicaciÃ³n; para valores grandes de n
puede pasar que se nos agote la memoria (veremos el mensaje â€œOutOfMemory Errorâ€). Podemos
asignar una cantidad de memoria apropiada para el programa â€œcribaEratostenes.javaâ€ desde la
lÃ­nea de comandos, si n es muy grande. Por ejemplo, para calcular los primos menores que
n = 100 000 000, se puede usar la instrucciÃ³n
walter-2@walter2-desktop:~/Escritorio/tn/java$ java -Xmx1000m -Xms1000m Teoria_Numeros

Esta instrucciÃ³n asigna al programa una memoria inicial (Xmx) de 1000 MB y una memoria
mÃ¡xi-ma (Xms) de 1000 MB (siempre y cuando existan tales recursos de memoria en nuestro
sistema).
En todo caso hay que tener en cuenta los siguientes datos

n
Primos â‰¤ n
10
4
100
25
1 000
168
10 000
1 229
100 000
9 592
1 000 000
78 498
10 000 000
664 579
100 000 000
5 761 455
1 000 000 000
50 847 534
10 000 000 000
455 052 511
100 000 000 000
4 118 054 813
1 000 000 000 000
37 607 912 018
10 000 000 000 000
346 065 536 839

9.3

Primos entre m y n.

Para encontrar todos los primos entre m y n (con 3 â‰¤ m < n ) procedemos como si estuvieramos
colando primos en la lista {2, 3, ..., n}, solo que esta vez, eliminamos los mÃºltiplos que estÃ¡n entre
âˆš
m y n : Eliminamos los mÃºltiplos de los primos p para los cuales p2 â‰¤ n (o tambiÃ©n p â‰¤ n ),
que estÃ¡n entre m y n.

MÃºltiplos de p entre m y n. Para los primos p inferiores a
p entre m y n.
Si m âˆ’ 1 = pq + r, 0 â‰¤ r < p =â‡’ p(q + 1) â‰¥ m

âˆš

n, buscamos el primer mÃºltiplo de

178

NÃšMEROS PRIMOS Y FACTORIZACIÃ“N.

AsÃ­, los mÃºltiplos de p mayores o iguales a m son
p(q + 1), p(q + 2), p(q + 3), ... con q = quo(m âˆ’ 1, p)

Ejemplo 9.1
Para encontrar
âˆš los primos entre m = 10 y n = 30, debemos eliminar los mÃºltiplos de los
primos â‰¤ 30 â‰ˆ 5. Es decir, los mÃºltiplos de los primos p = 2, 3, 5.

Como 10 âˆ’ 1 = 2 Â· 4 + 1, el 2 elimina los nÃºmeros 2(4 + k ) = 8 + 2k, k â‰¥ 1; es decir
{10, 12, ..., 30}
Como 10 âˆ’ 1 = 3 Â· 3 + 0, el 3 elimina los nÃºmeros 3(3 + k ) = 9 + 3k, k â‰¥ 1; es decir
{12, 15, 18, 21, 24, 27, 30}
Como 10 âˆ’ 1 = 5 Â· 1 + 4, el 5 elimina los nÃºmeros 5(1 + k ) = 5 + 5k, k â‰¥ 1; es decir
{10, 15, 20, 25.}
Finalmente nos quedan los primos 11, 13, 17, 19, 23, 29.

9.3.0.1 Algoritmo e implementaciÃ³n Como antes, solo consideramos los impares entre m y
n. Recordemos que si x âˆˆ R y si n â‰¤ x < n + 1 con n âˆˆ Z, entonces la parte entera de x es n .
Se escribe JxK = n.
Sean n, m nÃºmeros naturales tales que 3 â‰¤ m < n. Sea A el conjunto de nÃºmeros impares entre
m y n.
El primer impar de A es 2 Â·

r

El Ãºltimo impar de A es 2 Â·

q n âˆ’3 y

m +1âˆ’3
2

2

z

+3

+3

n
r
z
q 3 yo
âˆ´ El conjunto de impares entre m y n es A = 2 Â· i + 3 : i = m+21âˆ’3 , Â· Â· Â· , nâˆ’
.
2
Si ponemos min = quo(m + 1 âˆ’ 3, 2) y max = quo(n âˆ’ 3, 2), los impares entre m y n son los
elementos del conjunto {2 Â· i + 3 : i = min, ..., max }
Como antes, usamos un arreglo booleano esPrimo(i) con i = min, ..., max. esPrimo(i) representa
al nÃºmero 2 Â· i + 3.

179

Ejemplo 9.2

Si m = 11 y 20, J(m + 1 âˆ’ 3)/2K = 4 y J(n âˆ’ 3)/2K = 8. Luego, el,primer impar es
2 Â· 4 + 3 = 11 y el Ãºltimo impar es 2 Â· 8 + 3 = 19.

âˆš
Para aplicar el colado necesitamos los primos â‰¤ n. Esta lista de primos la obtenemos con la
funciÃ³n Eratostenes(isqrt(n)). AquÃ­ hacemos uso del mÃ©todo BIsqrt(n)donde n es BigInteger
(Ver ApÃ©ndice ??). Para cada primo pi en la lista,

a.) si m â‰¤ p2i , tachamos los mÃºltiplos impares de pi como antes,

1
2
3
4
5

if m â‰¤ p2i then
k = ( pi âˆ’ 1)/2 ;
while (2k + 1) pi â‰¤ n do
esPrimo[((2k + 1) pi âˆ’ 3)/2] =False;
k = k + 1;

Note que si k = ( pi âˆ’ 1)/2 entonces (2k + 1) pi = p2i
b.) si p2i < m, tachamos desde el primer mÃºltiplo impar de pi que supere m :
Los mÃºltiplos de pi que superan m son pi (q + k) con q = quo(m âˆ’ 1, p). De esta lista solo
nos interesan los mÃºltiplos impares. Esto requiere un pequeÃ±o anÃ¡lisis aritmÃ©tico.

Como pi es impar, pi (q + k) es impar solo si q + k es impar. Poniendo q2 = rem(q, 2)
entonces (2k + 1 âˆ’ q2 + q) es impar si k = q2 , q2 + 1, ... . En efecto,


2k + 1 âˆ’ q2 + q =

2k + 1 + q
2k + q

si
si

q es par. AquÃ­ k = q2 = 0, 1, ...
q es impar. AquÃ­ k = q2 = 1, 2, ...

Luego, los mÃºltiplos impares de pi que superan m son los elementos del conjunto

{(2k + 1 âˆ’ q2 + q) Â· pi : q2 = rem(q, 2) y k = q2 , q2 + 1, ...}

La manera de tachar los mÃºltiplos impares de pi es

180

1
2
3
4
5
6

NÃšMEROS PRIMOS Y FACTORIZACIÃ“N.

if p2i < m then
q = (m âˆ’ 1)/p; q2 = rem(q, 2); k = q2 ; mp = (2k + 1 âˆ’ q2 + q) Â· pi ;
while mp â‰¤ n do
esPrimo[(mp âˆ’ 3)/2] =False;
k = k + 1;
mp = (2k + 1 âˆ’ q2 + q) Â· pi

Algoritmo 9.1: Colado de primos entre m y n.
Datos: n, m âˆˆ N con m < n.
Salida: Primos entre m y n
âˆš
1 Primo() = una lista de primos â‰¤
n;
2 min = ( m + 1 âˆ’ 3) /2; max = ( n âˆ’ 3) /2 ;
3 esPrimo [i ], i = min, ..., max ;
4 for j = min, ..., max do
5
esPrimo [ j] =True;
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22

23
24
25
26

np = cantidad de primos en la lista Primos;
Suponemos Primo(0) = 2;
for i = 1, 2, ..., np do
if m â‰¤ p2i then
k = ( pi âˆ’ 1)/2 ;
while (2k + 1) pi â‰¤ n do
esPrimo[((2k + 1) pi âˆ’ 3)/2] =False;
k = k + 1;
if p2i < m then
q = (m âˆ’ 1)/p ;
q2 = rem(q, 2) ;
k = q2 ;
mp = (2k + 1 âˆ’ q2 + q) Â· pi ;
while mp â‰¤ n do
esPrimo[(mp âˆ’ 3)/2] =False;
k = k + 1;
mp = (2k + 1 âˆ’ q2 + q) Â· pi
Imprimir ;
for j = min, ..., max do
if esPrimo [ j] =True then
Imprima 2 Â· ( j + min) + 3

Ahora podemos armar el algoritmo completo.
ImplementaciÃ³n en Java. Vamos a agregar el mÃ©todo Primos(m, n) a nuestra clase â€œTeoria_Numerosâ€.
El mÃ©todo recibe dos naturales 0 â‰¤ m < n y devuelve un vector con los nÃºmeros primos entre
m y n.

181

Como antes, usamos un arreglo booleano esPrimo(i) con i = 0, ..., max âˆ’ min + 1 donde min =
(m + 1 âˆ’ 3)/2 y max = (n âˆ’ 3)/2.

âˆš
Si p es primo y p â‰¤ n, entonces si s Â· p es un mÃºltiplo impar de p entre m y n, debemos
poner esPrimo((s*p-3)/2-min)=false
Notemos que, esPrimo(i) representa al impar 2 Â· (i + min) + 3.
public class Teoria_Numeros
{
...
//--------------------- M\â€™etodos---------------------------------//
...
public static Vector Primos(int m, int n)
{
Vector

salida = new Vector(1);

int k,mip,p,q,q2;
int min = (m+1-3)/2;
int max = (n-3)/2;
int total = max-min+1;
int sqrtn = BIsqrt(new BigInteger(""+n)).intValue();
boolean[]

esPrimo

= new boolean[max+1];

Vector primos;
primos = Primos(sqrtn);
if(0<= m && m < 3)
return Primos(n);
for(int i = 0; i < total; i++)
esPrimo[i]=true;
//primos(0)=2, inicia en primos(1)=3
for(int i = 1; i< primos.size() ; i++)
{ p =((Integer)primos.elementAt(i)).intValue();

182

NÃšMEROS PRIMOS Y FACTORIZACIÃ“N.

if(p*p<m)
{ q=(m-1)/p;
q2=q%2;
k=q2;
mip=(2*k+1-q2+q)*p;
while(mip<=n)
{
esPrimo[(mip-3)/2-min]=false;
k= k+1;
mip=(2*k+1-q2+q)*p;
}
}
}
//Imprimir
for(int i = 0; i < total; i++)
if(esPrimo[i])
salida.addElement(new Integer(2*(i+min)+3));
salida.trimToSize();
return salida;
}// Primos n,m
public static BigInteger BIsqrt(BigInteger n)
{

BigInteger DOS

= new BigInteger("2");

BigInteger xkm1 = n.divide(DOS);
BigInteger xk

= n;

if(n.compareTo(BigInteger.ONE)< 0)
return xkm1=n;
while(xkm1.compareTo(xk)<0)
{
xk=xkm1;
xkm1=xkm1.add(n.divide(xkm1));
xkm1=xkm1.divide(DOS);
}
return xkm1;
}//BIsqrt
//----------------------------------------------------------------//
public static void main(String[] args)
{
System.out.println("\n\n");
//-------------------------------------------------------------//primos entre m,n
int m

= 20;

int n = 50;
Vector primosmn;
primosmn = Primos(m,n);
for(int j = 0; j < primosmn.size(); j++)
{

Integer num = (Integer)primosmn.elementAt(j);
System.out.println(""+(int)num.intValue());

}
//-------------------------------------------------------------System.out.println("\n\n");
}//fin main
}//fin de la clase

183

La corrida, usando n = 20 y m = 50, entrega el siguiente resultado,
walter-2@walter2-desktop:~/Escritorio/tn/java$ javac
walter-2@walter2-desktop:~/Escritorio/tn/java$ java

Teoria_Numeros.java
Teoria_Numeros

23
29
31
37
41
43
47
walter-2@walter2-desktop:~/Escritorio/tn/java$

9.4

FactorizaciÃ³n por ensayo y error.

El mÃ©todo mÃ¡s sencillo de factorizaciÃ³n (y muy Ãºtil) es el mÃ©todo de factorizaciÃ³n por ensayo y
error (FEE). Este mÃ©todo va probando con los posibles divisores de n hasta encontrar un factor
de este nÃºmero.
En vez de probar con todos los posibles divisores de n (es decir, en vez de usar fuerza bruta)
podemos hacer algunos refinamientos para lograr un algoritmo mÃ¡s eficiente en el sentido de
reducir las pruebas a un conjunto de nÃºmeros mÃ¡s pequeÃ±o, en el que se encuentren los divisores
pequeÃ±os de n.

9.4.1

Probando con una progresiÃ³n aritmÃ©tica.

Como estamos buscando factores pequeÃ±os de n, podemos usar el teorema,

Teorema 9.1
Si n âˆˆ Z+ admite la factorizaciÃ³n n = ab, con a, b âˆˆ Z+ entonces a â‰¤

âˆš

n o bâ‰¤

âˆš

n.

Del teorema anterior se puede deducir que

â€¢ Si n no tiene factores d con 1 < d â‰¤

âˆš

n, entonces n es primo.

âˆš
â€¢ Al menos uno de los factores de n es menor que
n (no necesariamente todos). Por ejemâˆš
plo 14 = 2 Â· 7 solo tiene un factor menor que 14 â‰ˆ 3.74166).

De acuerdo al teorema fundamental de la aritmÃ©tica, cualquier nÃºmero natural > 1 factoriza, de
manera Ãºnica (excepto por el orden) como producto de primos. Esto nos dice que la estrategia

184

NÃšMEROS PRIMOS Y FACTORIZACIÃ“N.

âˆš
Ã³ptima de factorizaciÃ³n serÃ­a probar con los primos menores que n. El problema es que si n
es muy grande , el cÃ¡lculo de los primos de prueba durarÃ­a siglos (sin considerar los problemas
de almacenar estos nÃºmeros).
Recientemente (2005) se factorizÃ³ un nÃºmero de 200 cifras9 (RSA-200). Se tardÃ³ cerca de 18 meses
en completar la factorizaciÃ³n con un esfuerzo computacional equivalente a 53 aÃ±os de trabajo de
un CPU 2.2 GHz Opteron.

9.4.2

Algoritmo.

Identificar si un nÃºmero es primo es generalmente fÃ¡cil, pero factorizar un nÃºmero (grande)
arbitrario no es sencillo. El mÃ©todo de factorizaciÃ³n de un nÃºmero N probando con divisores
primos (â€œtrial divisionâ€) consiste en probar dividir N con primos pequeÃ±os. Para esto se debe
previamente almacenar una tabla suficientemente grande de nÃºmeros primos o generar la tabla
cada vez. Como ya vimos en la criba de EratÃ³stenes, esta manera de proceder trae consigo problemas de memoria. En realidad es mÃ¡s ventajoso proceder de otra manera.

Para hacer la pruebas de divisibilidad usamos los enteros 2, 3 y la sucesiÃ³n 6k Â± 1, k =
1, 2, ... .
Esta elecciÃ³n cubre todos los primos e incluye divisiones por algunos nÃºmeros compuestos
(25,35,...) pero la implementaciÃ³n es sencilla y el programa suficientemente rÃ¡pido (para
nÃºmeros no muy grandes) que vale la pena permitirse estas divisiones inÃºtiles.

En general, debemos decidir un lÃ­mite G en la bÃºsqueda de divisores. Si se divide Ãºnicamente por divisores primos â‰¤ G, se harÃ­an Ï€ ( G ) â‰ˆ G/ ln G divisiones. Si se divide por 2 ,
G/3
= 3/ ln G
3 y 6k Â± 1 se harÃ­an aproximadamente G/3 divisiones10 de las cuales
G/ ln G
6
son divisiones Ãºtiles. Si G = 10 , tendrÃ­amos â‰ˆ 22% divisiones Ãºtiles. En este caso, un
ciclo probando divisiones por primos Ãºnicamente es â‰ˆ 1/0.22 = 4.6 veces mÃ¡s lento11 .
Cuando se juzga la rapidez de un programa se toma en cuenta el tiempo de corrida en el
peor caso o se toma en cuenta el tiempo promedio de corrida (costo de corrida del programa
si se aplica a muchos nÃºmeros). Como ya sabemos (por el Teorema de Mertens) hay un
porcentaje muy pequeÃ±o de nÃºmeros impares sin divisores â‰¤ G, asÃ­ que en promedio,
nuestra implementaciÃ³n terminarÃ¡ bastante antes de alcanzar el lÃ­mite G (el â€œpeor casoâ€
no es muy frecuente) por lo que tendremos un programa con un comportamiento deseable.

Detalles de la implementaciÃ³n.
9 Se

trata del caso mÃ¡s complicado, un nÃºmero que factoriza como producto de dos primos (casi) del mismo tamaÃ±o.
Pues los nÃºmeros naturales ( â‰¤ G ) son de la forma 6k + m con m âˆˆ {0, 1, ..., 5} y solo estamos considerando m = 1, 5,
es decir una tercera parte.
11 AÃºn si se almacena previamente una tabla de primos en forma compacta, esto consume tiempo [9]
10

185

â€¢ Para la implementaciÃ³n necesitamos saber cÃ³mo generar los enteros de la forma 6k Â± 1.
Alternando el âˆ’1 y el 1 obtenemos la sucesiÃ³n

5, 7, 11, 13, 17, 19, ...
que iniciando en 5, se obtiene alternando los sumandos 2 y 4. Formalmente, si mk = 6k âˆ’ 1
y si sk = 6k + 1 entonces, podemos poner la sucesiÃ³n como

7, 11, 13, ..., mk , sk , mk+1 , sk+1 , ...
Ahora, notemos que sk = mk + 2 y que mk+1 = sk + 4 = mk + 6. La sucesiÃ³n es
7, 11, 13, ..., mk , mk + 2, mk + 6, mk+1 + 2, mk+1 + 6, ...
En el programa debemos probar si el nÃºmero es divisible por 2 , por 3 y ejecutamos el ciclo
p = 5;
While

p â‰¤ G Do {
Probar divisibilidad por p
Probar divisibilidad por p + 2
p= p+6}

âˆš
N }.
â€¢ En cada paso debemos verificar si el divisor de prueba p alcanzÃ³ el lÃ­mite MÃ­n
{
G,
âˆš
Si se quiere evitar el cÃ¡lculo de la raÃ­z, se puede usar el hecho de que si p > N entonces
p > N/p.

Algoritmo 9.2: FactorizaciÃ³n por Ensayo y Error.
âˆš
Datos: N âˆˆ N, G â‰¤ N
Salida: Un factor p â‰¤ G de N si hubiera.
1 p = 5;
2 if N es divisible por 2 o 3 then
3
Imprimir factor;
4 else
5
while p â‰¤ G do
6
if N es divisible por p o p + 2 then
7
Imprimir factor;
8
break;
9
end
10
p= p+6
11
end
12 end
ImplementaciÃ³n en Java. El programa que sigue es una clase independiente. Si se quiere, se
pueden tomar los mÃ©todos y agregarlo a la clase Teoria_Numeros.java

186

NÃšMEROS PRIMOS Y FACTORIZACIÃ“N.

Creamos una clase que
âˆš busca factores primos de un nÃºmero N hasta un lÃ­mite G. En el programa, G = MÃ­n { N, G }.
Usamos un mÃ©todo reducir(N,p) que verifica si p es factor, si es asÃ­, continua dividiendo por p
hasta que el residuo no sea cero. Retorna la parte de N que no ha sido factorizada.
El mÃ©todo Factzar_Ensayo_Error(N, G) llama al mÃ©todo reducir(N,p) para cada p = 2, 3, 7, 11, 13, ....
hasta que se alcanza el lÃ­mite G.

import java.util.Vector;
import java.math.BigInteger;
public class Ensayo_Error
{

private Vector

salida = new Vector(1);

static BigInteger Ge

= new BigInteger("10000000");//10^7

BigInteger

UNO

= new BigInteger("1");

BigInteger

DOS

= new BigInteger("2");

BigInteger

TRES

= new BigInteger("3");

BigInteger

SEIS

= new BigInteger("4");

BigInteger

Nf;

pos
= 1; //posici\â€™on del exponente del factor
_
public Ensayo Error(){} //Hay que crear el objeto
int

public BigInteger reducir(BigInteger Ne, BigInteger p)
{

int exp = 0, posAct = pos;
BigInteger residuo;
residuo =

Ne.mod(p);

if(residuo.compareTo(BigInteger.ZERO)==0)
{ salida.addElement(p); //p es objeto BigInteger
salida.addElement(BigInteger.ONE); //exponente
pos = pos+2; //posici\â€™on del siguiente exponente (si hubiera)
}
while(residuo.compareTo(BigInteger.ZERO)==0)
{Ne

=

residuo =

Ne.divide(p); // Ne = Ne/p
Ne.mod(p);

exp=exp+1;
salida.set(posAct, new BigInteger(""+exp)); //p es objeto BigInteger
}
return Ne;
}//

187

public Vector Factzar_Ensayo_Error(BigInteger Ne, BigInteger limG)
{
BigInteger p

= new BigInteger("5");

Nf = Ne;
Nf = reducir(Nf, DOS);
Nf = reducir(Nf, TRES);
while(p.compareTo(limG)<=0)
{
Nf= reducir(Nf, p);

//dividir por p

Nf= reducir(Nf, p.add(DOS)); //dividir por p+2
p = p.add(SEIS); //p=p+6
}
if(Nf.compareTo(BigInteger.ONE)>0)
{
salida.addElement(Nf); //p es objeto BigInteger
salida.addElement(BigInteger.ONE); //exponente
}
return salida;
}
public static void main(String[] args)
{
BigInteger limG;
BigInteger Nduro

= new BigInteger("2388005888439481");

BigInteger N

= new BigInteger("27633027771706698949");
= new Ensayo_Error();

Ensayo_Error Obj
Vector

factores;

factores = Obj.Factzar_Ensayo_Error(N); //factoriza
//Imprimir vector de factores primos
System.out.println("\n\n");
System.out.println("N = "+N+"\n\n");
System.out.println("Hay " +factores.size()/2+" factores primos <= " + Ge+"\n\n");
System.out.println("N = "+Obj.print(factores)+"\n\n");
System.out.println("\n\n");
}
}

Al ejecutar este programa en terminal con N = 367367653565289976655797, la salida es
walter-2@walter2-desktop:~/Escritorio/tn/java$ javac Ensayo_Error.java
walter-2@walter2-desktop:~/Escritorio/tn/java$ java Ensayo_Error
N = 27633027771706698949

188

NÃšMEROS PRIMOS Y FACTORIZACIÃ“N.

Hay 3 factores primos <= 10000000
N = 37^2 * 3671^3 * 408011^1
walter-2@walter2-desktop:~/Escritorio/tn/java$

ImplementaciÃ³n en LibreOffice. Se puede hacer una implemetaciÃ³n el LibreOffice, pero por
supuesto, como no disponemos de una clase â€˜BigIntegerâ€™, solo se pueden factorizar nÃºmeros no
mÃ¡s allÃ¡ de diez dÃ­gitos.

[Descargar]

REM

***** BASIC
Option Explicit

*****

Sub Main
Dim N, G, k
Dim factores As String
Dim factorizacion() As Long
N =

Celda("A4").Value

G =

Celda("B4").Value

G = Sqr(N)
If N < 0 Then
MsgBox ("Debe introducir un n\â€™umero natural")
Else
factorizacion() = FactorizacionEE(N, G)
If UBound(factorizacion) = 0 Then
Celda("C4").setString("")
Celda("A6").setString("Este n\â€™umero es primo")
Else

189

For k = 0 To UBound(factorizacion)
If k = 0 Then
factores = Trim(str(factorizacion(k)))
Else
factores = factores +"."+Trim(Str(factorizacion(k)))
End If
Next
Celda("A6").setString(" ")
Celda("C4").setString(factores)
End If
End If
End Sub
Function FactorizacionEE(N, g)
Dim salir As Boolean
Dim factor As Long
Dim factores() As Long
Dim p As Long, i As Long
Dim j As Long, prueba
Dim exp As Long, k
i = 0
j = 0
ReDim factores(i)
p = 5
Do
If N Mod 2 = 0 Then
factor = 2
N = N / 2
ElseIf N Mod 3 = 0 Then
factor = 3
N = N / 3
Else
While salir = False
If N Mod p = 0 Then
factor = p
N = N / p
salir = True
Else
p = p + 2
End If
If salir = False And N Mod p = 0 Then
factor = p
N = N / p
salir = True
Else
p = p + 4
End If
If salir = False And p > g Then
salir = True
factor = 0
End If
Wend
End If

190

NÃšMEROS PRIMOS Y FACTORIZACIÃ“N.

If factor = 0 Then
ReDim Preserve factores(i)
factores(i) = N
i = i + 1
Exit Do
Else
If i - 1 < 0 Then
ReDim Preserve factores(i)
factores(i) = factor
i = i + 1
Else
ReDim Preserve factores(i)
factores(i) = factor
i = i + 1
End If
p = 5
salir = False
End If
Loop Until N = 1
FactorizacionEE = factores
End Function

9.5

MÃ©todo de factorizaciÃ³n â€œrhoâ€ de Pollard.

En el mÃ©todo de factorizaciÃ³n
por ensayo y error, en su versiÃ³n mÃ¡s cruda, probamos con todos
âˆš
los nÃºmeros entre 2 y N para hallar un factor de N. Si no lo hallamos, N es primo. Con el
mÃ©todo de factorizaciÃ³n â€œrhoâ€ de Pollard podrÃ­amos encontrar factores mÃ¡s rÃ¡pido de tal manera que los factores pequeÃ±os que van quedando se pueden factorizar con el mÃ©todo de ensayo y
error.

âˆš
En el mÃ©todo â€œrhoâ€ de Pollard, en vez de hacer estos â‰ˆ âˆšN pasos (en el peor caso), vamos a
escoger una lista aleatoria de nÃºmeros, mÃ¡s pequeÃ±a que N, y probar con ellos.
A menudo se construyen sucesiones seudo-aleatorias x0 , x1 , x2 , ... usando una iteraciÃ³n de la forma
xi+1 = f ( xi ) (mod N ), con x0 = random(0, N âˆ’ 1). Entonces { x0 , x1 , ...} âŠ† Z N . Por lo tanto los
xi â€™s se empiezan a repetir en algÃºn momento.
La idea es esta: Supongamos que ya calculamos la sucesiÃ³n x0 , x1 , x2 , ... y que es â€œsuficientemente
aleatoriaâ€. Si p es un factor primo de N y si



xi
xi

â‰¡ x j (mod p)
â‰¡
/ x j (mod N )

191

entonces, como xi âˆ’ x j = kp, resulta que MCD( xi âˆ’ x j , N ) es un factor no trivial de N.
Claro, no conocemos p, pero conocemos los xi â€™s, asÃ­ que podemos revelar la existencia de p con
el cÃ¡lculo del MCD: En la prÃ¡ctica se requiere comparar, de manera eficiente, los xi con los x j
hasta revelar la presencia del factor p vÃ­a el cÃ¡lculo del MCD( xi âˆ’ x j , N ).

ï£±
ï£² xi

â‰¡ x j (mod p)

ï£³

â‰¡
/ x j (mod N )

xi

=â‡’ mcd ( xi âˆ’ x j , N ) es factor no trivial de N

Si x0 , x1 , x2 , ... es â€œsuficientemente aleatoriaâ€, hay una probabilidad muy alta de que encontremos
pronto una â€œrepeticiÃ³nâ€ del tipo xi â‰¡ x j (mod p) antes de que esta repeticiÃ³n ocurra (mod N).

Antes de entrar en los detalles del algoritmo y su eficiencia, veamos un ejemplo.

Ejemplo 9.3
Sea N = 1387. Para crear una sucesiÃ³n â€œseudoaleatoriaâ€ usamos f ( x ) = x2 âˆ’ 1 y x1 = 2.
Luego,

x0
x i +1

= 2
= xi2 âˆ’ 1 (mod N )

es decir,

{ x0 , x1 , x2 , ...} =

{2, 3, 8, 63, 1194,
1186, 177, 814, 996, 310, 396, 84, 120, 529, 1053, 595, 339,
1186, 177, 814, 996, 310, 396, 84, 120, 529, 1053, 595, 339, ...}

Luego, â€œpor inspecciÃ³nâ€ logramos ver que 1186 â‰¡
/ 8 (mod N ) y luego usamos el detector
de factores: mcd (1186 âˆ’ 8, N ) = 19. Y efectivamente, 19 es un factor de 1387. En este
caso detectamos directamente un factor primo de N.

Por supuesto, no se trata de comparar todos los xi â€™s con los x j â€™s para j < i. El mÃ©todo de factorizaciÃ³n â€œrhoâ€ de Pollard, en la variante de R. Brent, usa un algoritmo para detectar rÃ¡pidamente
un ciclo en una sucesiÃ³n ([28]) y hacer solo unas cuantas comparaciones. Es decir, queremos detectar rÃ¡pidamente xi â‰¡ x j (mod p) usando la sucesiÃ³n xi+1 = f ( xi ) (mod N ) (que alcanza un
ciclo un poco mÃ¡s tarde) y el test mcd ( xi âˆ’ x j , N ).

192

NÃšMEROS PRIMOS Y FACTORIZACIÃ“N.

âˆš
TÃ­picamente necesitamos unas O( p) operaciones. El argumento es heurÃ­stico. BÃ¡sicamente lo
que se muestra es que, como en el problema del cumpleaÃ±os, dos nÃºmeros xi y x j , tomados de
manera aleatoria, son congruentes mÃ³dulo p con probabilidad mayor que 1/2, despuÃ©s de que
âˆš
hayan sido seleccionados unos 1.177 p nÃºmeros.
âˆš
Aunque la sucesiÃ³n xi+1 = f ( xi ) (mod N ) cae en un ciclo en unas O( N ) âˆšoperaciones, es muy
âˆš
probable que detectemos xi â‰¡ x j (mod p) en unos O( p) pasos. Si p â‰ˆ N entonces encontrarÃ­amos un factor de N en unos O( N 1/4 ) pasos. Esto nos dice que el algoritmo â€œrhoâ€ de
Pollard factoriza N 2 con el mismo esfuerzo computacional con el que el mÃ©todo de ensayo y
error factoriza N.

9.5.1

Algoritmo e implementaciÃ³n.

La algoritmo original de R. Brent compara x2k âˆ’1 con x j , donde 2k+1 âˆ’ 2kâˆ’1 â‰¤ j â‰¤ 2k+1 âˆ’ 1. Los
detalles de cÃ³mo esta manera de proceder detectan rÃ¡pidamente un ciclo en una sucesiÃ³n no se
ven aquÃ­ pero pueden encontrarse en [28] y [25].

Ejemplo 9.4
Sean N = 3968039, f ( x ) = x2 âˆ’ 1 y x0 = 2. Luego,
mcd ( x1 âˆ’ x3 , N )
mcd ( x3 âˆ’ x6 , N )
mcd ( x3 âˆ’ x7 , N )
..
.
mcd ( x63 âˆ’ x96 , N )
mcd ( x63 âˆ’ x97 , N )
mcd ( x63 âˆ’ x98 , N )
mcd ( x63 âˆ’ x99 , N )
mcd ( x63 âˆ’ x100 , N )
mcd ( x63 âˆ’ x101 , N )
mcd ( x63 âˆ’ x102 , N )
mcd ( x63 âˆ’ x103 , N )

=
=
=
..
.
=
=
=
=
=
=
=
=

1
1
1
..
.
1
1
1
1
1
1
1
1987

N = 1987 Â· 1997.

El algoritmo que vamos a describir aquÃ­ es otra variante del algoritmo de Brent ([29]) que es mÃ¡s
sencillo de implementar.
DespuÃ©s de hacer la implemetaciÃ³n vamos a ver un refinameinto muy sencillo.
Se calcula MCD( xi âˆ’ x j , N ) para i = 0, 1, 3, 7, 15, ... y j = i + 1, ..., 2i + 1 hasta que, o xi = x j (mod N )
(en este caso se debe escoger una f diferente o un x0 diferente) o que un factor no trivial de N
sea encontrado.

193

Observe que si i = 2k âˆ’ 1 entonces j = 2i + 1 = 2k+1 âˆ’ 1, es decir el Ãºltimo j serÃ¡ el â€˜nuevoâ€™ i.
Por tanto, en el algoritmo actualizamos xi al final del For, haciendo la asignaciÃ³n xi = x2i+1 = x j .

Algoritmo 9.3: MÃ©todo rho de Pollard (variante de R. Brent)
Datos: N âˆˆ N, f , x0
Salida: Un factor p de N o mensaje de falla.
1 salir=false;
2 k = 0, x0 = Random(2, N âˆ’ 1);
3 x i = x0 ;
4 while salir=False do
5
i = 2k âˆ’ 1 ;
6
for j = i + 1, i + 2, ..., 2i + 1 do
x j = f ( x0 ) (mod N ) ;
7
if xi = x j then
8
9
salir=True;
10
Imprimir â€œEl mÃ©todo fallÃ³. Reintentar cambiando f o x0 â€;
11
Exit For;

16

g = mcd ( xi âˆ’ x j , N ) ;
if 1 < g < N then
salir=True;
Imprimir N = N/g Â· g ;
Exit For;

17

x0 = x j ;

12
13
14
15

18
19

xi = x j ;
k + +;

ImplementaciÃ³n en Java. La implementaciÃ³n sigue paso a paso el algoritmo.De nuevo aquÃ­
hacemos un programa independiente. Naturalmente, se puede incluir como un conjunto de
mÃ©todos en Teoria_Numeros.java
La corrida de prueba se hace con un nÃºmero relativamente grande, claro no de varios cientos de
dÃ­gitos... para eso se necesita otros mÃ©todos.

194

NÃšMEROS PRIMOS Y FACTORIZACIÃ“N.

import java.math.BigInteger;
public class rhoPollard
{
rhoPollard(){}
public BigInteger f(BigInteger x)
{
return x.multiply(x).add(BigInteger.ONE);//x^2+1
}
void FactorPollard(BigInteger N)

public
{

int i, k;
BigInteger xi,xj;
BigInteger g

= BigInteger.ONE;

BigInteger x0

= new BigInteger(""+2);;

boolean salir

= false;

k = 0;
xi= x0;
xj= x0;
while(salir==false)
{ i=(int)(Math.pow(2,k)-1);
for(int j=i+1; j<=2*i+1; j++)
{
xj=f(x0).mod(N);
if(xi.compareTo(xj)==0)//si son iguales
{salir=true;
System.out.print("Fallo"+"\n\n");
break;
}
g= N.gcd(xi.subtract(xj));
if(g.compareTo(BigInteger.ONE)==1 && g.compareTo(N)==-1)//1<g<N
{salir=true;
System.out.print("Factor = "+g+"\n\n");
break;
}
x0=xj;
}
xi=xj;
k++;
}
System.out.print(N+" =

"+g+" . "+N.divide(g)+"\n\n");

}
public static void main(String[] args)
{
System.out.print("\n\n");
rhoPollard obj = new rhoPollard();
BigInteger N = new BigInteger("10001449242860005111762859");
obj.FactorPollard(N);
System.out.print("\n\n");
}
}//

EJERCICIOS

195

El resultado de la corrida es,
walter-2@walter2-desktop:~/Escritorio/tn/java$ javac rhoPollard.java
walter-2@walter2-desktop:~/Escritorio/tn/java$ java rhoPollard

Factor = 7368787
10001449242860005111762859 =

7368787 . 1357272132151466057

walter-2@walter2-desktop:~/Escritorio/tn/java$

Refinamiento. En general, hay muchos casos en los que MCD( xi âˆ’ x j , N ) = 1. En vez de calcular todos estos MCD(z1 , N ), MCD(z2 , N ), ..., calculamos unos pocos MCD( Qk , N ), donde Qk =
âˆkj=1 z j (mod N ). Brent sugiere escoger k entre ln N y N 1/4 pero lejos de cualquiera de los dos
extremos ([28]). Riesel ([9]) sugiere tomar k como un mÃºltiplo de 100.

Ejemplo 9.5
Sean N = 3968039, f ( x ) = x2 âˆ’ 1 y x0 = 2. Luego, tomando k = 30
30

Q30 = âˆ z j (mod N ) = 3105033,

mcd ( Q30 , N )

=

âˆ z j (mod N ) = 782878,

mcd ( Q60 , N )

= 1987

1

j =1
60

Q60 =

j=31

EJERCICIOS
9.1

Implementar una variante con el producto Qk = âˆkj=1 z j (mod N ).

9.6

Pruebas de Primalidad.

Para decidir si un nÃºmero n pequeÃ±o es primo, podemos usar el mÃ©todo de ensayo y error para
âˆš
verificar que no tiene divisores primos inferiores a n.
Para un nÃºmero un poco mÃ¡s grande, la estrategia usual es primero verificar si tiene divisores
primos pequeÃ±os, sino se usa el test para seudoprimos fuertes de Miller-Rabin con unas pocas
bases pi (con pi primo) y usualmente se combina con el test de Lucas. Esta manera de proceder
decide de manera correcta si un nÃºmero es primo o no, hasta cierta cota 10 M . Es decir, la combinaciÃ³n de algoritmos decide de manera correcta si n < 10 M Sino, decide de manera correcta

196

NÃšMEROS PRIMOS Y FACTORIZACIÃ“N.

solamente con una alta probabilidad y cabe la (remota) posibilidad de declarar un nÃºmero compuesto como primo.
AquÃ­ solo vamos a tratar rÃ¡pidamente la prueba de Miller-Rabin.

9.7

Prueba de primalidad de Miller-Rabin.

Iniciamos con test de primalidad de Fermat, por razones histÃ³ricas. Esta prueba se basa el el
teorema,

Teorema 9.2 (Fermat)
Sea p primo. Si MCD( a, p) = 1 entonces a pâˆ’1 â‰¡ 1 (mod p).

Este teorema nos dice que si n es primo y a es un entero tal que 1 â‰¤ a â‰¤ n âˆ’ 1, entonces
anâˆ’1 â‰¡ 1 (mod n).
Por tanto, n es compuesto si encontramos 1 â‰¤ a â‰¤ n âˆ’ 1 tal que anâˆ’1 â‰¡
/ 1 (mod n).

DefiniciÃ³n 9.1
Sea n compuesto. Un entero 1 â‰¤ a â‰¤ n âˆ’ 1 para el que anâˆ’1 â‰¡
/ 1 (mod n), se llama â€œtestigo de
Fermatâ€ para n.

Un testigo de Fermat para n serÃ­a un testigo de no-primalidad. De manera similar, un nÃºmero
1 â‰¤ a â‰¤ n âˆ’ 1 para el que anâˆ’1 â‰¡ 1 (mod n), apoya la posibilidad de que n sea primo,

DefiniciÃ³n 9.2
Sea n un entero compuesto y sea a un entero para el cual 1 â‰¤ a â‰¤ n âˆ’ 1 y anâˆ’1 â‰¡ 1 (mod n).
Entonces se dice que n es un seudoprimo respecto a la base a. Al entero a se le llama un
â€œembaucador de Fermatâ€ para n.

Por ejemplo, n = 645 = 3 Â· 5 Â· 43 es un seudoprimo en base 2 pues 2nâˆ’1 â‰¡ 1 (mod n).
Es curioso que los seudoprimos en base 2 sean muy escasos. Por ejemplo, hay 882 206 716 primos inferiores a 2 Ã— 1010 y solo hay 19685 seudoprimos en base 2 inferiores a 2 Ã— 1010 . Esto

EJERCICIOS

197

nos dice que la base 2 parece ser muy poco â€œembaucadoraâ€ en el sentido de que si tomamos un
nÃºmero grande n de manera aleatoria y si verificamos que 2nâˆ’1 â‰¡ 1 (mod n), entonces es muy
probable que n sea primo. TambiÃ©n los seudoprimos en base 3 son muy escasos y es altamente
improbable que si tomamos un nÃºmero grande n de manera aleatoria, este sea compuesto y que
a la vez sea simultÃ¡neamente seudoprimo en base 2 y base 3.
Es decir, si un nÃºmero n pasa los dos test 2nâˆ’1 â‰¡ 1 (mod n) y 3nâˆ’1 â‰¡ 1 (mod n); es muy probable que sea primo.
Sin embargo, hay enteros n compuestos para los cuales anâˆ’1 â‰¡ 1 (mod n) para todo a que
cumpla MCD( a, n) = 1. A estos enteros se les llama nÃºmeros de Carmichael.
Por ejemplo, n = 561 = 3 Â· 11 Â· 17 es nÃºmero de Carmichael. Aunque este conjunto de nÃºmeros
es infinito, son mÃ¡s bien raros (poco densos). En los primeros 100 000 000 nÃºmeros naturales hay
2051 seudoprimos en base 2 y solo 252 nÃºmeros de Carmichael.
Nuestra situaciÃ³n es esta: Es poco probable que un nÃºmero compuesto pase varios test de â€œprimalidadâ€ anâˆ’1 â‰¡ 1 (mod n) excepto los nÃºmeros de Carmichael, que son compuestos y pasan
todos estos test.
Hay otro test, llamado â€œtest fuerte de seudo-primalidad en base aâ€ en el cual los nÃºmeros de
Carmichael no pasan. AdemÃ¡s, si tomamos k nÃºmeros de manera aleatoria a1 , a2 , ..., ak y si n
pasa este test en cada una de las bases ai , podemos decir que la probabilidad de que nos equivoquemos al declarar n como primo es menor que 1/4k . Por ejemplo, si k = 200 la probabilidad
de que nos equivoquemos es < 10âˆ’120

Teorema 9.3
Sea n un primo impar y sea n âˆ’ 1 = 2s r con r impar. Sea a un entero tal que MCD( a, n) = 1.
j
Entonces, o ar â‰¡ 1(mod n) o a2 r â‰¡ âˆ’1(mod n) para algÃºn j, 0 â‰¤ j â‰¤ s âˆ’ 1.

Con base en el teorema anterior, tenemos

DefiniciÃ³n 9.3
Sea n impar y compuesto y sea n âˆ’ 1 = 2s r con r impar. Sea 1 â‰¤ a â‰¤ n âˆ’ 1.
j

a.) Si ar â‰¡/1(mod n) y si a2 r â‰¡/ âˆ’ 1(mod n) para 0 â‰¤ j â‰¤ s âˆ’ 1, entonces a es llamado un
testigo fuerte (de no-primalidad) de n.
j

b.) Si ar â‰¡ 1( mod n) y si a2 r â‰¡ âˆ’1(mod n) para 0 â‰¤ j â‰¤ s âˆ’ 1, entonces n se dice un seudoprimo fuerte en la base a. Al entero a se le llama â€œembaucador fuerteâ€.

AsÃ­, un seudoprimo fuerte n en base a es un nÃºmero que actÃºa como un primo en el sentido
del teorema 9.3.

198

NÃšMEROS PRIMOS Y FACTORIZACIÃ“N.

Teorema 9.4 (Rabin)
Si n es un entero compuesto, a lo sumo
cadores fuertes de n.

1
de todos los nÃºmeros a, 1 â‰¤ a â‰¤ n âˆ’ 1, son embau4

Supongamos que tenemos un nÃºmero compuesto n. Tomamos k nÃºmeros { a1 , a2 , ..., ak } de manera aleatoria y aplicamos el test fuerte de seudo-primalidad a n con cada uno de de estas bases
ai . Entonces, hay menos que un chance en cuatro de que a1 no sea testigo de no-primalidad de
n, y menos que un chance en cuatro de que a2 no sea testigo de no-primalidad de n, etc. Si
n es primo, pasa el test para cualquier a < n. Si cada ai falla en probar que n es compuesto,
1
entonces la probabilidad de equivocarnos al decir que n es primo es inferior a k .
4
9.7.1

Algoritmo e implementaciÃ³n.

Algoritmo 9.4: Miller-Rabin
Datos: n â‰¥ 3 y un parÃ¡metro de seguridad t â‰¥ 1.
Salida: â€œn es primoâ€ o â€œ n es compuestoâ€.
s
1 Calcule r y s tal que n âˆ’ 1 = 2 r, r impar;
2 for i = 1, 2, ..., t do
3
a = Random(2, n âˆ’ 2);
4
y = ar (mod n);
5
if y 6= 1 y y 6= n âˆ’ 1 then
6
j = 1;
7
while j â‰¤ s âˆ’ 1 y y 6= n âˆ’ 1 do
8
y = y2 (mod n);
9
if y = 1 then
10
return â€œCompuestoâ€;
11
12
13

14

j = j + 1;
if y 6= n âˆ’ 1 then
return â€œCompuestoâ€;
return â€œPrimoâ€;

Todo primo impar n âˆ’ 1 se puede expresar como n âˆ’ 1 = 2 j r, con r impar.
El algoritmo 9.4 verifica si en cada base a se satisface la definiciÃ³n 9.3. En la lÃ­nea 9, si y = 1,
j
j âˆ’1
/ Â± 1 (mod n) entonces n es
entonces a2 r â‰¡ 1 (mod n). Puesto que este es el caso cuando a2 r â‰¡
compuesto. Esto es asÃ­ pues si x2 â‰¡ y2 (mod n) pero si x â‰¡
/ Â± y (mod n), entonces MCD( x âˆ’ y, n)
es un factor no trivial de n. En la lÃ­nea 12, si y 6= n âˆ’ 1, entonces a es un testigo fuerte de n.
Si el algoritmo 9.4 declara compuesto a n entonces n es definitivamente compuesto, por el
teorema 9.3. Si n es primo, es declarado primo. Si n es compuesto, la probabilidad de que el
algoritmo lo declare primo es inferior a 1/4t .

EJERCICIOS

199

El algoritmo 9.4 requiere, para n âˆ’ 1 = 2 j r con r impar, t(2 + j) ln n pasos. t es el nÃºmero de
bases.
Una estrategia que se usa a veces es fijar las bases. Se toman como base algunos de los primeros
primos en vez de tomarlas de manera aleatoria. El resultado importante aquÃ­ es este: Si p1 , p2 , ..., pt
son los primeros t primos y si Ïˆt es el mÃ¡s pequeÃ±o entero compuesto el cual es seudoprimo
para todas las bases p1 , p2 , ..., pt , entonces el algoritmo de Miller-Rabin, con las bases p1 , p2 , ..., pt ,
siempre responde de manera correcta si n < Ïˆt . Para 1 â‰¤ t â‰¤ 8 tenemos

t
1
2
3
4
5
6
7
8

Ïˆt
2047
1 373 653
25 326 001
3 215 031 751
2 152 302 898 747
3 474 749 660 383
341 550 071 728 321
341 550 071 728 321

ImplementaciÃ³n en Java. En la clase BigInteger de Java ya viene implementado el mÃ©todo
this.modPow(BigInteger r, BigInteger N) para calcular y = ar (mod N). Para calcular r y s
solo se divide N âˆ’ 1 por dos hasta que el residuo sea diferente de cero.
En esta implementaciÃ³n usamos los primeros ocho primos como bases. AsÃ­ el algoritmo responde
de manera totalmente correcta si 19 < N < 341550071728321. En todo caso, tambiÃ©n podemos
usar el mÃ©todo this.isProbablePrime(int c) que responde correctamente con una probabili1
dad que excede 1 âˆ’ c .
2
import java.math.BigInteger;
import java.util.*;
public class Miller_Rabin
{
public Miller_Rabin(){}
public boolean esPrimoMR(BigInteger N)
{

//n>3 e impar. Respuesta 100% segura si N <341 550 071 728 321
BigInteger

N1

= N.subtract(BigInteger.ONE);//N-1

BigInteger

DOS

= new BigInteger("2");

int[]

primo

= {2,3,5,7,11,13,17,19};

int

s

= 0;

boolean

esPrimo = true;

BigInteger

a,r,y;

int

j;

200

NÃšMEROS PRIMOS Y FACTORIZACIÃ“N.

while(N1.remainder(DOS).compareTo(BigInteger.ZERO)==0)//n-1 = 2^s r
{

N1=N1.divide(DOS);
s=s+1;

}
r

= N1;

N1 = N.subtract(BigInteger.ONE);
for(int i=0; i<=7; i++)
{

a = new BigInteger(""+primo[i]);
y = a.modPow(r, N);
if( y.compareTo(BigInteger.ONE)!=0 && y.compareTo(N1)!=0)
{ j=1;
while(j<= s-1 && y.compareTo(N1)!=0 )
{

y = y.modPow(DOS, N);
if(y.compareTo(BigInteger.ONE)==0) esPrimo=false;
j++;

}
if(y.compareTo(N1)!=0) esPrimo = false;
}
}
return esPrimo;
}
public static void main(String[] args)
{
System.out.println("\n\n");
BigInteger

N

Miller_Rabin

= new BigInteger("10011572903");
obj = new Miller_Rabin();

System.out.println(N+" es primo = "+obj.esPrimoMR(N)+"\n\n");
System.out.println("\n\n");
}
}

El resultado de compilar y correr este programa es,
walter-2@walter2-desktop:~/Escritorio/tn/java$ javac Miller_Rabin.java
walter-2@walter2-desktop:~/Escritorio/tn/java$ java Miller_Rabin
10011572903 es primo = true
walter-2@walter2-desktop:~/Escritorio/tn/java$

EJERCICIOS
9.2

Esta implementaciÃ³n falla para n = 2, 3, 5, 7, 11, 13, 17, 19. Â¿PorquÃ©?

EJERCICIOS

9.3

201

Mejore la implementaciÃ³n anterior.

9.8

Algoritmo Chino del Resto.

El problema clÃ¡sico conocido como problema chino del resto puede ser establecido como sigue:

Dados los mÃ³dulos m0 , m1 , ..., mk âˆˆ Z y los residuos correspondientes ui âˆˆ Zmi con i = 0, 2..., k;
encontrar un entero u tal que
u â‰¡ ui (mod mi ), 0 â‰¤ i â‰¤ k.

(9.1)

Las condiciones bajo las cuales se puede garantizar la existencia de una soluciÃ³n Ãºnica para este
problema se establecen en el siguiente teorema,

Teorema 9.5 (Chino del Resto)
Sean m0 , m1 , ..., mk âˆˆ Z primos relativos dos a dos, i.e. mcd (mi , m j ) = 1 si i 6= j, y consideremos
los k residuos ui âˆˆ Zmi , 0 â‰¤ i â‰¤ k. Para cada entero fijo a existe un Ãºnico entero u âˆˆ Z que
satisface las condiciones
ï£±
ï£´
ï£´
ï£´
ï£² aâ‰¤u<a+m
ï£´
ï£´
ï£´
ï£³

u â‰¡ ui (mod mi ),

k

con m = âˆmi ;
i =0

0â‰¤iâ‰¤k

Ejemplo 9.6
ï£±
ï£² u
Consideremos
u
ï£³
u

â‰¡
49 (mod) 99
â‰¡ âˆ’21 (mod) 97
â‰¡ âˆ’30 (mod) 95

AquÃ­ m = 912285. Si a = 0 tenemos u = 639985.
La unicidad es â€œmÃ³dulo m,â€ es decir, el problema chino del resto tiene infinitas soluciones en Z
k

pero tiene soluciÃ³n Ãºnica en Zm , con m = âˆmi .
i =0

Para ver la idea de la prueba, vamos a introducir una notaciÃ³n que nos va a servir mÃ¡s adelante.
Consideremos el Homomorfismo modular Ï†m : Z[ x ] âˆ’â†’ Zm [ x ] (m â‰¥ 2), definido por
Ï•m ( x ) = x

202

NÃšMEROS PRIMOS Y FACTORIZACIÃ“N.

Ï•m ( a) = rem( a, m) para todo a âˆˆ Z.
De acuerdo a la definiciÃ³n, Ï•m ( A( x )) solo cambia los coeficientes ai por los nuevos coeficientes
ai mod m. Por ejemplo, Ï•5 (3x6 âˆ’ x4 + 6x3 + x2 âˆ’ 3x ) = 3x6 + 4x4 + x3 + x2 + 2x.
Si u âˆˆ Zm entonces ( Ï•m0 (u), Ï•m1 (u), ...Ï•mn (u)) es uno de los m = âˆin=0 mi distintos n + 1âˆ’ tuples
posibles en Zm0 Ã— Zm1 Ã— ... Ã— Zmn . Si calculamos ( Ï•m0 (u), Ï•m1 (u), ...Ï•mn (u)) para cada u âˆˆ Zm ,
en algÃºn momento encontrarÃ­amos un u âˆˆ Zm tal que

( Ï•m0 (u), Ï•m1 (u), ...Ï•mn (u)) = (u0 , u1 , ..., un ).
AsÃ­, la unicidad de u debe entenderse en el sentido de que u es Ãºnico en Zm no en Z, es decir
u es Ãºnico mÃ³dulo m.
La idea de la prueba del teorema chino del resto nos dice cÃ³mo encontrar u. Lamentablemente
no es prÃ¡ctico buscar u de esta manera pues m puede ser muy grande.
9.8.1

Algoritmo e implementaciÃ³n.

El algoritmo usual para resolver este tipo de problemas se llama â€œalgoritmo de Garnerâ€ (por
H.L. Garner). La idea central del mÃ©todo de Garner es, a la manera del polinomio interpolante
de Newton, representar u como una combinaciÃ³n lineal de â€œbase mixtaâ€,

n âˆ’1

âˆ mi

u = v0 + v1 (m0 ) + v2 (m0 m1 ) + ... + vn

!
(9.2)

i =0

con vk âˆˆ Zmk , k = 0, 1, ..., n.
Si m es impar, la representaciÃ³n simÃ©trica de Zm es Zm = {âˆ’

mâˆ’1
mâˆ’1
, ..., âˆ’1, 0, 1, ...,
}
2
2

La representaciÃ³n de u como una combinaciÃ³n lineal de â€œbase mixtaâ€ tiene sentido si cada vk âˆˆ
Zmk tiene el mismo tipo de representaciÃ³n, es decir siempre (para cada k ) Zmk = {0, 1, ..., mk âˆ’ 1}
o siempre Zmk = {v : âˆ’mk /2 < v â‰¤ mk /2}.
Se puede probar que u siempre se puede representar en la forma (9.2) y, escogida un representaciÃ³n igual para todos los Zmk , los coeficientes vi son Ãºnicos.
Ejemplo 9.7
Sean m0 = 99, m1 = 97, y m2 = 95. Si u = 639985,
u = 49 + 62 Â· (m0 ) + 66 Â· (m0 m1 ).
Encontrar u es lo mismo que encontrar v0 , v1 , ..., vn .
Para i = 0, de la representaciÃ³n (9.2) se deduce u â‰¡ v0 (mod m0 ). AsÃ­ que u â‰¡ u0 (mod m0 ) tiene
soluciÃ³n u = u0 .
Para k â‰¥ 1, si se han obtenido los coeficientes v0 , v1 , ..., vkâˆ’1 , entonces de (9.2),

EJERCICIOS

k âˆ’1

âˆ mi

u â‰¡ v0 + v1 (m0 ) + ... + vk

203

!

(mod mk )

i =0

satisface el caso i = k del sistema de congruencias u â‰¡ ui (mod mi ), 0 â‰¤ i â‰¤ n, si se toma vk de
tal manera que
k âˆ’1

v0 + v1 (m0 ) + ... + vk

âˆ mi

!

â‰¡ uk (mod mk )

i =0

Esta ecuaciÃ³n la podemos resolver para un Ãºnico vk âˆˆ Zmk (k â‰¥ 1),
"
vk â‰¡

uk âˆ’ v0 + v1 (m0 ) + ... + vkâˆ’1

k âˆ’2

âˆ mi

i =0

!#!

k âˆ’1

âˆ mi

! âˆ’1

(mod mk )

i =0

El inverso se puede tomar pues âˆik=âˆ’01 mi y mk son primos relativos.
Algoritmo 9.5: Problema Chino del Resto en Z. Algoritmo de Garner

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16

Datos: (u0 , u1 , ...un ), (m0 , m1 , ..., mn ) con mi âˆˆ Z positivos y primos relativos dos a dos y
u i âˆˆ Zm i .
Salida: u âˆˆ Zm con m = âˆin=0 mi tal que u â‰¡ ui (mod mi ), i = 0, 1, ..., n.
CÃ¡lculo de inversos;
for k = 1 to n do
producto = Ï•mk (m0 ) ;
for i = 1 to k âˆ’ 1 do
producto = Ï•mk (producto Â· mi ) ;
Î³k = (producto)âˆ’1 (mÃ³d mk ) ;
CÃ¡lculo de los vk ;
v0 = u0 ;
j = 0;
for k = 1 to n do
temp = vkâˆ’1 ;
j = k âˆ’ 2;
while j â‰¥ 0 do
temp = Ï•mk (temp Â· m j + v j ) ;
j = j âˆ’ 1;
vk = Ï•mk ((uk âˆ’ temp)Î³k ) ;

22

Pasar u a base 10 ;
u = vn ;
j = n âˆ’ 1;
while j â‰¥ 0 do
u = u Â· mj + vj ;
j = j âˆ’ 1;

23

return u ;

17
18
19
20
21

204

NÃšMEROS PRIMOS Y FACTORIZACIÃ“N.

En este algoritmo, la soluciÃ³n u entra â€œrepresentadaâ€ en tÃ©rminos de los n + 1 residuos u0 , u1 , ..., un
respecto a los n + 1 mÃ³dulos m0 , m1 , ..., mn . Luego se pasa a una representaciÃ³n v0 , v1 , ..., vn respecto a la base mixta 1, m0 , ..., âˆin=âˆ’01 mi y, como paso final, se reconstruye u en base 10.
Para obtener u en el paso final, se usa una multiplicaciÃ³n anidada
u = v0 + m0 (v1 + m1 (v2 + ... + mnâˆ’2 (vnâˆ’1 + mnâˆ’1 (vn ))...))
En este Ãºltimo paso, cada iteraciÃ³n actualiza u como u = u Â· m j + v j con j = n âˆ’ 1, n âˆ’ 2, ..., 0.
AquÃ­ no es necesario poner u = Ï•m (u Â· m j + v j ) pues estas sumas estÃ¡n en el rango correcto,
es decir u Â· m j + v j âˆˆ Zm no importa la representaciÃ³n que se haya usado. En efecto, como
m
|vk | â‰¤ k entonces, de acuerdo a (9.2), |u| â‰¤ (âˆin=0 mi ) /2 = m/2. Si usamos la representaciÃ³n
2
{0, ..., m âˆ’ 1} de Zm obtenemos de manera similar, u â‰¤ m âˆ’ 1.
ImplementaciÃ³n en Java.
import java.math.BigInteger;
class PCR
{ PCR(){}
public BigInteger reprSimetrica(BigInteger m, BigInteger p)
{ BigInteger salida;
BigInteger DOS = new BigInteger("2");
salida = m.mod(p);
//representaci\â€™on sim\â€™etrica de Z_p =]-p/2,...-1,0,1,...,p/2]
//si salida > p/2 -> salida= - p = -p/2 +i.
if(salida.compareTo(p.divide(DOS))==1)
salida = salida.add(p.negate());
return salida;
}
//Algoritmo Chino del Resto
public static BigInteger Z_ACR(BigInteger Uis[], BigInteger Ms[])
{ //Requiere Ms[i]>2.
int

n

BigInteger u

= Ms.length-1; //Ms[0],...,Ms[n]
= BigInteger.ZERO;

BigInteger producto = BigInteger.ONE;
BigInteger temp;
BigInteger gamma[] = new BigInteger[n+1]; //gamma[1],...,gamma[n]
BigInteger v[] = new BigInteger[n+1];
//para k=1,2,...,n, gamma_k = (Prod mi_{i=0}^{k-1})^{-1} Mod m_k.
for(int k=1; k<=n; k++)
{

producto = Ms[0].mod(Ms[k]);
for(int i=1; i<= k-1; i++)
producto = (producto.multiply(Ms[i])).mod(Ms[k]);
gamma[k] = producto.modInverse(Ms[k]);

}
int j;
v[0]=Uis[0];
for(int k=1; k<=n; k++)

EJERCICIOS

{

205

temp = v[k-1];
j=k-2;
while(j>=0)
{temp = ((temp.multiply(Ms[j])).add(v[j])).mod(Ms[k]);
j=j-1;
}
v[k]= (Uis[k].subtract(temp)).multiply(gamma[k]).mod(Ms[k]);

}
u = v[n];
j = n-1;
while(j >= 0)
{u = (u.multiply(Ms[j])).add(v[j]);
j = j-1;
}
return u;
}
public static void main(String[] args)
{
System.out.print("\n\n");
PCR

obj = new PCR();

BigInteger uis[]={new BigInteger("49"),new BigInteger("-21"),
new BigInteger("-30")};
BigInteger mis[]={new BigInteger("99"),new BigInteger("97"),
new BigInteger("95")};
System.out.println(""+obj.Z_ACR(uis, mis));
System.out.print("\n\n");
}
}

El programa estÃ¡ preparado para resolver
ï£±
ï£² u
Consideremos
u
ï£³
u

â‰¡
49 (mod) 99
â‰¡ âˆ’21 (mod) 97
â‰¡ âˆ’30 (mod) 95

AquÃ­ m = 912285. Si a = 0 tenemos u = 639985. Este resultado se obtuvo despuÃ©s de compilar
y correr el programa,
walter-2@walter2-desktop:~/Escritorio/tn/java$ javac PCR.java
walter-2@walter2-desktop:~/Escritorio/tn/java$ java PCR
639985
walter-2@walter2-desktop:~/Escritorio/tn/java$

206

NÃšMEROS PRIMOS Y FACTORIZACIÃ“N.

VersiÃ³n actualizada de este libro: https://tecdigital.tec.ac.cr/revistamatematica/Libros/

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)

EJERCICIOS

207

BibliografÃ­a
[1] R. Carmichael. The Theory of Numbers. 1er Ed. John Wiley and Sons, 1914.
[2] P. Ribenboim. The Little Book of Bigger Primes. Springer, 2004.
[3] T. Koshy. Elementary Number Theory with Applications. 2da. Ed. Academic Press, 2007.
[4] N. Koblitz A course in number theory and cryptography. 2da ed., Springer,1994.
[5] H. Cohen Number theory. Volume I: Tools and Diophantine Equations. Springer, 2007.
[6] H. Cohen A course in computational algebraic number theory. Springer, 1996.
[7] Lindsay N. Childs. A Concrete Introduction to Higher Algebra. Springer-Verlag New York,
1995.
[8] G.H. Hardy, J.E. Littlewood. An Introduction to Theory of Numbers. Oxford Univ. Press.
1938.
[9] Hans Riesel. Prime Numbers and Computer Methods for Factorization. Springer; 2 edition.
1994.
[10] Mark Kac. Statistical Independence in Probability Analysis and Number Theory. John Wiley
and Sons, Inc. 1964.
[11] Harold Stark, An introduction to number theory. The MIT Press, 1987.
[12] M. Atallah, M. Blanton (2010). Algorithms and theory of computation handbook. General concepts and techniques. Chapman & Hall. CRC applied algorithms and data structures series.
2nd ed.
[13] E. Bach, J. Shallit (1996). Algorithmic Number Theory, Vol. 1: Efficient Algorithms. Cambridge,
MA: MIT Press, 1996.
[14] M. Oâ€™Neill., â€œThe Genuine Sieve of Eratosthenesâ€. Journal of Functional Programming.
Published online by Cambridge University Press. October 2008.
[15] Jonathan Sorenson. â€œAn Analysis of Two Prime Number Sievesâ€. Computer Sciences
Technical Report #1028. Department of Computer Sciences University of WisconsinMadison, June 10. 1991
[16] T. Jebelean (1993). â€œComparing several GCD algorithmsâ€. En ARITH-11: IEEE Symposium on Computer Arithmetic. IEEE, New York, 180-185.
[17] D. Knuth (1981). The Art of Computer Programming. Volume 1: Fundamental Algorithms.
Addison-Wesley. 2nd ed.
[18] D. Knuth (1981). The Art of Computer Programming. Volume 2: Seminumerical Algorithms.
Addison-Wesley. 2nd ed.
[19] G. Norton (1987). A shift-remainder GCD algorithm. Proceedings of the 5th international
conference, AAECC-5 on Applied Algebra, Algebraic Algorithms and Error-Correcting
Codes, p.350-356, 1987.
[20] J. Shallit, J. Sorenson (1994). Analysis of a Left-Shift Binary GCD Algorithm. J. Symbolic
Computation (1994) 17, 487-511
[21] A. Stepanov (2007). Notes on Programming. En http://www.stepanovpapers.com
[22] A. Stepanov, P. McJones (2009). Elements of Programming. Addison-Wesley.
[23] A.Weilert (2000). (1 + i )âˆ’ary GCD Computation in Z [i ] as an Analogue to the Binary
GCD Algorithm.J. Symbolic Computation (2000) 30, 605-617.
[24] William H. Press et all, NUMERICAL RECIPES. The Art of Scientific Computing. Third
Edition. Cambrifge University Press.
[25] S. Y. Yan. Number Theory for Computing. 2nd edition. Springer. 2001.

[26] Eric Weisstein, â€œPolygonal Number.â€ MathWorldâ€“A Wolfram Web Resource. http://
mathworld.wolfram.com/PolygonalNumber.html

[27] Jim
The

Delany, â€œGeometric Proof of the Tetrahedral Number Formulaâ€.
Wolfram
Demonstrations
Project.
http://demonstrations.wolfram.com/

GeometricProofOfTheTetrahedralNumberFormula/

[28] R. Brent. â€œAn Improved Monte Carlo Factorization Algorithm.â€ BIT 20 (1980), 176-184.
http://wwwmaths.anu.edu.au/~brent/pub/pubsall.html

[29] R. Brent, J. M. Pollard. â€œFactorization of the Eighth Fermat Number.â€ Mathematics of
Computation, vol 36, n 154 (1981), 627-630. http://wwwmaths.anu.edu.au/~brent/pub/
pubsall.html.
[30] Harold M. Edwards. Riemannâ€™s Zeta Function. Dover Publications Inc. 2001.

SoluciÃ³n de los Ejercicios

Soluciones del CapÃ­tulo 2
2.1 6|2 Â· 3 pero 6 - 2 y 6 - 3
2.2 si d| a âˆ§ d|( a + 1) =â‡’ d|( a + 1 âˆ’ a) Luego, d|1 =â‡’ d = Â±1.
2.3 Si kd|n =â‡’ n = k0 kd =â‡’ d|n (â‡’â‡)
2.4 Como d| a y d|b =â‡’ d|( a âˆ’ bq) =â‡’ d|r
2.5 Como a âˆ’ r = bq y 0 â‰¤ r < |b|, bq debe ser uno de los nÃºmeros { a, a âˆ’ 1, ..., a âˆ’ |b| + 1}
2.6 d| a y d|( ab + 2) =â‡’ d| ab âˆ§ d|( ab + 2) =â‡’ d|2 =â‡’ d = 1, âˆ¨ d = 2, pero como a es impar,
d = 1.
2.7 | A3 âˆª B5 âˆª C7 | = | A3 | + | B5 | + |C7 | âˆ’ | A3 âˆ© B5 | âˆ’ | B5 âˆ© C7 | âˆ’ |C7 âˆ© A3 | + | A3 âˆ© B5 âˆ© C7 | = 1629.

2.9 Si a = 6, b = 3; 3 = mcd (6, 3) 6= mcd (6, 6) 6= mcd (6, 6 âˆ’ 4 Â· 3).
2.10 Sean d = mcd ( ab, m), d1 = mcd ( a, m), d2 = mcd (b, m). Por Bezout,
ï£±
ï£² ax1 + my1 = d1
=â‡’ abx + my = d1 d2 =â‡’ d|d1 d2
ï£³
bx2 + my2 = d2
2.11 Sean d = mcd ( ab, m), d1 = mcd ( a, m), d2 = mcd (b, m).
Por Bezout, ax + by = 1, luego axm + bym = m. Como d1 es mÃºltiplo de a y d2 es mÃºltiplo de
m, se sigue axm = k1 d1 d2 . De manera anÃ¡loga, bym = k2 d1 d2 .
AsÃ­, d1 d2 |m âˆ§ d1 d2 | ab y entonces d1 d2 |d. Usando el ejercicio anterior se concluye que d1 d2 = d.


ax + by
as + ct
xct + sby) + bc(yt) = 1, es decir, mcd ( a, bc) = 1.

2.13 Por Bezout, existen x, y, s, t âˆˆ Z tal que

= 1
, Multiplicando obtenemos a( axs +
= 1

2.15 Por Bezout ax + by = d =â‡’ k1 x + k2 y = 1, por (2.1, 4) mcd (k1 , k2 ) = 1
2.16 ra + sb = d =â‡’ rk1 d + sk2 d = d =â‡’ rk1 + sk2 = 1 =â‡’ mcd (r, s) = 1 por (2.1, 4).
2.17 Sea d = mcd ( a, b), a y b son mÃºltiplos de d, entonces am + bn = h =â‡’ k1 dm + k2 dn =
h =â‡’ d|h.
2.18 â€œ=â‡’ â€: es el ejercicio anterior.
â€œâ‡= â€: Sea d = mcd ( a, b) y sea h = kd. Usando el algoritmo extendido de Euclides podemos
calcular x1 , y1 âˆˆ Z tal que ax1 + by1 = d =â‡’ ax1 k + by1 k = kd = h. Luego, la soluciÃ³n de la
ecuaciÃ³n diofÃ¡ntica es x = x1 k y y = y1 k.
2.19 Por el algoritmo extendido de Euclides, 1 = 365 Â· âˆ’699 + 1876 Â· 136 luego 24 = 365 Â· âˆ’16776 +
1876 Â· 3264
p
2.20 Seap k2 âˆ’ kp = d âˆˆ N. Luego k2 âˆ’ kp âˆ’ d2 = 0 de donde
p Â± p2 + 4 Â· 1 Â· d2
(âˆ—)
k=
2
p
k es entero, asÃ­ que p2 + 4d2 debe ser cuadrado perfecto, sea p2 + 4d2 = a2 , entonces
p = ( a âˆ’ 2d)( a + 2d)
como p es primo, solo tenemos las dos posibilidades siguientes,
1. p = ( a âˆ’ 2d) y p = ( a + 2d)
2. p2 = a + 2d y a âˆ’ 2d = 1 pues a + 2d â‰¥ a âˆ’ 2d.
En el primer caso d = 0 (y a = p). Entonces k = 0 o k = p
En el segundo caso, resolvemos el sistema y obtenemos d = ( p2 âˆ’ 1)/2 (y a = ( p2 + 1)/2 ). Como
a, d son naturales, este caso se cumple si p es impar, es decir p 6= 2. Sustituyendo d en (âˆ—) y
resolviendo queda k = ( p + 1)/2 y k = âˆ’( p âˆ’ 1)/2.
Note que si p = 2 solo puede suceder el primer caso y queda k = 0 o k = 2.
2.21 Para n = 2 es cierto, por el lema de Euclides.
Si es cierto para n = k y pi |(q1 q2 Â· sqk ) Â· qk+1 , por el lema de Euclides, pi |(q1 q2 Â· sqk ) o pi |qk+1 .
Aplicando la hipÃ³tesis de inducciÃ³n en el primer caso pi |q j para algÃºn j âˆˆ {1, 2, ..., k }, sino
p i | q k +1 .
209

210

SOLUCIÃ“N DE LOS EJERCICIOS

Î²j

Î±

2.26 Sean a = âˆi pi i , m = âˆ j q j y n = âˆs rsÎ´s la descomposiciÃ³n prima de estos nÃºmeros. Luego,
como mn y ak son iguales, su descomposiciÃ³n prima es la misma excepto por el orden de los
factores, i.e.
k Â· Î±i

Î²j

Î´
âˆ j q j âˆ s r s s = âˆi pi

Î²j

k Â· Î±i

Entonces para cada j, q j = pi
kÎ±d

âˆd pd

j

j

k Â· Î±is

y para cada s, rsÎ´s = pis

k
t
. Luego, m = âˆt pkÎ±
t = x y n=

= yk .

2.29 Hay un k âˆˆ Z tal que p âˆ’ 3 = 4k, entonces p âˆ’ 7 = 4(k âˆ’ 1), por tanto 4| p âˆ’ 7. Usando
la misma idea, comprobamos que 3| p âˆ’ 7. Como mcd (3, 4) = 1, mcm (3, 4) = 12 y entonces
12| p âˆ’ 7.
2.31 Si p1 , p2 , p3 son primos, mcd ( p1 p2 , p2 p3 , p1 , p3 ) = 1 y mcd ( pi p j , p j pk ) 6= 1. TambiÃ©n, si
a = 2 Â· 3 Â· 5, b = 5 Â· 7 Â· 11 y c = 11 Â· 2, mcd ( a, b, c) = 1
mcd ( a, b) = 5
mcd ( a, c) = 2
mcd (b, c) = 11
2.32 Sea d = mcd ( a, a + 1). Como d| a âˆ§ d|( a + 1) =â‡’ d|1. Luego, d = 1.
Otra manera: d = mcd ( a âˆ’ 1, a) =â‡’ d â‰¤ a âˆ’ ( a âˆ’ 1) = 1 pues d es la mÃ­nima combinaciÃ³n lineal
positiva de a y a âˆ’ 1.
2.33 m = mcd ( a, b) = mcm ( a, b) =â‡’ m| a âˆ§ m|b âˆ§ a|m âˆ§ b|m =â‡’ a = b (por ser ambos
positivos).
2.34 Sea d = mcd (mg, g), entonces d| g =â‡’ d â‰¤ g. Pero g| g âˆ§ g| gm, entonces g = d.
2.35 mcd ( a, b) = mcd ( a, k a) = a segÃºn el ejercicio anterior. mcm ( a, b) =

ab
= b.
a

2.36
â€œ=â‡’ â€: g| x y g|y =â‡’ g|s.
â€œâ‡= â€: g|s =â‡’ s = kg = (k âˆ’ 1) g + g. AsÃ­, si x = (k âˆ’ 1) g y y = g entonces s = x + y y mcd ( x, y) =
mcd ((k âˆ’ 1) g, g) = g, por ser g positivo.
a c
ad + bc
+ =
âˆˆ Z, entonces bd|( ad + bc). Como ad + bc = bd se tiene que b|( ad + bc)
b d
bd
y d|( ad + bc). Luego, b| ad âˆ§ d|bc. Finalmente, como mcd ( a, b) = mcd (c, d) = 1 se concluye que
b|d âˆ§ d|b, es decir | a| = |b|.

2.37 Si

2.38 Sea d = mcd ( a, b) y m = mcd ( a, b, ax + by). Como d| a âˆ§ d|b =â‡’ d|( ax + by) y por tanto
d|m.
Luego, como m| a âˆ§ m|b =â‡’ m|d.
âˆ´ d = m, por ser ambos positivos.
2.39 d = mcd ( a, a + 2) =â‡’ d| a âˆ§ d|( a + 2) =â‡’ d|2 =â‡’ d = 1 âˆ¨ d = 2.
9.1 Muestre que si n = pq, con p, q factores no triviales de n y p|(y âˆ’ x ) y n - (y âˆ’ x ), entonces
1 < mcd (y âˆ’ x, n) < n.
2.40 Usar la factorizaciÃ³n prima de N y deducir que sus factores no son los pi0 s.

SOLUCIÃ“N DE LOS EJERCICIOS

211

2.41 Sea dm = mcd (ma, mb) y d = mcd ( a, b). Por Bezout, existen x, y, s, t âˆˆ Z tal que
dm = amx + bmy = m( ax + by) = m(kd) pues d|( ax + by). Luego, md|dm .
d = as + bt =â‡’ md = (ma)s + (mb)t =â‡’ dm |md.
md|dm âˆ§ dm |md =â‡’ |dm | = |md| =â‡’ dm = |m|d, por ser dm y d positivos.
2.42 d|(2( a + 2b) âˆ’ (2a + b)), i.e. d|3b.
d|(2(2a + b) âˆ’ ( a + 2b)), i.e. d|3a
Luego d| mcd (3a, 3b) =â‡’ d|3 mcd ( a, b) =â‡’ d|3 por ejercicio(2.41). Luego, d = 1 o d = 3.
2.43 Asuma que A es entero. Sea 2Î± la mÃ¡s grande potencia de 2 que es â‰¤ n, i.e. 2Î± â‰¤ n pero
2Î± Â· 2 > n .
Î²

Considere todas las mÃ¡ximas potencias pi i , de los primos impares pi , que no exceden n, es decir,
Î²

Î² +1

pi i â‰¤ n pero pi i

> n. Sea P es producto de todas estas potencias, P = âˆ pi i .
Î²

i

Consideremos el producto


1
2Î± âˆ’1 P 2Î± âˆ’1 P
2Î± âˆ’1 P
2Î± âˆ’1 P
1 1
= 2Î± âˆ’1 P +
+
+ ... +
+ ... +
.
2Î±âˆ’1 P 1 + + + ... +
Î±
2 3
n
2
3
2
n
Analizamos ahora cada fracciÃ³n

2Î± âˆ’1 P
Î´
. Si k tiene factorizaciÃ³n prima k = 2Î´ âˆ qi i ,
k
i

ï£±
2Î± âˆ’1 P
ï£´
ï£´
ï£´
ï£´
ï£² 2Î´ âˆi qÎ´i
i

2Î± âˆ’1 P
=
ï£´
k
ï£´
Î± âˆ’1 P
ï£´
ï£´
ï£³ 2
2Î±

Por definiciÃ³n de P, los qi aparecen en P pero con una potencia igual o mayor, es decir, para
2Î± âˆ’1 P
cada i hay un j tal que qi = p j y Î´i â‰¤ Î² j . Luego, como Î´ â‰¤ Î± âˆ’ 1, entonces
es entero.
Î´
2Î´ âˆ i q i i
Pero, por otra parte, el caso 2Î±âˆ’1 P/2Î± = P/2 = m + 1/2 con m entero, por ser P impar. Resumiendo,

2

Î± âˆ’1

PA

= 2

Î± âˆ’1



1 1
1
P 1 + + + ... +
2 3
n

= 2Î± âˆ’1 P +



2Î± âˆ’1 P
2Î± âˆ’1 P
2Î± âˆ’1 P 2Î± âˆ’1 P
+
+ ... +
+
...
2
3
2Î±
n

= Q + P/2 = Q0 + 1/2,

con Q, Q0 enteros.

Pero si A es entero, 2Î±âˆ’1 PA es entero, mientras que Q0 + 1/2 no (â‡’â‡).

212

SOLUCIÃ“N DE LOS EJERCICIOS

2.47.a La verificaciÃ³n es directa:
Tn2âˆ’1 âˆ’ 2Tnâˆ’1

= (22

n âˆ’1

2n âˆ’1 Â·2

= 2

+ 1 ) 2 âˆ’ 2 ( 22
2n âˆ’1

+2Â·2

n âˆ’1

+ 1)

+ 1 âˆ’ 2 Â· 22

n âˆ’1

âˆ’2

2n

= 2 âˆ’1

2.47.b La fÃ³rmula anterior es una fÃ³rmula recursiva:
n

22 âˆ’ 1 = Tn âˆ’ 2 = Tn2âˆ’1 âˆ’ 2Tnâˆ’1 = Tnâˆ’1 ( Tnâˆ’1 âˆ’ 2), i.e.
Tn âˆ’ 2 = Tnâˆ’1 ( Tnâˆ’1 âˆ’ 2). Luego,
Tn âˆ’ 2

= Tnâˆ’1 ( Tnâˆ’1 âˆ’ 2)
= Tnâˆ’1 ( Tnâˆ’2 ( Tnâˆ’2 âˆ’ 2))
= Tnâˆ’1 Tnâˆ’2 Tnâˆ’3 ( Tnâˆ’3 âˆ’ 2)
..
.
= Tnâˆ’1 Tnâˆ’2 Tnâˆ’3 Â· sT0 ( T0 âˆ’ 2)
= Tnâˆ’1 Tnâˆ’2 Tnâˆ’3 Â· sT0 , pues T0 âˆ’ 2 = 3 âˆ’ 2 = 1

2.47.c Tm = Tmâˆ’1 Â· sTn Â· sT0 + 2. Si mcd ( Tn , Tm ) = d entonces d| Tm =â‡’ d|( Tmâˆ’1 Â· sTn Â· sT0 + 2)
y como d| Tn , d|2. AsÃ­ que d = 1 o d = 2. Pero por definiciÃ³n, Tm y Tn son impares.

IntroducciÃ³n a la TeorÃ­a de NÃºmeros.. Walter Mora F.
Derechos Reservados Â© Revista digital MatemÃ¡tica, EducaciÃ³n e Internet (www.tec-digital.itcr.ac.cr/revistamatematica/)


